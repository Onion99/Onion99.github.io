{"title":"Java并发(2) - synchronize","date":"2021-11-07T18:55:09.000Z","date_formatted":{"ll":"2021年11月7日","L":"2021/11/07","MM-DD":"11-07"},"link":"2021/11/07/FEETAEwJ336KYqim","comments":true,"tags":["并发"],"categories":["Java"],"updated":"2021-11-07T07:51:07.000Z","content":"<blockquote>\n<p>在 Java 中，关键字 synchronized 可以保证在同一个时刻，只有一个线程可以执行某个方法或者某个代码块,也可以保证一个线程的变化(主要是共享数据的变化)被其他线程所看到</p>\n</blockquote>\n<p>锁就是为达到这种互斥访问目的诞生的,从宏观上锁分为乐观锁和悲观锁</p>\n<ul>\n<li>乐观锁：认为读多写少，遇到并发写情况较少\n<ul>\n<li>Java 中 java.util.concurrent.atomic 包下面的原子变量类就是使用了乐观锁的一种实现方式 CAS 实现的</li>\n</ul>\n</li>\n<li>悲观锁：即认为写多，遇到并发写情况较多\n<ul>\n<li>Java 中 synchronized 和 ReentrantLock 等独占锁就是悲观锁思想的实现。</li>\n</ul>\n</li>\n</ul>\n<span id=\"more\"></span>\n<blockquote>\n<p>锁其实就是各个房子的门的关门开门的实现, 不用线程访问不同的锁(门)互不干扰</p>\n</blockquote>\n<h3 id=\"用法\">用法<a title=\"#用法\" href=\"#用法\"></a></h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//this,当前实例对象锁</span></span><br><span class=\"line\"><span class=\"keyword\">synchronized</span>(<span class=\"keyword\">this</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>;j&lt;<span class=\"number\">1000000</span>;j++)&#123;</span><br><span class=\"line\">        i++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//class对象锁</span></span><br><span class=\"line\"><span class=\"keyword\">synchronized</span>(AccountingSync.class)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>;j&lt;<span class=\"number\">1000000</span>;j++)&#123;</span><br><span class=\"line\">        i++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"作用于实例方法\">作用于实例方法<a title=\"#作用于实例方法\" href=\"#作用于实例方法\"></a></h4>\n<blockquote>\n<p>所谓的实例对象锁就是用 synchronized 修饰实例对象中的实例方法，注意这不包括静态方法</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AccountingSync</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//共享资源(临界资源)</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * synchronized 修饰实例方法</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">increase</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        i++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>;j&lt;<span class=\"number\">1000000</span>;j++)&#123;</span><br><span class=\"line\">            increase();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">\t    test1()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test1</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//这个时候两个线程,对象锁是一致的,所以结果无误</span></span><br><span class=\"line\">        AccountingSync instance=<span class=\"keyword\">new</span> AccountingSync();</span><br><span class=\"line\">        Thread t1=<span class=\"keyword\">new</span> Thread(instance);</span><br><span class=\"line\">        Thread t2=<span class=\"keyword\">new</span> Thread(instance);</span><br><span class=\"line\">        t1.start();</span><br><span class=\"line\">        t2.start();</span><br><span class=\"line\">        t1.join();</span><br><span class=\"line\">        t2.join();</span><br><span class=\"line\">        System.out.println(i);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 输出结果:</span></span><br><span class=\"line\"><span class=\"comment\">     * 2000000</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test2</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//这个时候两个线程,对象锁是不一致的,所以结果有误</span></span><br><span class=\"line\">        <span class=\"comment\">//将 synchronized 作用于静态的 increase 方法，这样的话，对象锁就当前类对象</span></span><br><span class=\"line\">        <span class=\"comment\">//由于无论创建多少个实例对象，但对于的类对象拥有只有一个，所有在这样的情况下对象锁就是唯一的</span></span><br><span class=\"line\">        <span class=\"comment\">//new新实例</span></span><br><span class=\"line\">        Thread t1=<span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> AccountingSyncBad());</span><br><span class=\"line\">        <span class=\"comment\">//new新实例</span></span><br><span class=\"line\">        Thread t2=<span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> AccountingSyncBad());</span><br><span class=\"line\">        t1.start();</span><br><span class=\"line\">        t2.start();</span><br><span class=\"line\">        t1.join();</span><br><span class=\"line\">        t2.join();</span><br><span class=\"line\">        System.out.println(i);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 输出结果有问题:</span></span><br><span class=\"line\"><span class=\"comment\">     * 123537</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"作用于静态方法\">作用于静态方法<a title=\"#作用于静态方法\" href=\"#作用于静态方法\"></a></h4>\n<blockquote>\n<p>当 synchronized 作用于静态方法时，其锁就是当前类的 class 对象锁。由于静态成员不专属于任何一个实例对象，是类成员，因此通过 class 对象锁可以控制静态成员的并发操作</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AccountingSyncClass</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 作用于静态方法,锁是当前class对象,也就是AccountingSyncClass类对应的class对象</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">increase</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        i++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">// 非静态,访问时锁不一样不会发生互斥</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">increase4Obj</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        i++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>;j&lt;<span class=\"number\">1000000</span>;j++)&#123;</span><br><span class=\"line\">            increase();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//new新实例</span></span><br><span class=\"line\">        Thread t1=<span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> AccountingSyncClass());</span><br><span class=\"line\">        <span class=\"comment\">//new心事了</span></span><br><span class=\"line\">        Thread t2=<span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> AccountingSyncClass());</span><br><span class=\"line\">        <span class=\"comment\">//启动线程</span></span><br><span class=\"line\">        t1.start();t2.start();</span><br><span class=\"line\">        t1.join();t2.join();</span><br><span class=\"line\">        System.out.println(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"同步代码块\">同步代码块<a title=\"#同步代码块\" href=\"#同步代码块\"></a></h4>\n<ul>\n<li>synchronized 同步块对同一条线程来说是可重入的，不会出现自己把自己锁死的问题</li>\n<li>同步块在已进入的线程执行完之前，会阻塞后面其他线程的进入。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AccountingSync</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> AccountingSync instance = <span class=\"keyword\">new</span> AccountingSync();</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//省略其他耗时操作....</span></span><br><span class=\"line\">        <span class=\"comment\">//使用同步代码块对变量i进行同步操作,锁对象为instance</span></span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span>(instance)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>;j&lt;<span class=\"number\">1000000</span>;j++)&#123;</span><br><span class=\"line\">                    i++;</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        Thread t1 = <span class=\"keyword\">new</span> Thread(instance);</span><br><span class=\"line\">        Thread t2 = <span class=\"keyword\">new</span> Thread(instance);</span><br><span class=\"line\">        t1.start();t2.start();</span><br><span class=\"line\">        t1.join();t2.join();</span><br><span class=\"line\">        System.out.println(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"原理(理解不了的)\">原理(理解不了的)<a title=\"#原理(理解不了的)\" href=\"#原理(理解不了的)\"></a></h3>\n<blockquote>\n<p>monitor 和 Java 对象头是实现 synchronized 的基础</p>\n</blockquote>\n<h4 id=\"moniter\">moniter<a title=\"#moniter\" href=\"#moniter\"></a></h4>\n<p>JVM 基于进入和退出 Monitor 对象来实现方法同步和代码块同步。代码块同步是使用 monitorenter 和 monitorexit 指令实现的， monitorenter 指令是在编译后插入到同步代码块的开始位置，而 monitorexit 是插入到方法结束处和异常处。任何对象都有一个 monitor 与之关联，当且一个 monitor 被持有后，它将处于锁定状态。</p>\n<p>根据虚拟机规范的要求，在执行 monitorenter 指令时，首先要去尝试获取对象的锁，如果这个对象没被锁定，或者当前线程已经拥有了那个对象的锁，把锁的计数器加 1；相应地，在执行 monitorexit 指令时会将锁计数器减 1，当计数器被减到 0 时，锁就释放了。如果获取对象锁失败了，那当前线程就要阻塞等待，直到对象锁被另一个线程释放为止。</p>\n<h4 id=\"对象头\">对象头<a title=\"#对象头\" href=\"#对象头\"></a></h4>\n<p>在 JVM 中，对象在内存中的布局分为三块区域：对象头、实例数据和对齐填充。Java 头对象是实现 synchronized 的锁对象的基础,一般而言,synchronized 使用的锁对象是存储在 Java 对象头里的。</p>\n<p><img src=\"https://z3.ax1x.com/2021/11/04/IeGDeI.png\" alt=\"IeGDeI.png\" loading=\"lazy\" class=\"φbp\"></p>\n<h3 id=\"synchronized与reentrantlock\">synchronized与ReentrantLock<a title=\"#synchronized与reentrantlock\" href=\"#synchronized与reentrantlock\"></a></h3>\n<ul>\n<li>开发\n<ul>\n<li>synchronized 隐式锁, 锁的持有与释放都是隐式的</li>\n<li>ReentrantLock 显示锁, 锁的持有和释放都必须由我们手动编写</li>\n</ul>\n</li>\n<li>性能:由于JDK1.6中加入了针对锁的优化措施（见后面），使得synchronized 与 ReentrantLock 的性能基本持平。ReentrantLock 只是提供了 synchronized 更丰富的功能，而不一定有更优的性能，所以在 synchronized 能实现需求的情况下，优先考虑使用 synchronized 来进行同步。</li>\n</ul>\n<h3 id=\"synchronize-与-volatile-异同\">synchronize 与 volatile 异同<a title=\"#synchronize-与-volatile-异同\" href=\"#synchronize-与-volatile-异同\"></a></h3>\n<ul>\n<li>性能差异\n<ul>\n<li>加锁、解锁的过程是要有性能损耗的</li>\n<li>volatile 变量的读操作的性能几乎与普通变量无差别,虽说写操作由于需要插入内存屏障所以会慢一些,但开销也比volatile低</li>\n</ul>\n</li>\n<li>阻塞\n<ul>\n<li>volatile 是Java虚拟机提供的一种轻量级同步机制，基于内存屏障实现的。不是锁带来的阻塞和性能损耗的问题</li>\n<li>synchronize 实现的锁本质上是一种阻塞锁</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"refer\">Refer<a title=\"#refer\" href=\"#refer\"></a></h3>\n<p><a href=\"https://blog.csdn.net/u010289802/article/details/104228091\" target=\"_blank\">暴力突破 Java 并发 - synchronize 解析_lerendan的博客-CSDN博客</a></p>\n","prev":{"title":"Java并发(3) - Lock","link":"2021/11/07/HcJi8WdXZ8E3DBWS"},"next":{"title":"Java并发(1) - volatile","link":"2021/11/07/VqykJCDZZcenZo3O"},"plink":"http://onion66.gitee.io/blog/2021/11/07/FEETAEwJ336KYqim/","reward":true,"copyright":{"custom":"Copyright:自由转载-非商用-禁止演绎-保持署名（CC BY-NC-ND 4.0）"}}