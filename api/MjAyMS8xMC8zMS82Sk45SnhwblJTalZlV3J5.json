{"title":"安卓优化 - 线程优化","date":"2021-10-31T20:48:51.000Z","date_formatted":{"ll":"2021年10月31日","L":"2021/10/31","MM-DD":"10-31"},"link":"2021/10/31/6JN9JxpnRSjVeWry","comments":true,"tags":["性能优化"],"categories":["Android"],"updated":"2021-10-31T12:48:38.000Z","content":"<h3 id=\"线程调度\">线程调度<a title=\"#线程调度\" href=\"#线程调度\"></a></h3>\n<blockquote>\n<p>任意时刻，只有一个线程占用CPU，处于运行状态</p>\n</blockquote>\n<p>多线程并发：轮流获取cpu使用权<br>\nJVM负责线程调度：按照特定调度模型分配CPU使用权</p>\n<h4 id=\"调度模型\">调度模型<a title=\"#调度模型\" href=\"#调度模型\"></a></h4>\n<ul>\n<li>分时调度模型: 轮流获取,均匀分配cpu时间</li>\n<li>抢占式调度模型:  按照优先级来</li>\n</ul>\n<span id=\"more\"></span>\n<h3 id=\"android异步方式\">Android异步方式<a title=\"#android异步方式\" href=\"#android异步方式\"></a></h3>\n<ul>\n<li>Thread\n<ul>\n<li>最简单、常见的方式</li>\n<li>不易复用，频繁创建销毁开销大</li>\n</ul>\n</li>\n<li>HandlerThread\n<ul>\n<li>自带消息循环的线程</li>\n<li>串行执行,长时间运行，不断从队列中获取任务</li>\n</ul>\n</li>\n<li>IntentService\n<ul>\n<li>继承自Service在内部创建HandlerThread</li>\n<li>异步、不占用主线程</li>\n<li>优先级高，不易被系统kil</li>\n</ul>\n</li>\n<li>AsyncTask\n<ul>\n<li>Android提供的工具类</li>\n<li>无需自己处理线程切换</li>\n</ul>\n</li>\n<li>线程池\n<ul>\n<li>jdk提供的线程池</li>\n<li>易复用，减少频繁创建、销毁的时间</li>\n<li>功能强大：定时、任务列队、并发数控制等</li>\n</ul>\n</li>\n<li>RxJava\n<ul>\n<li>由强大的Scheduler集合提供</li>\n<li>不同类型的区分：IO密集型、CPU密集型</li>\n</ul>\n</li>\n<li>协程</li>\n</ul>\n<h3 id=\"线程使用准则\">线程使用准则<a title=\"#线程使用准则\" href=\"#线程使用准则\"></a></h3>\n<p>1、严禁使用new Thread,因为这样不便控制,可能产生预期之外的事情<br>\n2、提供基础线程池供各个业务栈使用（避免各个业务栈各自维护一套线程池，导致线程数过多）<br>\n3、根据任务类型选择合适的异步方式（优先级低长时间执行-HandlerThread，定时执行-线程池）<br>\n4、创建线程必须命名（方便定位线程归属，运行期Thread.currentThread().setName修改名字）<br>\n5、关键异步任务监控（异步不等于不耗时，AOP的方式来做监控）<br>\n6、重视优先级的设置（Process.setThreadPriority(),可以设置多次）</p>\n","prev":{"title":"安卓优化 - 布局优化","link":"2021/10/31/5FIszA6Ut2OHE8Sg"},"next":{"title":"安卓优化 - 包体积","link":"2021/10/31/9LsQhIFgDkllFt0Q"},"plink":"https://onion99.github.io/2021/10/31/6JN9JxpnRSjVeWry/","reward":true,"copyright":{"custom":"Copyright:自由转载-非商用-禁止演绎-保持署名（CC BY-NC-ND 4.0）"}}