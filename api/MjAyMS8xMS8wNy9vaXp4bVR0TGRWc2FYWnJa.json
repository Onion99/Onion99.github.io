{"title":"Java并发(6) - 线程池","date":"2021-11-07T19:05:17.000Z","date_formatted":{"ll":"2021年11月7日","L":"2021/11/07","MM-DD":"11-07"},"link":"2021/11/07/oizxmTtLdVsaXZrZ","comments":true,"tags":["并发"],"categories":["Java"],"updated":"2021-11-07T11:04:41.000Z","content":"<p>线程池对比new Thread()</p>\n<ul>\n<li>重用存在的线程，减少线程创建、消亡的开销，性能佳。</li>\n<li>可有效控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞</li>\n<li>提供定时执行、定期执行、单线程、并发数控制等功能</li>\n</ul>\n<p>ExecutorService 是最初的线程池接口，ThreadPoolExecutor 类是对线程池的具体实现:</p>\n<div class=\"φbq\"><div class=\"φbs\"><table><thead>\n<tr>\n<th style=\"text-align:center\">构造参数</th>\n<th style=\"text-align:right\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">corePoolSize</td>\n<td style=\"text-align:right\">核心线程的数量,默认情况下,即使核心线程没有任务在执行它也存在的,我们固定一定数量的核心线程且它一直存活,这样就避免了一般情况下CPU创建和销毁线程带来的开销。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">maximumPoolSize</td>\n<td style=\"text-align:right\">最大线程数，当任务数量超过最大线程数时其它任务可能就会被阻塞。最大线程数 = 核心线程 + 非核心线程。非核心线程只有当核心线程不够用且线程池有空余时才会被创建，执行完任务后非核心线程会被销毁。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">keepAliveTime</td>\n<td style=\"text-align:right\">非核心线程的超时时长,当执行时间超过这个时间时,非核心线程就会被回收。当 allowCoreThreadTimeOut设置为true时,此属性也作用在核心线程上</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">unit</td>\n<td style=\"text-align:right\">时间单位</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">workQueue</td>\n<td style=\"text-align:right\">任务队列,我们提交给线程池的 runnable 会被存储在这个对象上</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">threadFactory</td>\n<td style=\"text-align:right\">线程工厂,用于指定为线程池创建新线程的方式</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">handler</td>\n<td style=\"text-align:right\">拒绝策略</td>\n</tr>\n</tbody>\n</table></div></div><span id=\"more\"></span>\n<h3 id=\"线程池分配原则\">线程池分配原则<a title=\"#线程池分配原则\" href=\"#线程池分配原则\"></a></h3>\n<ul>\n<li>当 currentSize &lt; corePoolSize 时,直接启动一个核心线程执行任务</li>\n<li>当 currentSize &gt;= corePoolSize 并且<code>workQueue</code>未满时，添加进来的任务会被安排到<code>workQueue</code>中等待执行</li>\n<li>当<code>workQueue</code>已满，但是 currentSize &lt; maximumPoolSize 时，会立即开启一个非核心线程来执行任务</li>\n<li>当 currentSize &gt;= corePoolSize并且workQueue 已满和currentSize &gt; maximumPoolSize 时, 线程池则拒绝执行该任务,且 ThreadPoolExecutor 会调用 RejectedtionHandler 的<code>rejectedExecution()</code>来通知调用者</li>\n</ul>\n<h3 id=\"任务队列\">任务队列<a title=\"#任务队列\" href=\"#任务队列\"></a></h3>\n<blockquote>\n<p>对于新的任务.要根据任务场景考虑使用什么类型的容器缓存新任务</p>\n</blockquote>\n<div class=\"φbq\"><div class=\"φbs\"><table><thead>\n<tr>\n<th style=\"text-align:center\">实现类</th>\n<th style=\"text-align:center\">类型</th>\n<th style=\"text-align:center\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">SynchronousQueue</td>\n<td style=\"text-align:center\">同步队列</td>\n<td style=\"text-align:center\">该队列不存储元素，每个插入操作必须等待另一个线程调用移除操作，否则插入操作会一直阻塞</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">ArrayBlockingQueue</td>\n<td style=\"text-align:center\">有界队列</td>\n<td style=\"text-align:center\">基于数组的阻塞队列，按照 FIFO 原则对元素进行排序</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">LinkedBlockingQueue</td>\n<td style=\"text-align:center\">无界队列</td>\n<td style=\"text-align:center\">基于链表的阻塞队列，按照 FIFO 原则对元素进行排序</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">PriorityBlockingQueue</td>\n<td style=\"text-align:center\">优先级队列</td>\n<td style=\"text-align:center\">具有优先级的阻塞队列</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">DelayQueue</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">类似于PriorityBlockingQueue，是二叉堆实现的无界优先级阻塞队列。要求元素都实现Delayed接口，通过执行时延从队列中提取任务，时间没到任务取不出来.</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">LinkedBlockingDeque</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">使用双向队列实现的有界双端阻塞队列。双端意味着可以像普通队列一样FIFO（先进先出），也可以像栈一样FILO（先进后出）</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">LinkedTransferQueue</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">它是ConcurrentLinkedQueue、LinkedBlockingQueue和SynchronousQueue的结合体,但是把它用在ThreadPoolExecutor中,和LinkedBlockingQueue行为一致，但是是无界的阻塞队列。</td>\n</tr>\n</tbody>\n</table></div></div><h3 id=\"线程工厂\">线程工厂<a title=\"#线程工厂\" href=\"#线程工厂\"></a></h3>\n<blockquote>\n<p>线程工厂指定创建线程的方式,需要实现 ThreadFactory 接口,并实现 newThread(Runnable r) 方法</p>\n</blockquote>\n<p>Executors 框架已经为我们实现了一个默认的线程工厂:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DefaultThreadFactory</span> <span class=\"keyword\">implements</span> <span class=\"title\">ThreadFactory</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> AtomicInteger poolNumber = <span class=\"keyword\">new</span> AtomicInteger(<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ThreadGroup group;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> AtomicInteger threadNumber = <span class=\"keyword\">new</span> AtomicInteger(<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String namePrefix;</span><br><span class=\"line\"> </span><br><span class=\"line\">    DefaultThreadFactory() &#123;</span><br><span class=\"line\">        SecurityManager s = System.getSecurityManager();</span><br><span class=\"line\">        group = (s != <span class=\"keyword\">null</span>) ? s.getThreadGroup() :</span><br><span class=\"line\">                              Thread.currentThread().getThreadGroup();</span><br><span class=\"line\">        namePrefix = <span class=\"string\">&quot;pool-&quot;</span> +poolNumber.getAndIncrement() +<span class=\"string\">&quot;-thread-&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Thread <span class=\"title\">newThread</span><span class=\"params\">(Runnable r)</span> </span>&#123;</span><br><span class=\"line\">        Thread t = <span class=\"keyword\">new</span> Thread(group, r,namePrefix + threadNumber.getAndIncrement(),<span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (t.isDaemon())</span><br><span class=\"line\">            t.setDaemon(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (t.getPriority() != Thread.NORM_PRIORITY)</span><br><span class=\"line\">            t.setPriority(Thread.NORM_PRIORITY);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> t;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"拒绝策略\">拒绝策略<a title=\"#拒绝策略\" href=\"#拒绝策略\"></a></h3>\n<blockquote>\n<p>线程数量大于等于 maximumPoolSize 且 workQueue 已满，则使用拒绝策略处理新任务</p>\n</blockquote>\n<div class=\"φbq\"><div class=\"φbs\"><table><thead>\n<tr>\n<th style=\"text-align:center\">实现类</th>\n<th style=\"text-align:center\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">AbortPolicy</td>\n<td style=\"text-align:center\">丢弃新任务，并抛出 RejectedExecutionException</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">DiscardPolicy</td>\n<td style=\"text-align:center\">不做任何操作，直接丢弃新任务</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">DiscardOldestPolicy</td>\n<td style=\"text-align:center\">丢弃队列队首的元素，并执行新任务</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">CallerRunsPolicy</td>\n<td style=\"text-align:center\">由调用线程执行新任务</td>\n</tr>\n</tbody>\n</table></div></div><h3 id=\"线程池\">线程池<a title=\"#线程池\" href=\"#线程池\"></a></h3>\n<h4 id=\"fixthreadpool\">FixThreadPool<a title=\"#fixthreadpool\" href=\"#fixthreadpool\"></a></h4>\n<blockquote>\n<p>FixThreadPool 只有核心线程，并且数量固定的，也不会被回收。使用 LinkedBlockingQueue 无界队列，所有线程都活动时，因为队列没有限制大小，新任务会等待执行。由于线程不会回收，FixThreadPool会更快地响应外界请求</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title\">newFixThreadPool</span><span class=\"params\">(<span class=\"keyword\">int</span> nThreads)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ThreadPoolExecutor(nThreads, nThreads, <span class=\"number\">0L</span>, TimeUnit.MILLISECONDS, </span><br><span class=\"line\">                        <span class=\"keyword\">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//使用</span></span><br><span class=\"line\">Executors.newFixThreadPool(<span class=\"number\">5</span>).execute(r);</span><br></pre></td></tr></table></figure>\n<h4 id=\"singlethreadpool\">SingleThreadPool<a title=\"#singlethreadpool\" href=\"#singlethreadpool\"></a></h4>\n<blockquote>\n<p>SingleThreadPool 只有一个核心线程，确保所有任务都在同一线程中按顺序完成。因此不需要处理线程同步的问题</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title\">newSingleThreadPool</span> <span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> FinalizableDelegatedExecutorService ( <span class=\"keyword\">new</span> ThreadPoolExecutor (<span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, TimeUnit. MILLISECONDS, </span><br><span class=\"line\">                        <span class=\"keyword\">new</span> LinkedBlockingQueue&lt;Runnable&gt;()) );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//使用</span></span><br><span class=\"line\">Executors.newSingleThreadPool ().execute(r);</span><br></pre></td></tr></table></figure>\n<h4 id=\"cachedthreadpool\">CachedThreadPool<a title=\"#cachedthreadpool\" href=\"#cachedthreadpool\"></a></h4>\n<blockquote>\n<p>CachedThreadPool 只有非核心线程，最大线程数非常大，所有线程都活动时，会为新任务创建新线程，否则利用空闲线程处理任务。采用 SynchronousQueue 同步队列相当于一个空集合，导致任何任务都会被立即执行。比较适合执行大量的耗时较少的任务。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title\">newCachedThreadPool</span><span class=\"params\">(<span class=\"keyword\">int</span> nThreads)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ThreadPoolExecutor(<span class=\"number\">0</span>, Integer.MAX_VALUE, <span class=\"number\">60L</span>, TimeUnit. SECONDS, </span><br><span class=\"line\">                        <span class=\"keyword\">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//使用</span></span><br><span class=\"line\">Executors.newCachedThreadPool().execute(r);</span><br></pre></td></tr></table></figure>\n<h4 id=\"scheduledthreadpool\">ScheduledThreadPool<a title=\"#scheduledthreadpool\" href=\"#scheduledthreadpool\"></a></h4>\n<blockquote>\n<p>核心线程数固定，非核心线程（闲着没活干会被立即回收）数没有限制</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ScheduledExecutorService <span class=\"title\">newScheduledThreadPool</span><span class=\"params\">(<span class=\"keyword\">int</span> corePoolSize)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ScheduledThreadPoolExecutor</span><span class=\"params\">(<span class=\"keyword\">int</span> corePoolSize)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(corePoolSize, Integer.MAX_VALUE, <span class=\"number\">0</span>, NANOSECONDS, <span class=\"keyword\">new</span> DelayedQueue ());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//使用，延迟1秒执行，每隔2秒执行一次Runnable r</span></span><br><span class=\"line\">Executors.newScheduledThreadPool(<span class=\"number\">5</span>).scheduleAtFixedRate(r, <span class=\"number\">1000</span>, <span class=\"number\">2000</span>, TimeUnit.MILLISECONDS);</span><br></pre></td></tr></table></figure>\n<h3 id=\"关闭线程池\">关闭线程池<a title=\"#关闭线程池\" href=\"#关闭线程池\"></a></h3>\n<ul>\n<li>shutdown()：执行后停止接受新任务，会把队列的任务执行完毕。将线程池状态变为 SHUTDOWN。</li>\n<li>shutdownNow()：也是停止接受新任务，但会中断所有的任务，将线程池状态变为 STOP</li>\n</ul>\n","prev":{"title":"Java并发(7) - ThreadLocal","link":"2021/11/07/MpHTUCP7P1OgtydO"},"next":{"title":"Java并发(5) - 线程协作","link":"2021/11/07/WkWqwHwU8wgNL4cd"},"plink":"http://onion66.gitee.io/blog/2021/11/07/oizxmTtLdVsaXZrZ/","reward":true,"copyright":{"custom":"Copyright:自由转载-非商用-禁止演绎-保持署名（CC BY-NC-ND 4.0）"}}