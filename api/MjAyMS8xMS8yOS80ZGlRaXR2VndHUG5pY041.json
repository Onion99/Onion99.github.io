{"title":"源码学习-HashMap","date":"2021-11-29T23:28:47.000Z","date_formatted":{"ll":"2021年11月29日","L":"2021/11/29","MM-DD":"11-29"},"link":"2021/11/29/4diQitvVwGPnicN5","comments":true,"tags":["源码解析"],"categories":["Java"],"updated":"2021-11-29T15:28:30.000Z","content":"<blockquote>\n<p>Map是什么,可以是一个键到值的Object,可以是一个键值对的集合, 是函数抽象的数学模型</p>\n</blockquote>\n<p>似不似?</p>\n<p>HashMap就是Map实现的佼佼者,它使用哈希表作为底层数据结构</p>\n<blockquote>\n<p>注意哦,作为性能的最上层,HashMap是不考虑线程安全的,这是上层人的优越,多线程情况下,可以选用<code>ConcurrentHashMap</code> &gt; <code>Collections.synchronizedMap(HashMap&lt;&gt;())</code></p>\n</blockquote>\n<span id=\"more\"></span>\n<h3 id=\"结构\">结构<a title=\"#结构\" href=\"#结构\"></a></h3>\n<blockquote>\n<p>当Node数组的长度大于8时,会转变红黑树来存储</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HashMap</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">AbstractMap</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Map</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt;, <span class=\"title\">Cloneable</span>, <span class=\"title\">Serializable</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 存储数据的Node数组,一枪秒了有木有,一看就是链表结构 </span></span><br><span class=\"line\">  <span class=\"keyword\">transient</span> Node&lt;K,V&gt;[] table;   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://z3.ax1x.com/2021/11/22/Iz66S0.png\" alt=\"Iz66S0.png\" loading=\"lazy\" class=\"φbp\"></p>\n<h3 id=\"解析\">解析<a title=\"#解析\" href=\"#解析\"></a></h3>\n<h4 id=\"hashmap()\">HashMap()<a title=\"#hashmap()\" href=\"#hashmap()\"></a></h4>\n<blockquote>\n<p>初始化部分主要决定当前容量(loadFactor ),以及存储的阀值(loadFactor)</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 最大容量，当两个构造函数中任何一个带参数的函数隐式指定较大的值时使用。必须是2的幂&lt;= 1&lt;&lt;30</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MAXIMUM_CAPACITY = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">30</span>;</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"comment\">// 默认扩容比例</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> DEFAULT_LOAD_FACTOR = <span class=\"number\">0.75f</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HashMap</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity)</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HashMap</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity, <span class=\"keyword\">float</span> loadFactor)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 针对煞笔的处理,不会真的有人给0吧</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (initialCapacity &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">&quot;Illegal initial capacity:&quot;</span> +initialCapacity);</span><br><span class=\"line\">    <span class=\"comment\">// 当前最大容量    </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY;</span><br><span class=\"line\">    <span class=\"comment\">// 判断扩容比例</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (loadFactor &lt;= <span class=\"number\">0</span> || Float.isNaN(loadFactor))</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">&quot;Illegal load factor: &quot;</span> +loadFactor);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.loadFactor = loadFactor;</span><br><span class=\"line\">    <span class=\"comment\">// 决定下一次调整容量的大小(临界值)</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 返回给定目标容量的2次幂大小</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">tableSizeFor</span><span class=\"params\">(<span class=\"keyword\">int</span> cap)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = cap - <span class=\"number\">1</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">2</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">4</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">8</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">16</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (n &lt; <span class=\"number\">0</span>) ? <span class=\"number\">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用指定的初始容量和默认的加载因子来初始化HashMap。这里应该注意的是，有时它不是您指定的初始容量。例如新HashMap (20,0.8);那么实际的初始容量是32，因为tablesize()方法严格要求初始容量增加到2的幂，只能是16、32、64、128</p>\n","prev":{"title":"源码学习-ViewModel","link":"2021/11/29/9S5c1rplpdSAbIxR"},"next":{"title":"源码学习-DataBinding","link":"2021/11/29/hu0861X6Ltf32fYt"},"plink":"http://onion66.gitee.io/blog/2021/11/29/4diQitvVwGPnicN5/","reward":true,"copyright":{"custom":"Copyright:自由转载-非商用-禁止演绎-保持署名（CC BY-NC-ND 4.0）"}}