{"title":"Java并发(5) - 线程协作","date":"2021-11-07T19:04:05.000Z","date_formatted":{"ll":"2021年11月7日","L":"2021/11/07","MM-DD":"11-07"},"link":"2021/11/07/WkWqwHwU8wgNL4cd","comments":true,"tags":["并发"],"categories":["Java"],"updated":"2021-11-07T11:04:05.479Z","content":"<h3 id=\"线程状态\">线程状态<a title=\"#线程状态\" href=\"#线程状态\"></a></h3>\n<p><img src=\"https://z3.ax1x.com/2021/11/05/InuMpd.png\" alt=\"InuMpd.png\" loading=\"lazy\" class=\"φbp\"></p>\n<span id=\"more\"></span>\n<h3 id=\"wait、notify、notifyall\">wait、notify、notifyAll<a title=\"#wait、notify、notifyall\" href=\"#wait、notify、notifyall\"></a></h3>\n<blockquote>\n<p>实现线程间的协作</p>\n</blockquote>\n<h4 id=\"wait\">wait<a title=\"#wait\" href=\"#wait\"></a></h4>\n<ul>\n<li><code>wait()</code>将当前运行的线程挂起(即让其进入阻塞状态)，直到<code>notify</code>或<code>notifyAll</code>方法来唤醒线程</li>\n<li><code>wait(long timeout)</code>跟上面类似,但会超时唤醒</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WaitTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 写法错误:这里会抛出的 IllegalMonitorStateException 异常</span></span><br><span class=\"line\">    <span class=\"comment\">// 因为在调用wait方式时没有获取到monitor对象的所有权，那如何获取monitor对象所有权？Java中只能通过Synchronized关键字来完成</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testWait</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Start-----&quot;</span>);</span><br><span class=\"line\">        wait(<span class=\"number\">1000</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;End-------&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 写法正确</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">testWait</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Start-----&quot;</span>);</span><br><span class=\"line\">        wait(<span class=\"number\">1000</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;End-------&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> WaitTest test = <span class=\"keyword\">new</span> WaitTest();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">            test.testWait();</span><br><span class=\"line\">        &#125;).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>wait()</code>的使用必须在<code>synchronized </code>的范围内，否则就会抛出IllegalMonitorStateException异常，<code>wait()</code>的作用就是阻塞当前线程等待notify/notifyAll方法的唤醒，或等待超时后自动唤醒</p>\n<h4 id=\"notify/notifyall\">notify/notifyAll<a title=\"#notify/notifyall\" href=\"#notify/notifyall\"></a></h4>\n<ul>\n<li><code>notify()</code>唤醒monitor上的一个线程</li>\n<li><code>notifyAll()</code>唤醒所有的线程</li>\n</ul>\n<h3 id=\"sleep、yield、join\">sleep、yield、join<a title=\"#sleep、yield、join\" href=\"#sleep、yield、join\"></a></h3>\n<ul>\n<li><code>sleep()</code>延时</li>\n<li><code>start()</code>启动线程，让线程变成就绪状态等待 CPU 调度后执行</li>\n<li><code>yield()</code>让掉当前线程资源占有，使正在运行中的线程重新变成就绪状态，并重新竞争 CPU 的调度权。它可能会获取到，也有可能被其他线程获取到</li>\n<li><code>join()</code>使主线程进入等待池并等待当前线程执行完毕后才会被唤醒</li>\n</ul>\n<p><code>yield()</code>可以很好的控制多线程，如执行某项复杂的任务时，如果担心占用资源过多，可以在完成某个重要的工作后使用 yield 方法让掉当前 CPU 的调度权，等下次获取到再继续执行，这样不但能完成自己的重要工作，也能给其他线程一些运行的机会，避免一个线程长时间占有 CPU 资源。</p>\n","prev":{"title":"Java并发(6) - 线程池","link":"2021/11/07/oizxmTtLdVsaXZrZ"},"next":{"title":"Java并发(4) - CAS","link":"2021/11/07/qX2v7eB61IheaBrH"},"plink":"https://onion99.github.io/2021/11/07/WkWqwHwU8wgNL4cd/","reward":true,"copyright":{"custom":"Copyright:自由转载-非商用-禁止演绎-保持署名（CC BY-NC-ND 4.0）"}}