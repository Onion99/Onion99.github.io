{"per_page":9,"total":5,"current":1,"data":[{"title":"Android黑科技 - 插件化","date":"2022-03-07T22:46:11.000Z","date_formatted":{"ll":"2022年3月7日","L":"2022/03/07","MM-DD":"03-07"},"thumbnail":"https://s1.ax1x.com/2022/03/07/b60yFg.md.png","excerpt":"<p>插件化技术最初源于免安装运行apk的想法，这个免安装的apk可以理解为插件。支持插件化的app可以在运行时加载和运行插件，这样便可以将app中一些不常用的功能模块做成插件，一方面减小了安装包的大小，另一方面可以实现app功能的动态扩展。</p>\n<p>想要实现插件化，主要是解决下面三个问题：</p>\n<ul>\n<li>插件中代码的加载和与主工程的互相调用</li>\n<li>插件中资源的加载和与主工程的互相访问</li>\n<li>四大组件生命周期的管理</li>\n</ul>","link":"2022/03/07/yriIudTcpjYyMHli","tags":["黑科技"],"categories":["Android"]},{"title":"Android黑科技 - 热修复","date":"2022-03-07T22:38:05.000Z","date_formatted":{"ll":"2022年3月7日","L":"2022/03/07","MM-DD":"03-07"},"thumbnail":"https://s1.ax1x.com/2022/03/07/b6wtK0.md.png","excerpt":"<blockquote>\n<p>热修复本质就是将错误的代码替换成正确的代码,但这里的替换不是改写原有的代码,而是提供一份新的正确的代码,让应用运行时绕过错误的代码,从而执行正确的代码</p>\n</blockquote>\n<p><img src=\"https://s1.ax1x.com/2022/03/06/bDtcIx.png\" alt=\"bDtcIx.png\" loading=\"lazy\" class=\"φbp\"></p>","link":"2022/03/07/phzbEh3JEzAC0XwD","tags":["黑科技"],"categories":["Android"]},{"title":"Android黑科技 - 热修复和插件化基础","date":"2022-03-07T22:31:41.000Z","date_formatted":{"ll":"2022年3月7日","L":"2022/03/07","MM-DD":"03-07"},"thumbnail":"https://s1.ax1x.com/2022/03/07/b6aO6P.md.png","excerpt":"<h3 id=\"dalvik和-art\">Dalvik和 ART<a title=\"#dalvik和-art\" href=\"#dalvik和-art\"></a></h3>\n<p>DVM也是实现了JVM规范的一个虚拟器，默认使用CMS垃圾回收器，但是与JVM运行 Class 字节码不同，DVM 执行 Dex(Dalvik Executable Format) ——专为 Dalvik 设计的一种压缩格式。Dex 文件是很多 .class 文件处理压缩后的产物，最终可以在 Android 运行时环境执行。</p>","link":"2022/03/07/ukYPIjylHjywfytF","tags":["黑科技"],"categories":["Android"]},{"title":"源码学习 - LiveData","date":"2022-03-02T17:47:39.000Z","date_formatted":{"ll":"2022年3月2日","L":"2022/03/02","MM-DD":"03-02"},"thumbnail":"https://s4.ax1x.com/2022/03/02/b8oz5R.md.png","excerpt":"<blockquote>\n<p><a href=\"https://developer.android.google.cn/reference/androidx/lifecycle/LiveData\" target=\"_blank\"><code>LiveData</code></a> 是一种可观察的数据存储器类。与常规的可观察类不同，LiveData 具有生命周期感知能力，意指它遵循其他应用组件（如 Activity、Fragment 或 Service）的生命周期。这种感知能力可确保 LiveData 仅更新处于活跃生命周期状态的应用组件观察者</p>\n</blockquote>","link":"2022/03/02/p2ie22dC9NcVwpEH","tags":["源码解析"],"categories":["Android"]},{"title":"源码学习 - Lifecycle","date":"2022-03-01T17:33:23.000Z","date_formatted":{"ll":"2022年3月1日","L":"2022/03/01","MM-DD":"03-01"},"thumbnail":"https://s4.ax1x.com/2022/03/02/b3lHxA.md.png","excerpt":"<blockquote>\n<p>Jetpack Lifecycle 提供了可用于构建生命周期感知型组件的类和接口,从而根据 Activity 或 Fragment 的当前生命周期状态自动调整其行为,记住我们要解析的是Jet Pack Lifecycle ,而不是 原有Activity/Fragment的生命周期流程</p>\n</blockquote>","link":"2022/03/01/uVaapTCHAYrYDaHP","tags":["源码解析"],"categories":["Android"]},{"title":"源码学习 - ViewModel","date":"2021-11-29T23:30:53.000Z","date_formatted":{"ll":"2021年11月29日","L":"2021/11/29","MM-DD":"11-29"},"thumbnail":"https://s4.ax1x.com/2022/03/02/b3GOSg.md.png","excerpt":"<blockquote>\n<p>ViewModel 类旨在以注重生命周期的方式存储和管理界面相关的数据。ViewModel 类让数据可在发生屏幕旋转等配置更改后继续留存,将视图和数据进行了分离解耦，为视图层提供数据</p>\n</blockquote>","link":"2021/11/29/9S5c1rplpdSAbIxR","tags":["源码解析"],"categories":["Android"]},{"title":"源码学习 - HashMap","date":"2021-11-29T23:28:47.000Z","date_formatted":{"ll":"2021年11月29日","L":"2021/11/29","MM-DD":"11-29"},"excerpt":"<blockquote>\n<p>Map是什么,可以是一个键到值的Object,可以是一个键值对的集合, 是函数抽象的数学模型</p>\n</blockquote>\n<p>似不似?</p>\n<p>HashMap就是Map实现的佼佼者,它使用哈希表作为底层数据结构</p>\n<blockquote>\n<p>注意哦,作为性能的最上层,HashMap是不考虑线程安全的,这是上层人的优越,多线程情况下,可以选用<code>ConcurrentHashMap</code> &gt; <code>Collections.synchronizedMap(HashMap&lt;&gt;())</code></p>\n</blockquote>","link":"2021/11/29/4diQitvVwGPnicN5","tags":["源码解析"],"categories":["Java"]},{"title":"源码学习 - DataBinding","date":"2021-11-29T23:27:07.000Z","date_formatted":{"ll":"2021年11月29日","L":"2021/11/29","MM-DD":"11-29"},"excerpt":"<h3 id=\"sameple\">Sameple<a title=\"#sameple\" href=\"#sameple\"></a></h3>\n<p>首先,我们来看看DataBinding使用:</p>\n<ol>\n<li>给layout文件套娃:</li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">layout</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">FrameLayout</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">androidx.viewpager.widget.ViewPager</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:id</span>=<span class=\"string\">&quot;@+id/home_pager&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">com.flyco.tablayout.SlidingTabLayout</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:id</span>=<span class=\"string\">&quot;@+id/home_tab&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">FrameLayout</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">layout</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>在Fragment或者View中获取binding对象</li>\n</ol>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">binding = DataBindingUtil.inflate(inflater,layoutRes,container,<span class=\"literal\">false</span>)</span><br></pre></td></tr></table></figure>\n<p>超,就是这么简单,来从<code>inflate</code>开始解析</p>","link":"2021/11/29/hu0861X6Ltf32fYt","tags":["源码解析"],"categories":["Android"]},{"title":"Java并发(7) - ThreadLocal","date":"2021-11-07T19:06:09.000Z","date_formatted":{"ll":"2021年11月7日","L":"2021/11/07","MM-DD":"11-07"},"excerpt":"<blockquote>\n<p>ThreadLocal 是一个关于创建线程局部变量的类。通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。而使用 ThreadLocal 建的变量只能被当前线程访问，其他线程则无法访问和修改</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">testThreadLocal</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Thread t = <span class=\"keyword\">new</span> Thread() &#123;</span><br><span class=\"line\">        ThreadLocal&lt;String&gt; mStringThreadLocal = <span class=\"keyword\">new</span> ThreadLocal&lt;&gt;();</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">super</span>.run();</span><br><span class=\"line\">            mStringThreadLocal.set(<span class=\"string\">&quot;name&quot;</span>);</span><br><span class=\"line\">            mStringThreadLocal.get();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\">    t.start();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","link":"2021/11/07/MpHTUCP7P1OgtydO","tags":["并发"],"categories":["Java"]}]}