{"per_page":9,"total":4,"current":1,"data":[{"title":"源码学习-Lifecycle","date":"2022-03-01T17:33:23.000Z","date_formatted":{"ll":"2022年3月1日","L":"2022/03/01","MM-DD":"03-01"},"excerpt":"<p><img src=\"https://s4.ax1x.com/2022/03/01/blNKTx.png\" alt=\"space\" loading=\"lazy\" class=\"φbp\"></p>\n<blockquote>\n<p>Jetpack Lifecycle 提供了可用于构建生命周期感知型组件的类和接口,从而根据 Activity 或 Fragment 的当前生命周期状态自动调整其行为,记住我们要解析的是Jet Pack Lifecycle ,而不是 原有Activity/Fragment的生命周期流程</p>\n</blockquote>","link":"2022/03/01/uVaapTCHAYrYDaHP","tags":["源码解析"],"categories":["Android"]},{"title":"源码学习-ViewModel","date":"2021-11-29T23:30:53.000Z","date_formatted":{"ll":"2021年11月29日","L":"2021/11/29","MM-DD":"11-29"},"excerpt":"<p>首先看看ViewModel是怎么样实例化</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">open</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;T : ViewModel?&gt;</span> <span class=\"title\">getFragmentScopeViewModel</span><span class=\"params\">(modelClass: <span class=\"type\">Class</span>&lt;<span class=\"type\">T</span>&gt;)</span></span>: T &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!::fragmentProvider.isInitialized) &#123;</span><br><span class=\"line\">        fragmentProvider = ViewModelProvider(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fragmentProvider.<span class=\"keyword\">get</span>(modelClass)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">open</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;T : ViewModel?&gt;</span> <span class=\"title\">getActivityScopeViewModel</span><span class=\"params\">(modelClass: <span class=\"type\">Class</span>&lt;<span class=\"type\">T</span>&gt;)</span></span>: T &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!::activityProvider.isInitialized) &#123;</span><br><span class=\"line\">        activityProvider = ViewModelProvider(requireActivity())</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> activityProvider.<span class=\"keyword\">get</span>(modelClass)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我超,原来是通过一个ViewModelProvider去get到的,他妈的这是干什么的呢,为什么要通过ViewModelProvider获取呢<br>\n<img src=\"http://img.doutula.com/production/uploads/image/2019/06/06/20190606755268_TSvBec.jpg\" alt=\"\" loading=\"lazy\"><br>\n我怎么知道,瞧瞧官方正儿八经的回答吧<br>\n<code>ViewModel</code>:旨在以注重生命周期的方式存储和管理界面相关的数据。ViewModel 类让数据可在发生屏幕旋转等配置更改后继续留存<br>\n<code>ViewModelProvider</code>: ViewModel的辅助程序类，该类负责为界面准备数据。在配置更改期间会自动保留 ViewModel 对象，以便它们存储的数据立即可供下一个 activity 或 fragment 实例使用</p>","link":"2021/11/29/9S5c1rplpdSAbIxR","tags":["源码解析"],"categories":["Android"]},{"title":"源码学习-HashMap","date":"2021-11-29T23:28:47.000Z","date_formatted":{"ll":"2021年11月29日","L":"2021/11/29","MM-DD":"11-29"},"excerpt":"<blockquote>\n<p>Map是什么,可以是一个键到值的Object,可以是一个键值对的集合, 是函数抽象的数学模型</p>\n</blockquote>\n<p>似不似?</p>\n<p>HashMap就是Map实现的佼佼者,它使用哈希表作为底层数据结构</p>\n<blockquote>\n<p>注意哦,作为性能的最上层,HashMap是不考虑线程安全的,这是上层人的优越,多线程情况下,可以选用<code>ConcurrentHashMap</code> &gt; <code>Collections.synchronizedMap(HashMap&lt;&gt;())</code></p>\n</blockquote>","link":"2021/11/29/4diQitvVwGPnicN5","tags":["源码解析"],"categories":["Java"]},{"title":"源码学习-DataBinding","date":"2021-11-29T23:27:07.000Z","date_formatted":{"ll":"2021年11月29日","L":"2021/11/29","MM-DD":"11-29"},"excerpt":"<h3 id=\"sameple\">Sameple<a title=\"#sameple\" href=\"#sameple\"></a></h3>\n<p>首先,我们来看看DataBinding使用:</p>\n<ol>\n<li>给layout文件套娃:</li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">layout</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">FrameLayout</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">androidx.viewpager.widget.ViewPager</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:id</span>=<span class=\"string\">&quot;@+id/home_pager&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">com.flyco.tablayout.SlidingTabLayout</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:id</span>=<span class=\"string\">&quot;@+id/home_tab&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">FrameLayout</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">layout</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>在Fragment或者View中获取binding对象</li>\n</ol>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">binding = DataBindingUtil.inflate(inflater,layoutRes,container,<span class=\"literal\">false</span>)</span><br></pre></td></tr></table></figure>\n<p>超,就是这么简单,来从<code>inflate</code>开始解析</p>","link":"2021/11/29/hu0861X6Ltf32fYt","tags":["源码解析"],"categories":["Android"]},{"title":"Java并发(7) - ThreadLocal","date":"2021-11-07T19:06:09.000Z","date_formatted":{"ll":"2021年11月7日","L":"2021/11/07","MM-DD":"11-07"},"excerpt":"<blockquote>\n<p>ThreadLocal 是一个关于创建线程局部变量的类。通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。而使用 ThreadLocal 建的变量只能被当前线程访问，其他线程则无法访问和修改</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">testThreadLocal</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Thread t = <span class=\"keyword\">new</span> Thread() &#123;</span><br><span class=\"line\">        ThreadLocal&lt;String&gt; mStringThreadLocal = <span class=\"keyword\">new</span> ThreadLocal&lt;&gt;();</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">super</span>.run();</span><br><span class=\"line\">            mStringThreadLocal.set(<span class=\"string\">&quot;name&quot;</span>);</span><br><span class=\"line\">            mStringThreadLocal.get();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\">    t.start();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","link":"2021/11/07/MpHTUCP7P1OgtydO","tags":["并发"],"categories":["Java"]},{"title":"Java并发(6) - 线程池","date":"2021-11-07T19:05:17.000Z","date_formatted":{"ll":"2021年11月7日","L":"2021/11/07","MM-DD":"11-07"},"excerpt":"<p>线程池对比new Thread()</p>\n<ul>\n<li>重用存在的线程，减少线程创建、消亡的开销，性能佳。</li>\n<li>可有效控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞</li>\n<li>提供定时执行、定期执行、单线程、并发数控制等功能</li>\n</ul>\n<p>ExecutorService 是最初的线程池接口，ThreadPoolExecutor 类是对线程池的具体实现:</p>\n<div class=\"φbq\"><div class=\"φbs\"><table><thead>\n<tr>\n<th style=\"text-align:center\">构造参数</th>\n<th style=\"text-align:right\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">corePoolSize</td>\n<td style=\"text-align:right\">核心线程的数量,默认情况下,即使核心线程没有任务在执行它也存在的,我们固定一定数量的核心线程且它一直存活,这样就避免了一般情况下CPU创建和销毁线程带来的开销。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">maximumPoolSize</td>\n<td style=\"text-align:right\">最大线程数，当任务数量超过最大线程数时其它任务可能就会被阻塞。最大线程数 = 核心线程 + 非核心线程。非核心线程只有当核心线程不够用且线程池有空余时才会被创建，执行完任务后非核心线程会被销毁。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">keepAliveTime</td>\n<td style=\"text-align:right\">非核心线程的超时时长,当执行时间超过这个时间时,非核心线程就会被回收。当 allowCoreThreadTimeOut设置为true时,此属性也作用在核心线程上</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">unit</td>\n<td style=\"text-align:right\">时间单位</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">workQueue</td>\n<td style=\"text-align:right\">任务队列,我们提交给线程池的 runnable 会被存储在这个对象上</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">threadFactory</td>\n<td style=\"text-align:right\">线程工厂,用于指定为线程池创建新线程的方式</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">handler</td>\n<td style=\"text-align:right\">拒绝策略</td>\n</tr>\n</tbody>\n</table></div></div>","link":"2021/11/07/oizxmTtLdVsaXZrZ","tags":["并发"],"categories":["Java"]},{"title":"Java并发(5) - 线程协作","date":"2021-11-07T19:04:05.000Z","date_formatted":{"ll":"2021年11月7日","L":"2021/11/07","MM-DD":"11-07"},"excerpt":"<h3 id=\"线程状态\">线程状态<a title=\"#线程状态\" href=\"#线程状态\"></a></h3>\n<p><img src=\"https://z3.ax1x.com/2021/11/05/InuMpd.png\" alt=\"InuMpd.png\" loading=\"lazy\" class=\"φbp\"></p>","link":"2021/11/07/WkWqwHwU8wgNL4cd","tags":["并发"],"categories":["Java"]},{"title":"Java并发(4) - CAS","date":"2021-11-07T18:59:57.000Z","date_formatted":{"ll":"2021年11月7日","L":"2021/11/07","MM-DD":"11-07"},"excerpt":"<p>锁机制问题:</p>\n<ul>\n<li>在多线程竞争下，加锁、释放锁会导致比较多的上下文切换和调度延时，引起性能问题</li>\n<li>一个线程持有锁会导致其它所有需要此锁的线程挂起</li>\n<li>如果一个优先级高的线程等待一个优先级低的线程释放锁会导致优先级倒置，引起性能风险</li>\n</ul>\n<p>volatile 是不错的机制，但是 volatile 不能保证原子性，因此对于同步最终还是要回到锁机制上来。独占锁是一种悲观锁，synchronized 就是一种独占锁，会导致其它所有需要锁的线程挂起，等待持有锁的线程释放锁。而另一个更加有效的锁就是乐观锁</p>\n<blockquote>\n<p>乐观锁即总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和 CAS 算法实现</p>\n</blockquote>","link":"2021/11/07/qX2v7eB61IheaBrH","tags":["并发"],"categories":["Android"]},{"title":"Java并发(3) - Lock","date":"2021-11-07T18:59:09.000Z","date_formatted":{"ll":"2021年11月7日","L":"2021/11/07","MM-DD":"11-07"},"excerpt":"<blockquote>\n<p>锁是用于通过多个线程控制对共享资源的访问的工具</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Lock lock = <span class=\"keyword\">new</span> ReentrantLock();</span><br><span class=\"line\">lock.lock();</span><br><span class=\"line\"><span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//临界区......</span></span><br><span class=\"line\">&#125;<span class=\"keyword\">finally</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//最好不要把获取锁的过程写在 try 语句块中，因为如果在获取锁时发生了异常，异常抛出的同时也会导致锁无法被释放</span></span><br><span class=\"line\">    lock.unlock();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","link":"2021/11/07/HcJi8WdXZ8E3DBWS","tags":["并发"],"categories":["Java"]}]}