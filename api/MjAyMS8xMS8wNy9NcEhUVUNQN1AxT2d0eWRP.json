{"title":"Java并发(7) - ThreadLocal","date":"2021-11-07T19:06:09.000Z","date_formatted":{"ll":"2021年11月7日","L":"2021/11/07","MM-DD":"11-07"},"link":"2021/11/07/MpHTUCP7P1OgtydO","comments":true,"tags":["并发"],"categories":["Java"],"updated":"2021-11-07T11:05:35.000Z","content":"<blockquote>\n<p>ThreadLocal 是一个关于创建线程局部变量的类。通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。而使用 ThreadLocal 建的变量只能被当前线程访问，其他线程则无法访问和修改</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">testThreadLocal</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Thread t = <span class=\"keyword\">new</span> Thread() &#123;</span><br><span class=\"line\">        ThreadLocal&lt;String&gt; mStringThreadLocal = <span class=\"keyword\">new</span> ThreadLocal&lt;&gt;();</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">super</span>.run();</span><br><span class=\"line\">            mStringThreadLocal.set(<span class=\"string\">&quot;name&quot;</span>);</span><br><span class=\"line\">            mStringThreadLocal.get();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\">    t.start();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<span id=\"more\"></span>\n<h3 id=\"threadlocal实例化\">ThreadLocal实例化<a title=\"#threadlocal实例化\" href=\"#threadlocal实例化\"></a></h3>\n<blockquote>\n<p>为 ThreadLocal 设置默认的 get 初始值，需要重写 initialValue 方法</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ThreadLocal&lt;String&gt; mThreadLocal = <span class=\"keyword\">new</span> ThreadLocal&lt;String&gt;() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> String <span class=\"title\">initialValue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> Thread.currentThread().getName();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>在 Android 中的应用，Looper 类就是利用了 ThreadLocal 的特性，保证每个线程只存在一个 Looper 对象:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ThreadLocal&lt;Looper&gt; sThreadLocal = <span class=\"keyword\">new</span> ThreadLocal&lt;Looper&gt;();</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">prepare</span><span class=\"params\">(<span class=\"keyword\">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sThreadLocal.get() != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">&quot;Only one Looper may be created per thread&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sThreadLocal.set(<span class=\"keyword\">new</span> Looper(quitAllowed));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"原理\">原理<a title=\"#原理\" href=\"#原理\"></a></h3>\n<h4 id=\"threadlocal.set()\">ThreadLocal.set()<a title=\"#threadlocal.set()\" href=\"#threadlocal.set()\"></a></h4>\n<p>首先获取当前线程，利用当前线程作为句柄获取一个 ThreadLocalMap 的对象，如果上述 ThreadLocalMap 对象不为空，则设置值，否则创建这个 ThreadLocalMap 对象并设置值</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">set</span><span class=\"params\">(T value)</span> </span>&#123;</span><br><span class=\"line\">    Thread t = Thread.currentThread();</span><br><span class=\"line\">    ThreadLocalMap map = getMap(t);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (map != <span class=\"keyword\">null</span>) map.set(<span class=\"keyword\">this</span>, value);</span><br><span class=\"line\">    <span class=\"keyword\">else</span> createMap(t, value);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>获取Thread 对象的threadLocals 变量</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ThreadLocalMap <span class=\"title\">getMap</span><span class=\"params\">(Thread t)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> t.threadLocals;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Thread</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\">    ThreadLocal.ThreadLocalMap threadLocals = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果一开始未设置,则新建 ThreadLocalMap 对象，并设置初始值</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">createMap</span><span class=\"params\">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class=\"line\">    t.threadLocals = <span class=\"keyword\">new</span> ThreadLocalMap(<span class=\"keyword\">this</span>, firstValue);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://z3.ax1x.com/2021/11/05/InDvFg.png\" alt=\"InDvFg.png\" loading=\"lazy\" class=\"φbp\"></p>\n<h4 id=\"threadlocal.get()\">ThreadLocal.get()<a title=\"#threadlocal.get()\" href=\"#threadlocal.get()\"></a></h4>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Thread t = Thread.currentThread();</span><br><span class=\"line\">    ThreadLocalMap map = getMap(t);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (map != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        ThreadLocalMap.Entry e = map.getEntry(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"meta\">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class=\"line\">            T result = (T)e.value;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> setInitialValue();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"对象存放\">对象存放<a title=\"#对象存放\" href=\"#对象存放\"></a></h3>\n<ul>\n<li>在 Java 中,栈内存归属于线程私有,每个线程都会有一个栈内存,其存储的变量只能在其所属线程中可见,即栈内存可以理解成线程的私有内存</li>\n<li>堆内存中的对象对所有线程可见,堆内存中的对象可以被所有线程访问</li>\n<li>ThreadLocal 实例实际上也是被其创建的类持有（更顶端应该是被线程持有）,位于堆上</li>\n</ul>\n<h3 id=\"内存泄露问题\">内存泄露问题<a title=\"#内存泄露问题\" href=\"#内存泄露问题\"></a></h3>\n<p>当使用 ThreadLocal 保存一个 value 时，会在 ThreadLocalMap 中的数组插入一个Entry对象，ThreadLocal 在没有外部强引用时，发生 GC 时会被回收，但如果创建 ThreadLocal 的线程一直持续运行，那么这个 Entry 对象中的 value 就有可能一直得不到回收，发生内存泄露</p>\n<p>解决:使用完 ThreadLocal 之后,记得调用 remove 方法</p>\n","prev":{"title":"源码学习 - DataBinding","link":"2021/11/29/hu0861X6Ltf32fYt"},"next":{"title":"Java并发(6) - 线程池","link":"2021/11/07/oizxmTtLdVsaXZrZ"},"plink":"https://onion99.github.io/2021/11/07/MpHTUCP7P1OgtydO/","reward":true,"copyright":{"custom":"Copyright:自由转载-非商用-禁止演绎-保持署名（CC BY-NC-ND 4.0）"}}