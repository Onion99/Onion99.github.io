{"title":"Android黑科技 - 热修复","date":"2022-03-07T22:38:05.000Z","date_formatted":{"ll":"2022年3月7日","L":"2022/03/07","MM-DD":"03-07"},"thumbnail":"https://s1.ax1x.com/2022/03/07/b6wtK0.md.png","link":"2022/03/07/phzbEh3JEzAC0XwD","comments":true,"tags":["黑科技"],"categories":["Android"],"updated":"2022-03-07T14:32:37.000Z","content":"<blockquote>\n<p>热修复本质就是将错误的代码替换成正确的代码,但这里的替换不是改写原有的代码,而是提供一份新的正确的代码,让应用运行时绕过错误的代码,从而执行正确的代码</p>\n</blockquote>\n<p><img src=\"https://s1.ax1x.com/2022/03/06/bDtcIx.png\" alt=\"bDtcIx.png\" loading=\"lazy\" class=\"φbp\"></p>\n<span id=\"more\"></span>\n<p>基础知识:</p>\n<ul>\n<li><a href=\"https://fullstackaction.com/pages/ccf9c0/#%E4%B8%80%E3%80%81dex-class-%E6%B5%85%E6%9E%90\" target=\"_blank\">热修复与插件化基础 - dex与class</a></li>\n<li><a href=\"https://fullstackaction.com/pages/1084c4/\" target=\"_blank\">热修复与插件化基础 - Java与Android虚拟机</a></li>\n<li><a href=\"https://fullstackaction.com/pages/a5eb80/\" target=\"_blank\">热修复与插件化基础 - Java与Android的类加载器</a></li>\n</ul>\n<h2 id=\"实现方案\">实现方案<a title=\"#实现方案\" href=\"#实现方案\"></a></h2>\n<h3 id=\"native层替换方案\">Native层替换方案<a title=\"#native层替换方案\" href=\"#native层替换方案\"></a></h3>\n<blockquote>\n<p>底层替换，修改java方法在native层的函数指针，指向修复后的方法以达到修复目的</p>\n</blockquote>\n<p>Android/Java代码的最小组织方式是方法（Method，实际上，每一个dex文件最多可以包含65536（0xffff）个方法），每个方法在ART虚拟机中都有一个ArtMethod结构体指针与之对应，ArtMethod结构体中包含了Java方法的所有信息，包括执行入口、访问权限、所属类和代码执行地址等等。换句话说，虚拟机就是通过ArtMethod结构体来操纵Java方法的。ArtMethod结构如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ArtMethod</span> <span class=\"title\">FINAL</span> &#123;</span></span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">  GcRoot&lt;mirror::Class&gt; declaring_class_;</span><br><span class=\"line\"></span><br><span class=\"line\">  std::atomic&lt;std::<span class=\"keyword\">uint32_t</span>&gt; access_flags_;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Offset to the CodeItem.</span></span><br><span class=\"line\">  <span class=\"keyword\">uint32_t</span> dex_code_item_offset_;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Index into method_ids of the dex file associated with this method.</span></span><br><span class=\"line\">  <span class=\"keyword\">uint32_t</span> dex_method_index_;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">uint16_t</span> method_index_;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">uint16_t</span> hotness_count_;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">PtrSizedFields</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// Depending on the method type, the data is</span></span><br><span class=\"line\">    <span class=\"comment\">//   - native method: pointer to the JNI function registered to this method</span></span><br><span class=\"line\">    <span class=\"comment\">//                    or a function to resolve the JNI function,</span></span><br><span class=\"line\">    <span class=\"comment\">//   - conflict method: ImtConflictTable,</span></span><br><span class=\"line\">    <span class=\"comment\">//   - abstract/interface method: the single-implementation if any,</span></span><br><span class=\"line\">    <span class=\"comment\">//   - proxy method: the original interface method or constructor,</span></span><br><span class=\"line\">    <span class=\"comment\">//   - other methods: the profiling data.</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span>* data_;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Method dispatch from quick compiled code invokes this pointer which may cause bridging into</span></span><br><span class=\"line\">    <span class=\"comment\">// the interpreter.</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span>* entry_point_from_quick_compiled_code_;</span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">  ptr_sized_fields_;</span><br><span class=\"line\">...</span><br><span class=\"line\">｝</span><br></pre></td></tr></table></figure>\n<p>其中有一个关键指针，它是方法的执行入口：<br>\n<code>entry_point_from_quick_compiled_code_</code><br>\n也就是说，这个指针指向方法体编译后对应的汇编指令。那么，如果我们能hook这个指针，由原来指向有bug的方法，变成指向正确的方法，就达到了修复的目的。这就是native层替换方案的核心原理。具体实现方案可以是改变指针指向（AndFix），也可以直接替换整个结构体（Sophix）。</p>\n<p>需要注意的是，底层替换方案虽然是即使生效的，但是因为不会加载新类，而是直接修改原类，所以修改的代码不能增加新的方法，否则会造成索引数与方法数不匹配，无法通过索引找到正确方法，字段同理</p>\n<h3 id=\"类加载方案\">类加载方案<a title=\"#类加载方案\" href=\"#类加载方案\"></a></h3>\n<blockquote>\n<p>加载一个类的时候，都会去循环dexElements数组取出里面的dex文件，然后从dex文件中找目标类，只要目标类找到，则直接退出循环，也就是后面的dex文件就没有被取到的机会。将热修复的类放在dexElements[]的最前面，这样加载类时 <strong>会优先加载到要修复的类</strong>以达到修复目的</p>\n</blockquote>\n<p><img src=\"https://s1.ax1x.com/2022/03/06/bDduwj.png\" alt=\"bDduwj.png\" loading=\"lazy\" class=\"φbp\"></p>\n<p>基于jvm的java应用是通过ClassLoader来加载应用中的class的，Android对JVM优化过，使用的是ART(以前是Dalvik)，class文件会被打包进dex文件中，底层虚拟机有所不同，那么它们的类加载器也会有所区别，在Android中，要加载dex文件中的class文件就需要用到 PathClassLoader 或 DexClassLoader 这两个Android专用的类加载器。</p>\n<p><img src=\"https://s1.ax1x.com/2022/03/07/bsEKiR.png\" alt=\"bsEKiR.png\" loading=\"lazy\" class=\"φbp\"></p>\n<h4 id=\"原理\">原理<a title=\"#原理\" href=\"#原理\"></a></h4>\n<p><img src=\"https://s1.ax1x.com/2022/03/07/bsdsXT.png\" alt=\"bsdsXT.png\" loading=\"lazy\" class=\"φbp\"></p>\n<h4 id=\"生成修复dex\">生成修复Dex<a title=\"#生成修复dex\" href=\"#生成修复dex\"></a></h4>\n<p>1.将出bug的类修改正确，然后执行打包流程  <a href=\"https://imgtu.com/i/bsNkSf\" target=\"_blank\"><img src=\"https://s1.ax1x.com/2022/03/07/bsNkSf.png\" alt=\"bsNkSf.png\" loading=\"lazy\"></a></p>\n<p>2.此时取出工程目录下的/build/intermediates/javac/debug/classes/包路径/文件夹下对应的class文件</p>\n<p>3.在复制这个class文件时，需要把它所在的完整包目录一起复制，然后在命令行下cd到该目录，执行<code>dx --dex --output=patch.dex 包名路径/需要修复的类文件</code>,此时会在当前目录下生成patch.dex文件  <a href=\"https://imgtu.com/i/bsNQf0\" target=\"_blank\"><img src=\"https://s1.ax1x.com/2022/03/07/bsNQf0.png\" alt=\"bsNQf0.png\" loading=\"lazy\"></a></p>\n<p>4.然后将patch.dex文件当成补丁包放入资源文件夹raw下即可。</p>\n<p>指令为：dx --dex --output=patch.dex com/xxx/xxx/fixbug.class -&gt; 生成patch.dex文件</p>\n<p>也可以写成：dx --dex --output=patch.jar com/xxx/xxx/fixbug.class -&gt; 生成patch.jar文件</p>\n<p>ClassLoader可以加载.dex文件，或者.zip、.jar、.apk中包含的.dex文件</p>\n<h4 id=\"实践\">实践<a title=\"#实践\" href=\"#实践\"></a></h4>\n<p>Application:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 之所以要在本类中做补丁包的安装是因为怕如果在后面的流程中做安装会造成有些带bug的类如果已经被系统加载的话，后续补丁包安装之后</span></span><br><span class=\"line\"><span class=\"comment\"> * 补丁包中的类得不到执行，因为类加载有缓存机制，系统会将加载过的类做一份内存缓存。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApplication</span> <span class=\"keyword\">extends</span> <span class=\"title\">Application</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate();</span><br><span class=\"line\">        <span class=\"comment\">// 此处为加载补丁包，其实真实应用场景是从服务端下载补丁文件，因为本工程为示例所以直接将其放在raw资源文件目录下去读取，省去了下载过程</span></span><br><span class=\"line\">        File patchFile = <span class=\"keyword\">new</span> File(getCacheDir().getAbsolutePath() + File.separator + <span class=\"string\">&quot;patch.dex&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 为了高版本Android访问外部存储需要分区等问题，因为此处仅做示例讲解所以就直接将包拷贝到私有目录中</span></span><br><span class=\"line\">            <span class=\"comment\">// 拷贝到私有目录中还有一个好处是避免在补丁包安装过程中包文件被删除造成安装失败</span></span><br><span class=\"line\">            copyFile(patchFile);</span><br><span class=\"line\">            <span class=\"comment\">// 安装补丁包</span></span><br><span class=\"line\">            HotFix.installPatch(<span class=\"keyword\">this</span>, patchFile);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">copyFile</span><span class=\"params\">(File dest)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        InputStream input = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        OutputStream output = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 由于本项目是测试功能，所以这里直接将补丁包放在工程内，真实开发环境中应该是放在服务器然后下载下来</span></span><br><span class=\"line\">            input = getResources().openRawResource(R.raw.patch);</span><br><span class=\"line\">            output = <span class=\"keyword\">new</span> FileOutputStream(dest);</span><br><span class=\"line\">            <span class=\"keyword\">byte</span>[] buf = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">1024</span>];</span><br><span class=\"line\">            <span class=\"keyword\">int</span> bytesRead;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> ((bytesRead = input.read(buf)) != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                output.write(buf, <span class=\"number\">0</span>, bytesRead);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            input.close();</span><br><span class=\"line\">            output.close();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>HotFix.installPatch:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HotFix</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">installPatch</span><span class=\"params\">(Application application, File patch)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (patch == <span class=\"keyword\">null</span> || !patch.exists()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">             * 1.获取当前的类加载器z</span></span><br><span class=\"line\"><span class=\"comment\">             */</span></span><br><span class=\"line\">            ClassLoader classLoader = application.getClassLoader();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">             * 2.获取到dexElements属性以便后续向前追加patch.dex</span></span><br><span class=\"line\"><span class=\"comment\">             */</span></span><br><span class=\"line\">            Field pathListField = ReflectUtils.findField(classLoader, <span class=\"string\">&quot;pathList&quot;</span>);</span><br><span class=\"line\">            Object pathList = pathListField.get(classLoader);</span><br><span class=\"line\">            Field dexElementsField = ReflectUtils.findField(pathList, <span class=\"string\">&quot;dexElements&quot;</span>);</span><br><span class=\"line\">            Object[] dexElements = (Object[]) dexElementsField.get(pathList);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">             * 3.通过反射调用DexPathList类中的makePathElements()方法将patch.dex最终转换为Element[]数组，</span></span><br><span class=\"line\"><span class=\"comment\">             * DexPathList一系列方法都是用来将补丁包转换为Element[]数组的，如makePathElements，makeDexElements..</span></span><br><span class=\"line\"><span class=\"comment\">             * 具体的API根据真实API的版本不同方法参数等可能会有出入，所以这里在使用过程中实际上应该通过判断去兼容各个版本，</span></span><br><span class=\"line\"><span class=\"comment\">             * 此处因为是示例所以没做兼容</span></span><br><span class=\"line\"><span class=\"comment\">             */</span></span><br><span class=\"line\">            List&lt;File&gt; files = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">            files.add(patch);</span><br><span class=\"line\">            Method method = ReflectUtils.findMethod(pathList, <span class=\"string\">&quot;makePathElements&quot;</span>, List.class, File.class, List.class);</span><br><span class=\"line\">            ArrayList&lt;IOException&gt; suppressedExceptions = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">            Object[] patchElements = (Object[]) method.invoke(pathList, files, application.getCacheDir(), suppressedExceptions);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">             * 4.合并patchElements+dexElements,将补丁包的.dex文件插入数组最前面，后续在加载类的时候会优先从第一个开始遍历查找类</span></span><br><span class=\"line\"><span class=\"comment\">             */</span></span><br><span class=\"line\">            Object[] newElements = (Object[]) Array.newInstance(dexElements.getClass().getComponentType(), dexElements.length + patchElements.length);</span><br><span class=\"line\">            System.arraycopy(patchElements, <span class=\"number\">0</span>, newElements, <span class=\"number\">0</span>, patchElements.length);</span><br><span class=\"line\">            System.arraycopy(dexElements, <span class=\"number\">0</span>, newElements, patchElements.length, dexElements.length);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">             * 5.将新数组置换掉BaseDexClassLoader -&gt; pathList -&gt; dexElements属性，至此工作完成</span></span><br><span class=\"line\"><span class=\"comment\">             */</span></span><br><span class=\"line\">            dexElementsField.set(pathList, newElements);</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReflectUtils</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/* 找到反射属性 **/</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Field <span class=\"title\">findField</span><span class=\"params\">(Object instance, String name)</span> </span>&#123;</span><br><span class=\"line\">        Class&lt;?&gt; clz = instance.getClass();</span><br><span class=\"line\">        Field field = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (clz != Object.class) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                field = clz.getDeclaredField(name);</span><br><span class=\"line\">                field.setAccessible(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> field;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (NoSuchFieldException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//向父类寻找属性</span></span><br><span class=\"line\">            clz = clz.getSuperclass();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> field;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/* 找到反射函数 **/</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Method <span class=\"title\">findMethod</span><span class=\"params\">(Object instance, String name, Class&lt;?&gt;... parameterTypes)</span> </span>&#123;</span><br><span class=\"line\">        Class&lt;?&gt; clz = instance.getClass();</span><br><span class=\"line\">        Method method = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (clz != Object.class) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                method = clz.getDeclaredMethod(name, parameterTypes);</span><br><span class=\"line\">                method.setAccessible(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> method;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (NoSuchMethodException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//向父类寻找属性</span></span><br><span class=\"line\">            clz = clz.getSuperclass();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> method;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/* 找到反射所有函数数组 **/</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Method[] findAllMethods(Object instance) &#123;</span><br><span class=\"line\">        Class&lt;?&gt; clz = instance.getClass();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> clz.getDeclaredMethods();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>实际上，类替换方案的核心思想就是：将修改后的patch（包含bug类文件）打包成dex文件，然后hook ClassLoader加载流程，将这个dex文件插入到Element数组的第一个元素。因为加载类是依次进行的，所以虚拟机从第一个Element找到类后，就不会再加载bug类了。</p>\n<p>类加载方案也有缺点，因为类加载后无法卸载，所以类加载方案必须重启App，让bug类重新加载后才能生效</p>\n<h3 id=\"instant-run方案\">Instant Run方案<a title=\"#instant-run方案\" href=\"#instant-run方案\"></a></h3>\n<blockquote>\n<p>Instant Run 方案的核心思想是——插桩，在编译时通过插桩在每一个方法中插入代码，修改代码逻辑，在需要时绕过错误方法，调用patch类的正确方法</p>\n</blockquote>\n<p>首先，在编译时Instant Run为每个类插入IncrementalChange变量：<br>\n<code>IncrementalChange  $change;</code></p>\n<p>为每一个方法添加类似如下代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">        IncrementalChange var2 = $change;</span><br><span class=\"line\">        <span class=\"comment\">//$change不为null，表示该类有修改，需要重定向</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(var2 != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//通过access$dispatch方法跳转到patch类的正确方法</span></span><br><span class=\"line\">            var2.access$dispatch(<span class=\"string\">&quot;onCreate.(Landroid/os/Bundle;)V&quot;</span>, <span class=\"keyword\">new</span> Object[]&#123;<span class=\"keyword\">this</span>, savedInstanceState&#125;);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.setContentView(<span class=\"number\">2130968601</span>);</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.tv = (TextView)<span class=\"keyword\">this</span>.findViewById(<span class=\"number\">2131492944</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>如上代码，当一个类被修改后，Instant Run会为这个类新建一个类，命名为xxx&amp;override，且实现IncrementalChange接口，并且赋值给原类的$change变量。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainActivity</span>$<span class=\"title\">override</span> <span class=\"keyword\">implements</span> <span class=\"title\">IncrementalChange</span> </span>&#123;</span><br><span class=\"line\">｝</span><br></pre></td></tr></table></figure>\n<p>此时，在运行时原类中每个方法的var2 != null，通过accessdispatch（参数是方法名和原参数）定位到patch类MainActivityoverride中修改后的方法。</p>\n<p>Instant Run是google在AS2.0时用来实现“热部署”的，同时也为“热修复”提供了一个绝佳的思路。美团的Robust就是基于此。</p>\n<h3 id=\"so库修复\">SO库修复<a title=\"#so库修复\" href=\"#so库修复\"></a></h3>\n<h4 id=\"接口调用替换\">接口调用替换<a title=\"#接口调用替换\" href=\"#接口调用替换\"></a></h4>\n<p>sdk提供接口替换System默认加载so库的接口</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SOPatchManger.loadLibrary(String libName)</span><br><span class=\"line\"><span class=\"comment\">//代替</span></span><br><span class=\"line\">System.loadLibrary(String libName)</span><br></pre></td></tr></table></figure>\n<p>SOPatchManger.loadLibrary接口加载so库的时候优先尝试去加载sdk指定目录下补丁的so。若不存在，则再去加载安装apk目录下的so库</p>\n<p>优点：不需要对不同sdk版本进行兼容，所以sdk版本都是System.loadLibrary这个接口<br>\n缺点：需要侵入业务代码，替换掉System默认加载so库的接口</p>\n<h4 id=\"反射注入\">反射注入<a title=\"#反射注入\" href=\"#反射注入\"></a></h4>\n<p>采取类似类修复反射注入方式，只要把补丁so库的路径插入到nativeLibraryDirectories数组的最前面，就能够达到加载so库的时候是补丁so库而不是原来so库的目录，从而达到修复。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"built_in\">String</span> <span class=\"function\"><span class=\"title\">findLibrary</span>(<span class=\"params\"><span class=\"built_in\">String</span> libraryName</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">String</span> fileName = System.mapLibraryName(libraryName);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (NativeLibraryElement element : nativeLibraryPathElements) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">String</span> path = element.findNativeLibrary(fileName);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (path != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> path;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>优点：不需侵入用户接口调用<br>\n缺点：需要做版本兼容控制，兼容性较差</p>\n<h2 id=\"热修复技术方案选型\">热修复技术方案选型<a title=\"#热修复技术方案选型\" href=\"#热修复技术方案选型\"></a></h2>\n<p><img src=\"https://s1.ax1x.com/2022/03/06/bDwH8x.png\" alt=\"bDwH8x.png\" loading=\"lazy\" class=\"φbp\"></p>\n<h2 id=\"热修复和插件化区别\">热修复和插件化区别<a title=\"#热修复和插件化区别\" href=\"#热修复和插件化区别\"></a></h2>\n<blockquote>\n<p>插件化和热修复的原理，都是动态加载 dex／apk 中的类／资源，让宿主正常的加载和运行插件（补丁）中的内容</p>\n</blockquote>\n<ul>\n<li>\n<p>插件化目标是想把需要实现的模块或功能当做一个独立的提取出来，减少宿主的规模。重在解决组件的生命周期，以及资源的问题</p>\n</li>\n<li>\n<p>热修复目标在修复已有的问题。重在解决替换已有的有问题的类／方法／资源等</p>\n</li>\n</ul>\n<h2 id=\"deemo\">Deemo<a title=\"#deemo\" href=\"#deemo\"></a></h2>\n<p><a href=\"https://github.com/jiangzhengnan/Syringe\" target=\"_blank\">jiangzhengnan/Syringe: 📌 插件化注入工程(热修复+插件化)</a></p>\n<h2 id=\"refer\">Refer<a title=\"#refer\" href=\"#refer\"></a></h2>\n<p><a href=\"https://www.jianshu.com/p/cb1f0702d59f\" target=\"_blank\">热修复——深入浅出原理与实现</a><br>\n<a href=\"https://www.cnblogs.com/not2/p/11392733.html\" target=\"_blank\">热修复 - 西贝雪</a><br>\n<a href=\"https://zhuanlan.zhihu.com/p/109169752\" target=\"_blank\">Android热修复技术,你会怎么选？</a><br>\n<a href=\"https://github.com/BigSweet/hotFixALL\" target=\"_blank\">BigSweet/hotFixALL: 整理andfix,thinker,robust热修复使用方法和原理</a><br>\n<a href=\"https://github.com/yoyiyi/SoleilNotes/blob/master/Android/%E7%83%AD%E4%BF%AE%E5%A4%8D.md\" target=\"_blank\">SoleilNotes/热修复.md at master · yoyiyi/SoleilNotes</a></p>\n","prev":{"title":"Android黑科技 - 插件化","link":"2022/03/07/yriIudTcpjYyMHli"},"next":{"title":"Android黑科技 - 热修复和插件化基础","link":"2022/03/07/ukYPIjylHjywfytF"},"plink":"http://onion66.gitee.io/blog/2022/03/07/phzbEh3JEzAC0XwD/","toc":[{"id":"实现方案","title":"实现方案","index":"1"},{"id":"热修复技术方案选型","title":"热修复技术方案选型","index":"2"},{"id":"热修复和插件化区别","title":"热修复和插件化区别","index":"3"},{"id":"deemo","title":"Deemo","index":"4"},{"id":"refer","title":"Refer","index":"5"}],"reward":true,"copyright":{"custom":"Copyright:自由转载-非商用-禁止演绎-保持署名（CC BY-NC-ND 4.0）"}}