{"title":"自定义View(11) - 滚动速度和滚动计算","date":"2021-11-03T22:09:36.000Z","date_formatted":{"ll":"2021年11月3日","L":"2021/11/03","MM-DD":"11-03"},"link":"2021/11/03/cNDSpE5p4avS2tOi","comments":true,"tags":["图形绘制"],"categories":["Android"],"updated":"2021-11-03T14:09:07.000Z","content":"<h3 id=\"velocitytracker\">VelocityTracker<a title=\"#velocitytracker\" href=\"#velocitytracker\"></a></h3>\n<blockquote>\n<p>跟踪手指在滑动过程中的速度，包括水平和竖直方向的速度</p>\n</blockquote>\n<span id=\"more\"></span>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">VelocityTrackerTestView</span>(<span class=\"title\">context</span>: <span class=\"title\">Context</span>?, <span class=\"title\">attrs</span>: <span class=\"title\">AttributeSet</span>?) : <span class=\"title\">View</span>(<span class=\"title\">context</span>, <span class=\"title\">attrs</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//1、创建实例</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> mVelocityTracker = VelocityTracker.obtain()</span><br><span class=\"line\">    <span class=\"meta\">@SuppressLint(&quot;ClickableViewAccessibility&quot;)</span></span><br><span class=\"line\">    <span class=\"function\">override fun <span class=\"title\">onTouchEvent</span><span class=\"params\">(event: MotionEvent)</span>: Boolean </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//2、重置</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (event.actionMasked == MotionEvent.ACTION_DOWN) &#123;</span><br><span class=\"line\">            mVelocityTracker.clear()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//3、开始追踪</span></span><br><span class=\"line\">        mVelocityTracker.addMovement(event)</span><br><span class=\"line\"> </span><br><span class=\"line\">        when (event.actionMasked) &#123;</span><br><span class=\"line\">            MotionEvent.ACTION_DOWN -&gt; &#123;</span><br><span class=\"line\">                <span class=\"comment\">//...</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            MotionEvent.ACTION_MOVE -&gt; &#123;</span><br><span class=\"line\">                <span class=\"comment\">//o...</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            MotionEvent.ACTION_UP -&gt; &#123;</span><br><span class=\"line\">                <span class=\"comment\">//速度 = （ 终点位置(px) - 起点位置(px) ）/ 时间段(ms)</span></span><br><span class=\"line\">                <span class=\"comment\">//4、设置时间段</span></span><br><span class=\"line\">                mVelocityTracker.computeCurrentVelocity(<span class=\"number\">1000</span>)</span><br><span class=\"line\">                <span class=\"comment\">//5、获取x方向、y方向的速度</span></span><br><span class=\"line\">                <span class=\"comment\">//其中getXVelocity、getYVelocity方法的参数是pointerId，用于多指触控。不考虑多指时，可以不用传参数</span></span><br><span class=\"line\">                <span class=\"keyword\">var</span> xVelocity = mVelocityTracker.getXVelocity(<span class=\"number\">0</span>)</span><br><span class=\"line\">                <span class=\"keyword\">var</span> yVelocity = mVelocityTracker.getYVelocity(<span class=\"number\">0</span>)</span><br><span class=\"line\">                <span class=\"comment\">//...</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"function\">override fun <span class=\"title\">onDetachedFromWindow</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//6、当不需要使用时，重置并回收内存</span></span><br><span class=\"line\">        mVelocityTracker.clear()</span><br><span class=\"line\">        mVelocityTracker.recycle()</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onDetachedFromWindow()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>VelocityTracker 一般用来判断当前是否达到一定的滑动速度来触发 Fling 的效果，这个滑动速度我们可以自己设置，也可以通过系统提供的来获取</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">var</span> mViewConfiguration : ViewConfiguration = ViewConfiguration.get(context)</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">var</span> mMaxFlingVelocity = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"comment\">//触发fling的速度</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">var</span> mMinFlingVelocity = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">init &#123;</span><br><span class=\"line\">    mMaxFlingVelocity = mViewConfiguration.scaledMaximumFlingVelocity</span><br><span class=\"line\">    mMinFlingVelocity = mViewConfiguration.scaledMinimumFlingVelocity</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"scroller\">Scroller<a title=\"#scroller\" href=\"#scroller\"></a></h3>\n<p>在 View 类里面，有两个和滚动相关的类 scrollTo() 和 scrollBy。这两个方法可以实现 View 内容的移动，比如说一个 TextView，如果使用 scrollTo()，那么移动的是里面的文字而不是位置，scrollBy() 也是一样的。那么为什么是移动，不是滚动呢？这是因为这两个方法都是瞬间完成，而不是带有滚动过程的滚动，所以说如果要实现效果比较好的滚动还是需要 Scroller</p>\n<p>常用API:</p>\n<div class=\"φbq\"><div class=\"φbs\"><table><thead>\n<tr>\n<th style=\"text-align:center\">API</th>\n<th style=\"text-align:center\">简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">computeScrollOffset()</td>\n<td style=\"text-align:center\">判断当前的滑动动作是否完成的</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">getCurrX()、getCurrY()</td>\n<td style=\"text-align:center\">获取当前滑动的坐标值</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">getFinalX()、getFinalY()</td>\n<td style=\"text-align:center\">获取最终滑动停止时的坐标</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">isFinished()</td>\n<td style=\"text-align:center\">用来判断当前滚动是否结束</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">startScroll(int startX, int startY, int dx, int dy)</td>\n<td style=\"text-align:center\">用来开始滚动，这个是很重要的一个触发computeScroll()的方法，调用这个方法之后，我们就可以在computeScroll里面获取滚动的信息，然后完成我们的需要。这个还有一个带有滚动持续时间的重载函数，可以根据需求自由使用。特别要注意这四个参数，startX和startY是开始的坐标位置，正数左上，负数右下，dx、dy同理，当在computeScroll()获取getCurrX()的时候，变化范围就与这里地设置有关。</td>\n</tr>\n</tbody>\n</table></div></div><h3 id=\"overscroller\">OverScroller<a title=\"#overscroller\" href=\"#overscroller\"></a></h3>\n<blockquote>\n<p>对超出滑动边界的情况的处理</p>\n</blockquote>\n","prev":{"title":"Java并发(1) - volatile","link":"2021/11/07/VqykJCDZZcenZo3O"},"next":{"title":"自定义View(10) - GestureDetector","link":"2021/11/03/dY7a31QepeVitGkX"},"plink":"http://onion66.gitee.io/blog/2021/11/03/cNDSpE5p4avS2tOi/","reward":true,"copyright":{"custom":"Copyright:自由转载-非商用-禁止演绎-保持署名（CC BY-NC-ND 4.0）"}}