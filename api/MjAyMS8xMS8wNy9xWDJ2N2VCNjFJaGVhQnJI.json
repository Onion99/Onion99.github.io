{"title":"Java并发(4) - CAS","date":"2021-11-07T18:59:57.000Z","date_formatted":{"ll":"2021年11月7日","L":"2021/11/07","MM-DD":"11-07"},"link":"2021/11/07/qX2v7eB61IheaBrH","comments":true,"tags":["并发"],"categories":["Android"],"updated":"2021-11-07T10:59:30.000Z","content":"<p>锁机制问题:</p>\n<ul>\n<li>在多线程竞争下，加锁、释放锁会导致比较多的上下文切换和调度延时，引起性能问题</li>\n<li>一个线程持有锁会导致其它所有需要此锁的线程挂起</li>\n<li>如果一个优先级高的线程等待一个优先级低的线程释放锁会导致优先级倒置，引起性能风险</li>\n</ul>\n<p>volatile 是不错的机制，但是 volatile 不能保证原子性，因此对于同步最终还是要回到锁机制上来。独占锁是一种悲观锁，synchronized 就是一种独占锁，会导致其它所有需要锁的线程挂起，等待持有锁的线程释放锁。而另一个更加有效的锁就是乐观锁</p>\n<blockquote>\n<p>乐观锁即总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和 CAS 算法实现</p>\n</blockquote>\n<span id=\"more\"></span>\n<h3 id=\"原子操作\">原子操作<a title=\"#原子操作\" href=\"#原子操作\"></a></h3>\n<blockquote>\n<p>所谓“原子”操作，是指一组不可分割的操作：操作者对目标对象进行操作时，要么完成所有操作后其他操作者才能操作；要么这个操作者不能进行任何操作</p>\n</blockquote>\n<p><img src=\"https://z3.ax1x.com/2021/11/04/Ie5YA1.png\" alt=\"Ie5YA1.png\" loading=\"lazy\" class=\"φbp\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestAtomic</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 实例化了一个AtomicInteger类的对象atomic并定义初始值为1</span></span><br><span class=\"line\">        AtomicInteger atomic = <span class=\"keyword\">new</span> AtomicInteger(<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 进行atomic的原子化操作：增加1并且获取这个增加后的新值</span></span><br><span class=\"line\">        atomic.incrementAndGet();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"cas-原理\">CAS 原理<a title=\"#cas-原理\" href=\"#cas-原理\"></a></h3>\n<blockquote>\n<p>CAS 的思想很简单，三个参数：当前内存值 V、旧的预期值 A、即将更新的值 B，当且仅当预期值 A 和内存值 V 相同时，将内存值修改为 B 并返回 true，否则什么都不做，并返回 false。我们拿 AtomicInteger 类来分析，先来看看 AtomicInteger 静态代码块片段</p>\n</blockquote>\n<h3 id=\"cas缺点\">CAS缺点<a title=\"#cas缺点\" href=\"#cas缺点\"></a></h3>\n<ul>\n<li>循环时间长开销很大</li>\n<li>只能保证一个共享变量的原子操作</li>\n<li>ABA问题</li>\n</ul>\n","prev":{"title":"Java并发(5) - 线程协作","link":"2021/11/07/WkWqwHwU8wgNL4cd"},"next":{"title":"Java并发(3) - Lock","link":"2021/11/07/HcJi8WdXZ8E3DBWS"},"plink":"https://onion99.github.io/2021/11/07/qX2v7eB61IheaBrH/","reward":true,"copyright":{"custom":"Copyright:自由转载-非商用-禁止演绎-保持署名（CC BY-NC-ND 4.0）"}}