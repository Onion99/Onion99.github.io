{"title":"Java并发(4) - CAS","date":"2021-11-07T18:59:57.000Z","date_formatted":{"ll":"2021年11月7日","L":"2021/11/07","MM-DD":"11-07"},"link":"2021/11/07/qX2v7eB61IheaBrH","comments":true,"tags":["并发"],"categories":["Android"],"updated":"2021-11-07T10:59:30.000Z","content":"<p>锁机制问题:</p>\n<ul>\n<li>在多线程竞争下，加锁、释放锁会导致比较多的上下文切换和调度延时，引起性能问题</li>\n<li>一个线程持有锁会导致其它所有需要此锁的线程挂起</li>\n<li>如果一个优先级高的线程等待一个优先级低的线程释放锁会导致优先级倒置，引起性能风险</li>\n</ul>\n<p>volatile 是不错的机制，但是 volatile 不能保证原子性，因此对于同步最终还是要回到锁机制上来。独占锁是一种悲观锁，synchronized 就是一种独占锁，会导致其它所有需要锁的线程挂起，等待持有锁的线程释放锁。而另一个更加有效的锁就是乐观锁</p>\n<blockquote>\n<p>乐观锁即总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和 CAS 算法实现</p>\n</blockquote>\n<span id=\"more\"></span>\n<h3 id=\"原子操作\">原子操作<a title=\"#原子操作\" href=\"#原子操作\"></a></h3>\n<blockquote>\n<p>所谓“原子”操作，是指一组不可分割的操作：操作者对目标对象进行操作时，要么完成所有操作后其他操作者才能操作；要么这个操作者不能进行任何操作</p>\n</blockquote>\n<p><img src=\"https://z3.ax1x.com/2021/11/04/Ie5YA1.png\" alt=\"Ie5YA1.png\" loading=\"lazy\" class=\"φbp\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestAtomic</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 实例化了一个AtomicInteger类的对象atomic并定义初始值为1</span></span><br><span class=\"line\">        AtomicInteger atomic = <span class=\"keyword\">new</span> AtomicInteger(<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 进行atomic的原子化操作：增加1并且获取这个增加后的新值</span></span><br><span class=\"line\">        atomic.incrementAndGet();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"cas-原理\">CAS 原理<a title=\"#cas-原理\" href=\"#cas-原理\"></a></h3>\n<blockquote>\n<p>CAS 的思想很简单，三个参数：当前内存值 V、旧的预期值 A、即将更新的值 B，当且仅当预期值 A 和内存值 V 相同时，将内存值修改为 B 并返回 true，否则什么都不做，并返回 false。我们拿 AtomicInteger 类来分析，先来看看 AtomicInteger 静态代码块片段</p>\n</blockquote>\n<h3 id=\"cas缺点\">CAS缺点<a title=\"#cas缺点\" href=\"#cas缺点\"></a></h3>\n<ul>\n<li>循环时间长开销很大</li>\n<li>只能保证一个共享变量的原子操作</li>\n<li>ABA问题</li>\n</ul>\n<h3 id=\"例子\">例子<a title=\"#例子\" href=\"#例子\"></a></h3>\n<p>1.在内存地址V当中，存储着值为10的变量。</p>\n<p><img src=\"https://s1.ax1x.com/2022/03/17/q9xFtf.png\" alt=\"q9xFtf.png\" loading=\"lazy\" class=\"φbp\"></p>\n<p>2.此时线程1想要把变量的值增加1。对线程1来说，旧的预期值A=10，要修改的新值B=11。</p>\n<p><img src=\"https://s1.ax1x.com/2022/03/17/q9x90I.png\" alt=\"q9x90I.png\" loading=\"lazy\" class=\"φbp\"></p>\n<p>3.在线程1要提交更新之前，另一个线程2抢先一步，把内存地址V中的变量值率先更新成了11。</p>\n<p><img src=\"https://s1.ax1x.com/2022/03/17/q9vv1e.png\" alt=\"q9vv1e.png\" loading=\"lazy\" class=\"φbp\"></p>\n<p>4.线程1开始提交更新，首先进行A和地址V的实际值比较（Compare），发现A不等于V的实际值，提交失败。</p>\n<p><img src=\"https://s1.ax1x.com/2022/03/17/q9v56J.png\" alt=\"q9v56J.png\" loading=\"lazy\" class=\"φbp\"></p>\n<p>5.线程1重新获取内存地址V的当前值，并重新计算想要修改的新值。此时对线程1来说，A=11，B=12。这个重新尝试的过程被称为自旋。</p>\n<p><img src=\"https://s1.ax1x.com/2022/03/17/q9v8OA.png\" alt=\"q9v8OA.png\" loading=\"lazy\" class=\"φbp\"></p>\n<p>6.这一次比较幸运，没有其他线程改变地址V的值。线程1进行Compare，发现A和地址V的实际值是相等的。</p>\n<p><img src=\"https://s1.ax1x.com/2022/03/17/q9vmo6.png\" alt=\"q9vmo6.png\" loading=\"lazy\" class=\"φbp\"></p>\n<p>7.线程1进行SWAP，把地址V的值替换为B，也就是12。</p>\n<p><img src=\"https://s1.ax1x.com/2022/03/17/q9j9vd.png\" alt=\"q9j9vd.png\" loading=\"lazy\" class=\"φbp\"></p>\n<p>从思想上来说，Synchronized属于悲观锁，悲观地认为程序中的并发情况严重，所以严防死守。CAS属于乐观锁，乐观地认为程序中的并发情况不那么严重，所以让线程不断去尝试更新，最终可以理解成一个无阻塞多线程争抢资源的模型</p>\n<h3 id=\"参考\">参考<a title=\"#参考\" href=\"#参考\"></a></h3>\n<p><a href=\"https://www.jianshu.com/p/ae25eb3cfb5d\" target=\"_blank\">Java：CAS(乐观锁) </a></p>\n","prev":{"title":"Java并发(5) - 线程协作","link":"2021/11/07/WkWqwHwU8wgNL4cd"},"next":{"title":"Java并发(3) - Lock","link":"2021/11/07/HcJi8WdXZ8E3DBWS"},"plink":"https://onion99.github.io/2021/11/07/qX2v7eB61IheaBrH/","reward":true,"copyright":{"custom":"Copyright:自由转载-非商用-禁止演绎-保持署名（CC BY-NC-ND 4.0）"}}