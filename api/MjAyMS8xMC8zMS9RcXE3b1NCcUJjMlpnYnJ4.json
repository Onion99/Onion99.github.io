{"title":"CS理论 - 计算机网络","date":"2021-10-31T21:31:00.000Z","date_formatted":{"ll":"2021年10月31日","L":"2021/10/31","MM-DD":"10-31"},"thumbnail":"https://s1.ax1x.com/2022/03/14/bL0Ei8.md.png","link":"2021/10/31/Qqq7oSBqBc2Zgbrx","comments":true,"tags":["网络","计算机基础"],"categories":["CS理论"],"updated":"2021-10-31T13:30:32.000Z","content":"<h2 id=\"tcp/ip\">TCP/IP<a title=\"#tcp/ip\" href=\"#tcp/ip\"></a></h2>\n<blockquote>\n<p>两台计算机之间的通讯是通过TCP/IP协议在因特网上进行的</p>\n</blockquote>\n<p>TCP：Transmission Control Protocol 传输控制协议, 用于应用程序之间的通信<br>\nIP：Internet Protocol 网际协议, 用于计算机之间的通信</p>\n<span id=\"more\"></span>\n<h4 id=\"分层\">分层<a title=\"#分层\" href=\"#分层\"></a></h4>\n<blockquote>\n<p>因为网络具有不稳定性,要保证通信正常</p>\n</blockquote>\n<p><img src=\"https://z3.ax1x.com/2021/10/28/5qccSf.png\" alt=\"5qccSf.png\" loading=\"lazy\" class=\"φbp\"></p>\n<h4 id=\"tcp连接\">TCP连接<a title=\"#tcp连接\" href=\"#tcp连接\"></a></h4>\n<blockquote>\n<p>通信双方建立确认「可以通信」，不会将对方的消息丢弃，即为「建立连接」</p>\n</blockquote>\n<h5 id=\"连接建立(三次握手)\">连接建立(三次握手)<a title=\"#连接建立(三次握手)\" href=\"#连接建立(三次握手)\"></a></h5>\n<p><img src=\"https://z3.ax1x.com/2021/10/28/5LRCDS.png\" alt=\"5LRCDS.png\" loading=\"lazy\" class=\"φbp\"></p>\n<h5 id=\"连接关闭\">连接关闭<a title=\"#连接关闭\" href=\"#连接关闭\"></a></h5>\n<p><img src=\"https://z3.ax1x.com/2021/10/28/5LRGCR.png\" alt=\"5LRGCR.png\" loading=\"lazy\" class=\"φbp\"></p>\n<h5 id=\"长连接\">长连接<a title=\"#长连接\" href=\"#长连接\"></a></h5>\n<blockquote>\n<p>强制不让连接的通道关闭</p>\n</blockquote>\n<ul>\n<li>TCP短连接\n<ul>\n<li>client向server发起连接请求，server接到请求，然后双方建立连接。client向server 发送消息，server回应client，然后一次读写就完成了</li>\n<li>一般的server不会回复完client后立即关闭连接的, 所以一般是client先发起close操作</li>\n</ul>\n</li>\n<li>TCP长连接\n<ul>\n<li>client向server发起连接，server接受client连接，双方建立连接。Client与server完成一次读写之后，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接</li>\n</ul>\n</li>\n</ul>\n<p>怎样实现长连接？<br>\n⼼跳。即在一定间隔时间内，使⽤TCP连接发送超短无意义消息来让网关不能将⾃己定义为「空闲连接」，从而防止网关将⾃己的连接关闭</p>\n<h2 id=\"http\">HTTP<a title=\"#http\" href=\"#http\"></a></h2>\n<blockquote>\n<p>Hyper Text Transfer Protocol（超文本传输协议）缩写,基于 TCP/IP 通信协议来传输数据,应用层协议</p>\n</blockquote>\n<ul>\n<li>\n<p>简单快速：只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。由于简单，因而通信速度很快。</p>\n</li>\n<li>\n<p>灵活：HTTP 允许传输任意类型的数据对象，传输的类型由 Content-Type 标记。</p>\n</li>\n<li>\n<p>无连接：限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接，传输时间。</p>\n</li>\n<li>\n<p>无状态：指协议对于事务处理没有记忆能力，后续处理需要前面的信息，必须重传，导致每次连接传送的数据量增大。但不需要先前信息时应答快。</p>\n</li>\n</ul>\n<h3 id=\"报文组成\">报文组成<a title=\"#报文组成\" href=\"#报文组成\"></a></h3>\n<p>请求报文:</p>\n<ul>\n<li>\n<p>请求行：包括请求方法、URL、协议/版本</p>\n</li>\n<li>\n<p>请求头(Request Header)</p>\n</li>\n<li>\n<p>请求正文</p>\n</li>\n</ul>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET / HTTP1<span class=\"number\">.1</span>             </span><br><span class=\"line\">Host:https:<span class=\"comment\">//wanandroid.com/</span></span><br><span class=\"line\">User-Agent:Mozilla/<span class=\"number\">5.0</span> (Linux; Android <span class=\"number\">6.0</span>; Nexus <span class=\"number\">5</span> Build/MRA58N) AppleWebKit/<span class=\"number\">537.36</span> (KHTML, like Gecko) Chrome/<span class=\"number\">86.0</span><span class=\"number\">.4240</span><span class=\"number\">.198</span> Mobile Safari/<span class=\"number\">537.36</span></span><br><span class=\"line\">Content-Type:application/json;charset=UTF<span class=\"number\">-8</span></span><br><span class=\"line\">Content-Length:<span class=\"number\">40</span></span><br><span class=\"line\">Connection:Keep-Alive</span><br><span class=\"line\"></span><br><span class=\"line\">name: <span class=\"string\">&quot;test&quot;</span></span><br></pre></td></tr></table></figure>\n<p>响应报文:</p>\n<ul>\n<li>\n<p>状态行</p>\n</li>\n<li>\n<p>响应头</p>\n</li>\n<li>\n<p>响应正文</p>\n</li>\n</ul>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTTP/<span class=\"number\">1.1</span> <span class=\"number\">200</span> OK</span><br><span class=\"line\">Content-Type: application/json;charset=UTF<span class=\"number\">-8</span></span><br><span class=\"line\">Date: Wed, <span class=\"number\">03</span> Feb <span class=\"number\">2020</span> <span class=\"number\">09</span>:<span class=\"number\">47</span>:<span class=\"number\">32</span> GMT</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;<span class=\"attr\">&quot;data&quot;</span>:[&#123;<span class=\"attr\">&quot;children&quot;</span>:[],<span class=\"attr\">&quot;courseId&quot;</span>:<span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"原理\">原理<a title=\"#原理\" href=\"#原理\"></a></h3>\n<ul>\n<li>基于 TCP/IP 通信协议来传递数据的协议</li>\n<li>用于 B/S 架构</li>\n<li>默认端口 80</li>\n</ul>\n<p><img src=\"https://s1.ax1x.com/2022/03/08/bgpj9x.png\" alt=\"bgpj9x.png\" loading=\"lazy\" class=\"φbp\"></p>\n<h3 id=\"发展\">发展<a title=\"#发展\" href=\"#发展\"></a></h3>\n<h3 id=\"http-1.0\">HTTP 1.0<a title=\"#http-1.0\" href=\"#http-1.0\"></a></h3>\n<ul>\n<li>请求与响应支持 HTTP 头，响应含状态行，增加了状态码</li>\n<li>支持 HEAD，POST 方法</li>\n<li>支持传输 HTML 文件以外其他类型的内容</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>非持久连接：客户端必须为每一个待请求的对象建立并维护一个新的连接，短连接增加了网络传输的负担</li>\n</ul>\n<h4 id=\"http-1.1\">HTTP 1.1<a title=\"#http-1.1\" href=\"#http-1.1\"></a></h4>\n<ul>\n<li>支持长连接</li>\n<li>在HTTP1.0的基础上引入了更多的缓存控制策略</li>\n<li>引入了请求范围设置，优化了带宽</li>\n<li>在错误通知管理中新增了错误状态响应码</li>\n<li>增加了Host头处理，可以传递主机名（hostname）</li>\n</ul>\n<h4 id=\"https\">HTTPS<a title=\"#https\" href=\"#https\"></a></h4>\n<ul>\n<li>HTTPS 运行在安全套接字协议(Secure Sockets Layer，SSL )或传输层安全协议（Transport Layer Security，TLS）之上，所有在TCP中传输的内容都需要经过加密。</li>\n<li>连接方式不同，HTTP的端口是 80，HTTPS的端口是 443.</li>\n<li>HTTPS 可以有效防止运营商劫持。</li>\n</ul>\n<h4 id=\"http-1.x优化（spdy）\">HTTP 1.x优化（SPDY）<a title=\"#http-1.x优化（spdy）\" href=\"#http-1.x优化（spdy）\"></a></h4>\n<p>SPDY ：在 HTTP 之前做了一层会话层，为了达到减少页面加载时间的目标，SPDY 引入了一个新的二进制分帧数据层，以实现优先次序、最小化及消除不必要的网络延迟，目的是更有效地利用底层 TCP 连接。</p>\n<ul>\n<li>多路复用，为多路复用设立了请求优先级</li>\n<li>对 header 部分进行了压缩</li>\n<li>引入了 HTTPS 加密传输</li>\n<li>客户端可以在缓存中取到之前请求的内容</li>\n</ul>\n<h4 id=\"http-2.0\">HTTP 2.0<a title=\"#http-2.0\" href=\"#http-2.0\"></a></h4>\n<ul>\n<li>使用二进制分帧层：在应用层与传输层之间增加一个二进制分帧层</li>\n<li>多路复用</li>\n<li>服务端推送：logo、CSS 文件直接推给客户端</li>\n<li>数据流优先级：对数据流可以设置优先值，比如设置先传 css 文件等</li>\n<li>头部压缩</li>\n<li>支持明文传输，HTTP 1.X 使用 SSL/TLS 加密传输。</li>\n</ul>\n<p><img src=\"https://s1.ax1x.com/2022/03/08/bg9bM8.png\" alt=\"bg9bM8.png\" loading=\"lazy\" class=\"φbp\"></p>\n<h4 id=\"http-3.0（quic）\">HTTP 3.0（QUIC）<a title=\"#http-3.0（quic）\" href=\"#http-3.0（quic）\"></a></h4>\n<p>QUIC (Quick UDP Internet Connections)，快速 UDP 互联网连接，基于UDP 协议的。</p>\n<ul>\n<li>\n<p>线头阻塞(HOL)问题的解决更为彻底<br>\n基于TCP的HTTP/2，尽管从逻辑上来说，不同的流之间相互独立，不会相互影响，但在实际传输方面，数据还是要一帧一帧的发送和接收，一旦某一个流的数据有丢包，则同样会阻塞在它之后传输的流数据传输。而基于 UDP 的QUIC 协议则可以更为彻底地解决这样的问题，让不同的流之间真正的实现相互独立传输，互不干扰。</p>\n</li>\n<li>\n<p>切换网络时的连接保持<br>\n当前移动端的应用环境，用户的网络可能会经常切换，比如从办公室或家里出门，WiFi断开，网络切换为 3G 或 4G。基于TCP的协议，由于切换网络之后，IP会改变，因而之前的连接不可能继续保持。而基于 UD P的 QUIC 协议，则可以内建与 TCP 中不同的连接标识方法，从而在网络完成切换之后，恢复之前与服务器的连接。</p>\n</li>\n</ul>\n<h2 id=\"https-1\">HTTPS<a title=\"#https-1\" href=\"#https-1\"></a></h2>\n<blockquote>\n<p>是以安全为目标的 HTTP 通道(加密通信的HTTP)，其实就是 <strong>HTTP+SSL/TLS</strong></p>\n</blockquote>\n<h4 id=\"工作原理\">工作原理<a title=\"#工作原理\" href=\"#工作原理\"></a></h4>\n<blockquote>\n<p>在客户端和服务器之间协商出一套对称密钥，每次发送消息之前将内容加密，收到之后解密，达到内容的加密传输</p>\n</blockquote>\n<h5 id=\"为什么不直接用非对称加密?\">为什么不直接用非对称加密?<a title=\"#为什么不直接用非对称加密?\" href=\"#为什么不直接用非对称加密?\"></a></h5>\n<p>非对称加密由于使用了复杂的数学原理，因此计算相当复杂，如果完全使用非对称加密来加密通信内容，会严重影响网络通信的性能</p>\n<h4 id=\"https流程\">HTTPS流程<a title=\"#https流程\" href=\"#https流程\"></a></h4>\n<p><img src=\"https://s1.ax1x.com/2022/03/08/bgCnRx.png\" alt=\"bgCnRx.png\" loading=\"lazy\" class=\"φbp\"></p>\n<ol>\n<li>客户端请求建立TLS连接</li>\n<li>服务器发回证书</li>\n<li>客户端验证服务器证书</li>\n<li>客户端信任服务器后，和服务器协商对称密钥</li>\n<li>使用对称密钥开始通信</li>\n</ol>\n<h2 id=\"授权\">授权<a title=\"#授权\" href=\"#授权\"></a></h2>\n<p>登录：身份认证，确认你是你的过程。<br>\n授权：由身份或持有的令牌确认享有某些权限（例如获取用户信息）。登录过程实质上的目的也是为了确认权限</p>\n<h3 id=\"cookie\">Cookie<a title=\"#cookie\" href=\"#cookie\"></a></h3>\n<blockquote>\n<p>使用Cookie管理登录状态</p>\n</blockquote>\n<p><img src=\"https://z3.ax1x.com/2021/10/28/5qrP4f.png\" alt=\"5qrP4f.png\" loading=\"lazy\" class=\"φbp\"></p>\n<p><img src=\"https://z3.ax1x.com/2021/10/28/5qrmbn.png\" alt=\"5qrmbn.png\" loading=\"lazy\" class=\"φbp\"></p>\n<h4 id=\"cookie工作机制\">Cookie工作机制<a title=\"#cookie工作机制\" href=\"#cookie工作机制\"></a></h4>\n<ol>\n<li>服务器需要客户端保存的内容，放在Set-Cookie的headers里返回，客户端会自动保存。</li>\n<li>客户端保存的Cookies，会在之后的所有请求里都携带进Cookie header里发回给服务器。</li>\n<li>客户端保存Cookie是按照服务器域名来分类的，例如shop.com发回的Cookie保存下来以后，在之后向games.com的请求中并不会被携带。</li>\n<li>.客户端保存的Cookie在超时后会被删除，没有设置超时时间的Cookie（称作Session Cookie）在浏览器关闭后就会自动删除，另外，服务器也可以主动删除还未过期的客户端Cookies</li>\n<li>Cookie是由服务端管理的，客户端只是被动接受。</li>\n</ol>\n<h3 id=\"authorization-header\">Authorization Header<a title=\"#authorization-header\" href=\"#authorization-header\"></a></h3>\n<blockquote>\n<p>两种主流方式 Basic 和 Beare</p>\n</blockquote>\n<h4 id=\"basic\">Basic<a title=\"#basic\" href=\"#basic\"></a></h4>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span>格式：Authorization: Basic&lt;username:password(Base64)&gt;</span><br><span class=\"line\"><span class=\"number\">2.</span>Basic认证过程</span><br><span class=\"line\"><span class=\"number\">1.</span>浏览器发送请求到服务器</span><br><span class=\"line\">                GET / HTTP /<span class=\"number\">1.1</span></span><br><span class=\"line\">                Host:xxx.xxx.com</span><br><span class=\"line\"><span class=\"number\">2.</span>服务端发送验证请求<span class=\"number\">401</span></span><br><span class=\"line\">                HTTP/<span class=\"number\">1.1</span> <span class=\"number\">401</span> Unauthorised</span><br><span class=\"line\">                Server: bfe/<span class=\"number\">1.0</span><span class=\"number\">.8</span><span class=\"number\">.18</span></span><br><span class=\"line\">                WWW-Authenticate: Basic realm=<span class=\"string\">&quot;XXXXX.com&quot;</span></span><br><span class=\"line\">                Content-<span class=\"built_in\">Type</span>: text/html; charset=utf<span class=\"number\">-8</span></span><br><span class=\"line\"><span class=\"number\">3.</span>客户端收到<span class=\"number\">401</span>返回值后，将自动弹出登录窗口，等待用户输入用户名，密码</span><br><span class=\"line\"><span class=\"number\">4.</span>将用户名密码进行Base64编码后发送给服务端进行验证</span><br><span class=\"line\">                GET / HTTP/<span class=\"number\">1.1</span></span><br><span class=\"line\">                Host: xxx.xxx.xxx.com</span><br><span class=\"line\">                Authorization: Basic xxxxxxxxxxxxxxxxxxxxxxxxxxxx</span><br><span class=\"line\"><span class=\"number\">5.</span>服务端取出Authorization中头信息，并与数据库进行比对，如果合法则返回<span class=\"number\">200</span>，不合法，则返回<span class=\"number\">401</span>。</span><br></pre></td></tr></table></figure>\n<h4 id=\"bearer\">Bearer<a title=\"#bearer\" href=\"#bearer\"></a></h4>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span>格式：Authorization: Bearer &lt;bearer token&gt;</span><br><span class=\"line\"><span class=\"number\">2.</span>bearer token 的获取方式：通过OAuth2的授权流程</span><br><span class=\"line\"><span class=\"number\">3.</span>OAuth2的流程</span><br><span class=\"line\">            <span class=\"number\">1.</span>第三方网站向授权网站申请授权合作，拿到client <span class=\"keyword\">id</span>和client secret</span><br><span class=\"line\">            <span class=\"number\">2.</span>用户在使用第三方网站的时候，点击通过授权，第三方网站将跳转授权网站，并将clientid传递给授权网站。</span><br><span class=\"line\">            <span class=\"number\">4.</span>授权方网站根据clientid，将第三方网站的信息和第三方网站需要的用户权限展示给用户，询问用户是否同意授权。</span><br><span class=\"line\">            <span class=\"number\">5.</span>当用户点击同意授权，授权方网站返回第三方网站，并传入Authorization code作为用户认可的凭证。</span><br><span class=\"line\">            <span class=\"number\">6.</span>第三方网站将Authorization code上送给自己的服务器，服务器将Authorization code跟自己服务器端存储的client secret发送给授权方服务器，授权方服务器通过验证后，返回给access token，整个OAuth2流程结束。</span><br><span class=\"line\">            <span class=\"number\">7.</span>在整个OAuth流程结束后，第三方网站服务器可以试用access token 作用用户授权的token，用此来向授权方网站请求获取用户信息等操作。</span><br><span class=\"line\">        </span><br><span class=\"line\"><span class=\"number\">4.</span>问题：</span><br><span class=\"line\">            为什么OAuth认证要引入Authorization code，并且需要申请授权的第三方将Authorization code传给第三方服务器，并且通过第三方服务器将Authorization code传递给授权方服务器。然后再获取授权方服务器的access token。这样做的目的是为了通信安全，因为OAuth不强制使用HTTPS，因此需要保证通信路径中存在窃听者的时候，还能保证足够的安全。</span><br><span class=\"line\">            </span><br><span class=\"line\"><span class=\"number\">5.</span>第三方APP通过微信登录的流程：</span><br><span class=\"line\">            这是一个标准的OAuth2的流程。</span><br><span class=\"line\">            <span class=\"number\">1.</span>第三方APP向腾讯方申请合作，拿到client <span class=\"keyword\">id</span> 和client secret</span><br><span class=\"line\">            <span class=\"number\">2.</span>当用户在第三方APP上需要微信登录的时候，第三方APP将使用微信SDK打开微信授权页面，并且传入client <span class=\"keyword\">id</span>作为自己授权<span class=\"keyword\">id</span>。</span><br><span class=\"line\">            <span class=\"number\">3.</span>微信拿到第三方app的client <span class=\"keyword\">id</span>后，提交微信后台，验证成功，则返回给第三方app Authorization code。</span><br><span class=\"line\">            <span class=\"number\">4.</span>第三方app拿到Authorization code后，将Authorization code传递给自己的服务器，第三方app的服务端将Authorization code 与 client secret 传递给微信后台，微信后台验证后返回access token。</span><br><span class=\"line\">            <span class=\"number\">5.</span>第三方app后台通过access token 想微信后台请求获取用户信息，微信验证通过后，则返回用户信息。</span><br><span class=\"line\">            <span class=\"number\">6.</span>服务器接受到用户信息后，在自己的数据库中建立一个账户，并将从微信获取的用户信息填入数据库中。并创建用户<span class=\"keyword\">id</span>，并将此<span class=\"keyword\">id</span>与微信<span class=\"keyword\">id</span>做好关联。</span><br><span class=\"line\">            <span class=\"number\">7.</span>当第三方app后台创建好用户后，想客户端的请求发出响应，并回传会刚刚创建的用户信息。</span><br><span class=\"line\">            <span class=\"number\">8.</span>客户端响应，获取用户信息，登录成功。</span><br><span class=\"line\">            </span><br><span class=\"line\"><span class=\"number\">6.</span>在自家APP中使用Bearer token</span><br><span class=\"line\">            部分app会在api设计中，将登录和授权设计出类似于OAuth2的过程，他会简化掉Authorization code的概念。既直接在接口请求成功后，返回access token，然后再之后的客户端的请求中，使用这个access token 作为Bearer token进行用户操作。</span><br><span class=\"line\">            </span><br><span class=\"line\"><span class=\"number\">7.</span>Refresh token</span><br><span class=\"line\">            Access token 都会有失效时间，当他失效后，第三方app的服务端会通过refresh token 接口传入refresh token 来获取新的access token。这样的的原因是安全，因为refresh token是放置在服务端的，即使access token被窃取，他也是有失效时间的。</span><br></pre></td></tr></table></figure>\n<h2 id=\"refer\">Refer<a title=\"#refer\" href=\"#refer\"></a></h2>\n<p><a href=\"https://www.jianshu.com/p/2a890d952461\" target=\"_blank\">登录授权、TCP/IP、HTTPS和代理</a><br>\n<a href=\"https://blog.csdn.net/kimlllll/article/details/103041225\" target=\"_blank\">编码、加密、Hash、TCP/IP、HTTPS</a><br>\n<a href=\"https://github.com/hsicen/HencoderPlus/blob/master/note/04-TCPIP%E5%92%8CHTTPS.md\" target=\"_blank\">HencoderPlus/04-TCPIP和HTTPS</a></p>\n","prev":{"title":"CS理论 - 编码与加密","link":"2021/10/31/MgnT9VQ3PhWZOJAq"},"next":{"title":"源码学习 - Glide","link":"2021/10/31/15jfHwStpctgCeeA"},"plink":"https://onion99.github.io/2021/10/31/Qqq7oSBqBc2Zgbrx/","toc":[{"id":"tcp/ip","title":"TCP&#x2F;IP","index":"1"},{"id":"http","title":"HTTP","index":"2"},{"id":"https-1","title":"HTTPS","index":"3"},{"id":"授权","title":"授权","index":"4"},{"id":"refer","title":"Refer","index":"5"}],"reward":true,"copyright":{"custom":"Copyright:自由转载-非商用-禁止演绎-保持署名（CC BY-NC-ND 4.0）"}}