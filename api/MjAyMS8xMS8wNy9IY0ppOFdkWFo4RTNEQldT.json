{"title":"Java并发(3) - Lock","date":"2021-11-07T18:59:09.000Z","date_formatted":{"ll":"2021年11月7日","L":"2021/11/07","MM-DD":"11-07"},"link":"2021/11/07/HcJi8WdXZ8E3DBWS","comments":true,"tags":["并发"],"categories":["Java"],"updated":"2021-11-07T10:58:11.000Z","content":"<blockquote>\n<p>锁是用于通过多个线程控制对共享资源的访问的工具</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Lock lock = <span class=\"keyword\">new</span> ReentrantLock();</span><br><span class=\"line\">lock.lock();</span><br><span class=\"line\"><span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//临界区......</span></span><br><span class=\"line\">&#125;<span class=\"keyword\">finally</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//最好不要把获取锁的过程写在 try 语句块中，因为如果在获取锁时发生了异常，异常抛出的同时也会导致锁无法被释放</span></span><br><span class=\"line\">    lock.unlock();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<span id=\"more\"></span>\n<h3 id=\"特性和方法\">特性和方法<a title=\"#特性和方法\" href=\"#特性和方法\"></a></h3>\n<p>提供synchronized不具备的主要特性:</p>\n<div class=\"φbq\"><div class=\"φbs\"><table><thead>\n<tr>\n<th style=\"text-align:center\">特性</th>\n<th style=\"text-align:center\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">以非阻塞地获取锁</td>\n<td style=\"text-align:center\">当前线程尝试获取锁，如果这一时刻锁没有被其他线程获取到，则成功获取并持有锁</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">可以被中断地获取锁</td>\n<td style=\"text-align:center\">获取到锁的线程能够响应中断，当获取到锁的线程被中断时，中断异常将会被抛出，同时锁会被释放</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">超时的方式获取锁</td>\n<td style=\"text-align:center\">在指定的截止时间之前获取锁,超时后仍旧无法获取则返回</td>\n</tr>\n</tbody>\n</table></div></div><div class=\"φbq\"><div class=\"φbs\"><table><thead>\n<tr>\n<th style=\"text-align:center\">Method</th>\n<th style=\"text-align:center\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">lock()</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">获取锁。如果锁不可用,则当前线程将被禁用以进行线程调度，并处于休眠状态，等待直到获取锁。</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">lockInterruptibly()</td>\n<td style=\"text-align:center\">可以中断的去获取锁</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">newCondition()</td>\n<td style=\"text-align:center\">返回当前锁的Condition(等待条件),在Condition之前，当前线程必须持有锁,调用Condition.wait 当前线程将释放锁</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">tryLock()</td>\n<td style=\"text-align:center\">直接获取锁,可以true,不可以false</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">tryLock(time,unit)</td>\n<td style=\"text-align:center\">超时获取锁,有三种情况:1.当前线程在超时时间内获得了锁;2.当前线程被中断;3.超时时间结束，返回false</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">unlock()</td>\n<td style=\"text-align:center\">释放锁</td>\n</tr>\n</tbody>\n</table></div></div><h3 id=\"reentrantlock\">ReentrantLock<a title=\"#reentrantlock\" href=\"#reentrantlock\"></a></h3>\n<blockquote>\n<p>ReentrantLock 和 synchronized声明一样可以用来实现线程之间的同步互斥，但在功能上比 synchronized声明 更强大而且更灵活</p>\n</blockquote>\n<div class=\"φbq\"><div class=\"φbs\"><table><thead>\n<tr>\n<th>构造Method</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ReentrantLock()</td>\n<td>创建一个 ReentrantLock的实例</td>\n</tr>\n<tr>\n<td>ReentrantLock(boolean fair)</td>\n<td>创建一个特定锁类型（公平锁/非公平锁）的ReentrantLock的实例</td>\n</tr>\n</tbody>\n</table></div></div><ul>\n<li>公平锁: 先来先得, 线程调度有序</li>\n<li>非公平锁: 一种获取锁的抢占机制,谁快谁得,线程调度无序</li>\n</ul>\n<div class=\"φbq\"><div class=\"φbs\"><table><thead>\n<tr>\n<th>调用Method</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>getHoldCount()</td>\n<td>调用lock()方法的次数</td>\n</tr>\n<tr>\n<td>getOwner()</td>\n<td>返回当前拥有此锁的线程，如果不拥有，则返回 null</td>\n</tr>\n<tr>\n<td>getQueuedThreads()</td>\n<td>返回正在等待获取此锁的线程的集合</td>\n</tr>\n<tr>\n<td>getWaitingThreads()</td>\n<td>返回与此锁相关联的Condition下等待的线程的集合</td>\n</tr>\n<tr>\n<td>hasQueuedThread()</td>\n<td>查询给定线程是否等待获取锁</td>\n</tr>\n<tr>\n<td>hasQueuedThreads()</td>\n<td>查询否有线程正在等待获取锁</td>\n</tr>\n<tr>\n<td>hasWaiters()</td>\n<td>查询任何线程是否等待与此锁相关联的给定条件</td>\n</tr>\n<tr>\n<td>isHeldByCurrentThread()</td>\n<td>查询此锁是否由当前线程持有</td>\n</tr>\n</tbody>\n</table></div></div><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReentrantLockTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        MyService service = <span class=\"keyword\">new</span> MyService();</span><br><span class=\"line\">        MyThread a1 = <span class=\"keyword\">new</span> MyThread(service);</span><br><span class=\"line\">        MyThread a2 = <span class=\"keyword\">new</span> MyThread(service);</span><br><span class=\"line\">        MyThread a3 = <span class=\"keyword\">new</span> MyThread(service);</span><br><span class=\"line\">        a1.start();</span><br><span class=\"line\">        a2.start();</span><br><span class=\"line\">        a3.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyService</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> Lock lock = <span class=\"keyword\">new</span> ReentrantLock();</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testMethod</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            lock.lock();</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">              System.out.println(<span class=\"string\">&quot;ThreadName=&quot;</span> + Thread.currentThread().getName() + (<span class=\"string\">&quot; &quot;</span> + (i + <span class=\"number\">1</span>)));</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">              lock.unlock();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 结果:当一个线程运行完毕后才把锁释放，其他线程才能执行</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> MyService service;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyThread</span><span class=\"params\">(MyService service)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">super</span>();</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.service = service;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            service.testMethod();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"condition\">Condition<a title=\"#condition\" href=\"#condition\"></a></h3>\n<blockquote>\n<p>线程对象可以注册指定的Condition, 从而可以有选择性的进行线程通知,使得线程调度上更加灵活</p>\n</blockquote>\n<div class=\"φbq\"><div class=\"φbs\"><table><thead>\n<tr>\n<th style=\"text-align:center\">Method</th>\n<th style=\"text-align:center\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">await()</td>\n<td style=\"text-align:center\">使当前线程等待，直到它收到信号或被中断</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">signal()</td>\n<td style=\"text-align:center\">发出信号,唤醒一个等待线程</td>\n</tr>\n</tbody>\n</table></div></div><p>思路理清:</p>\n<ol>\n<li>首先<code>a.start()</code> 输出<code>&quot;await&quot;</code>,然后进入<code>condition.await()</code></li>\n<li>3s后<code>service.signal()</code> 输出<code>&quot;signal&quot;</code></li>\n<li>进入<code>condition.signal()</code> , 3s后输出<code>&quot;最好的signal()的语句&quot;</code></li>\n<li>再之后输出<code>&quot;signal之后的语句&quot;</code></li>\n</ol>\n<p>等待/通知的实现:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UseSingleConditionWaitNotify</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        MyService service = <span class=\"keyword\">new</span> MyService();</span><br><span class=\"line\">        ThreadA a = <span class=\"keyword\">new</span> ThreadA(service);</span><br><span class=\"line\">        a.start();</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">3000</span>);</span><br><span class=\"line\">        service.signal();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyService</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> Lock lock = <span class=\"keyword\">new</span> ReentrantLock();</span><br><span class=\"line\">        <span class=\"keyword\">public</span> Condition condition = lock.newCondition();</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">await</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            lock.lock();</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot; await&quot;</span>);</span><br><span class=\"line\">                condition.await();</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;signal之后的语句&quot;</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                lock.unlock();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">signal</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">            lock.lock();</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;\t\t\t\t</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;signal&quot;</span>);</span><br><span class=\"line\">                condition.signal();</span><br><span class=\"line\">                Thread.sleep(<span class=\"number\">3000</span>);</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;最好的signal()的语句&quot;</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                lock.unlock();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThreadA</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> MyService service;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ThreadA</span><span class=\"params\">(MyService service)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">super</span>();</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.service = service;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            service.await();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"readwritelock-接口的实现类：reentrantreadwritelock\">ReadWriteLock 接口的实现类：ReentrantReadWriteLock<a title=\"#readwritelock-接口的实现类：reentrantreadwritelock\" href=\"#readwritelock-接口的实现类：reentrantreadwritelock\"></a></h3>\n<blockquote>\n<p>ReentrantLock（排他锁）具有完全互斥排他的效果，即同一时刻只允许一个线程访问,效率低下,ReadWriteLock 接口的实现类 ReentrantReadWriteLock 读写锁就是为了解决这个问题。读写锁维护了两个锁，一个是读操作相关的锁成为共享锁，一个是写操作相关的锁为排他锁。通过分离读锁和写锁，其并发性比一般排他锁有了很大提升</p>\n</blockquote>\n<ul>\n<li>读读共享</li>\n<li>写写互斥</li>\n<li>读写互斥</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> ReentrantReadWriteLock lock = <span class=\"keyword\">new</span> ReentrantReadWriteLock();</span><br><span class=\"line\"><span class=\"comment\">// 读读共享情况,输出可以发现两个线程几乎可以同时运行</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">read</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            lock.readLock().lock();</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;获得读锁&quot;</span> + Thread.currentThread().getName()</span><br><span class=\"line\">                    + <span class=\"string\">&quot; &quot;</span> + System.currentTimeMillis());</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">10000</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            lock.readLock().unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// TODO Auto-generated catch block</span></span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","prev":{"title":"Java并发(4) - CAS","link":"2021/11/07/qX2v7eB61IheaBrH"},"next":{"title":"Java并发(2) - synchronize","link":"2021/11/07/FEETAEwJ336KYqim"},"plink":"https://onion99.github.io/2021/11/07/HcJi8WdXZ8E3DBWS/","reward":true,"copyright":{"custom":"Copyright:自由转载-非商用-禁止演绎-保持署名（CC BY-NC-ND 4.0）"}}