{"title":"自定义View(7) - layout 布局过程","date":"2021-11-03T22:02:46.000Z","date_formatted":{"ll":"2021年11月3日","L":"2021/11/03","MM-DD":"11-03"},"link":"2021/11/03/ZyOr4iLxJj7nAQxR","comments":true,"tags":["图形绘制"],"categories":["Android"],"updated":"2021-11-03T14:01:26.000Z","content":"<p><img src=\"https://s2.ax1x.com/2019/12/06/QJQEcR.jpg\" alt=\"viewasds\" loading=\"lazy\" class=\"φbp\"></p>\n<span id=\"more\"></span>\n<h3 id=\"layout-类型\">layout 类型<a title=\"#layout-类型\" href=\"#layout-类型\"></a></h3>\n<p><img src=\"https://z3.ax1x.com/2021/11/03/IA7tv4.png\" alt=\"IA7tv4.png\" loading=\"lazy\" class=\"φbp\"></p>\n<h3 id=\"view-的-layout-过程\">View 的 layout 过程<a title=\"#view-的-layout-过程\" href=\"#view-的-layout-过程\"></a></h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 指定视图及其所有子视图的大小和位置 这是布局机制的第二阶段</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">layout</span><span class=\"params\">(<span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> t, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> b)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 判断是否measure,没有的话再measure一遍</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec);</span><br><span class=\"line\">        mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 当前视图的四个顶点</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> oldL = mLeft;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> oldT = mTop;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> oldB = mBottom;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> oldR = mRight;</span><br><span class=\"line\">    <span class=\"comment\">// 判断视图大小或者位置是否发生改变</span></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> changed = isLayoutModeOptical(mParent) ?</span><br><span class=\"line\">            setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);</span><br><span class=\"line\">    <span class=\"comment\">// 发生改变        </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123;</span><br><span class=\"line\">        onLayout(changed, l, t, r, b);</span><br><span class=\"line\">        <span class=\"comment\">// 对于单一View的laytou过程：由于单一View是没有子View的，故onLayout（）是一个空实现-&gt;&gt;分析3</span></span><br><span class=\"line\">        <span class=\"comment\">// 对于ViewGroup的laytou过程：由于确定位置与具体布局有关，所以onLayout（）在ViewGroup为1个抽象方法，需重写实现</span></span><br><span class=\"line\"></span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://z3.ax1x.com/2021/11/03/IAqjZd.png\" alt=\"IAqjZd.png\" loading=\"lazy\" class=\"φbp\"></p>\n<h3 id=\"viewgroup-的-layout-过程\">ViewGroup 的 layout 过程<a title=\"#viewgroup-的-layout-过程\" href=\"#viewgroup-的-layout-过程\"></a></h3>\n<blockquote>\n<p>ViewGroup 的 layout 过程确定位置与具体的布局有关，所以在 ViewGroup 中是一个抽象方法，需要重写实现</p>\n</blockquote>\n<p>复写<code> onLayout()</code>步骤:</p>\n<ol>\n<li>遍历所有子 View</li>\n<li>根据自身需求计算当前子 View 的四个位置值（需自身实现）</li>\n<li>根据上述 4 个位置的计算值，设置子 View 的 4 个顶点：调用子 View 的 layout 方法，即确定了子 View 在父容器里的位置</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ViewGroup的onLayout实现的大致思路</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onLayout</span><span class=\"params\">(<span class=\"keyword\">boolean</span> changed, <span class=\"keyword\">int</span> left, <span class=\"keyword\">int</span> top, <span class=\"keyword\">int</span> right, <span class=\"keyword\">int</span> bottom)</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// 参数说明</span></span><br><span class=\"line\">   <span class=\"comment\">// changed 当前View的大小和位置改变了 </span></span><br><span class=\"line\">   <span class=\"comment\">// left 左部位置  top 顶部位置  right 右部位置  bottom 底部位置</span></span><br><span class=\"line\">   <span class=\"comment\">// 1. 遍历子View：循环所有子View</span></span><br><span class=\"line\">   <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;getChildCount(); i++) &#123;</span><br><span class=\"line\">         View child = getChildAt(i);   </span><br><span class=\"line\">         <span class=\"comment\">// 2. 计算当前子View的四个位置值</span></span><br><span class=\"line\">         <span class=\"comment\">// 2.1 位置的计算逻辑需自己实现，也是自定义View的关键</span></span><br><span class=\"line\">         calculate();</span><br><span class=\"line\">         <span class=\"comment\">// 2.2 对计算后的位置值进行赋值</span></span><br><span class=\"line\">         <span class=\"keyword\">int</span> mLeft  = Left</span><br><span class=\"line\">         <span class=\"keyword\">int</span> mTop  = Top</span><br><span class=\"line\">         <span class=\"keyword\">int</span> mRight = Right</span><br><span class=\"line\">         <span class=\"keyword\">int</span> mBottom = Bottom</span><br><span class=\"line\"> </span><br><span class=\"line\">       <span class=\"comment\">// 3. 根据上述4个位置的计算值设置子View的4个顶点：调用子view的layout() &amp; 传递计算过的参数</span></span><br><span class=\"line\">       <span class=\"comment\">// 即确定了子View在父容器的位置</span></span><br><span class=\"line\">       child.layout(mLeft, mTop, mRight, mBottom);</span><br><span class=\"line\">       <span class=\"comment\">// 该过程类似于单一View的layout过程中的layout()和onLayout()</span></span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://z3.ax1x.com/2021/11/03/IAL1L4.png\" alt=\"IAL1L4.png\" loading=\"lazy\" class=\"φbp\"></p>\n<h4 id=\"viewgroup-子类（linearlayout）的-layout-过程分析\">ViewGroup 子类（LinearLayout）的 layout 过程分析<a title=\"#viewgroup-子类（linearlayout）的-layout-过程分析\" href=\"#viewgroup-子类（linearlayout）的-layout-过程分析\"></a></h4>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onLayout</span><span class=\"params\">(<span class=\"keyword\">boolean</span> changed, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> t, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> b)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 根据自身方向属性，而选择不同的处理方式</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mOrientation == VERTICAL) &#123;</span><br><span class=\"line\">        layoutVertical(l, t, r, b);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        layoutHorizontal(l, t, r, b);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>根据 LinearLayout 的方向（vertical、horizontal）进入不同的布局过程，这里我们只选垂直方向的布局过程，即layoutVertical()</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">layoutVertical</span><span class=\"params\">(<span class=\"keyword\">int</span> left, <span class=\"keyword\">int</span> top, <span class=\"keyword\">int</span> right, <span class=\"keyword\">int</span> bottom)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 子View的数量</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> count = getVirtualChildCount();</span><br><span class=\"line\">    <span class=\"comment\">// 1. 遍历子View</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; count; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> View child = getVirtualChildAt(i);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (child == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            childTop += measureNullChild(i);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (child.getVisibility() != GONE) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 2. 计算子View的测量宽 / 高值</span></span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> childWidth = child.getMeasuredWidth();</span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> childHeight = child.getMeasuredHeight();</span><br><span class=\"line\"> </span><br><span class=\"line\">            <span class=\"comment\">// 3. 确定自身子View的位置</span></span><br><span class=\"line\">            <span class=\"comment\">// 即：递归调用子View的setChildFrame()，实际上是调用了子View的layout() -&gt;&gt;分析2</span></span><br><span class=\"line\">            setChildFrame(child, childLeft, childTop + getLocationOffset(child), childWidth, childHeight);</span><br><span class=\"line\"> </span><br><span class=\"line\">            <span class=\"comment\">// childTop逐渐增大，即后面的子元素会被放置在靠下的位置</span></span><br><span class=\"line\">            <span class=\"comment\">// 这符合垂直方向的LinearLayout的特性</span></span><br><span class=\"line\">            childTop += childHeight + lp.bottomMargin + getNextLocationOffset(child);</span><br><span class=\"line\"> </span><br><span class=\"line\">            i += getChildrenSkipCount(child, i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">setChildFrame</span><span class=\"params\">( View child, <span class=\"keyword\">int</span> left, <span class=\"keyword\">int</span> top, <span class=\"keyword\">int</span> width, <span class=\"keyword\">int</span> height)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// setChildFrame（）仅仅只是调用了子View的layout（）而已</span></span><br><span class=\"line\">    child.layout(left, top, left ++ width, top + height);</span><br><span class=\"line\">    <span class=\"comment\">// 在子View的layout（）又通过调用setFrame（）确定View的四个顶点</span></span><br><span class=\"line\">    <span class=\"comment\">// 即确定了子View的位置</span></span><br><span class=\"line\">    <span class=\"comment\">// 如此不断循环确定所有子View的位置，最终确定ViewGroup的位置</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"getmeasurewidth-和-getwidth-区别\">getMeasureWidth 和 getWidth 区别<a title=\"#getmeasurewidth-和-getwidth-区别\" href=\"#getmeasurewidth-和-getwidth-区别\"></a></h3>\n<blockquote>\n<p>某些情况下，View 需要多次 measure 才能确定自己的测量宽高，在前几次的测量过程中，其得出的测量宽高有可能和最终宽高不一致.，但最终来说，测量宽高还是和最终宽高相同。</p>\n</blockquote>\n<p><img src=\"https://z3.ax1x.com/2021/11/03/IAjrmF.png\" alt=\"IAjrmF.png\" loading=\"lazy\" class=\"φbp\"></p>\n","prev":{"title":"自定义View(8) - draw 绘制过程","link":"2021/11/03/p4CRfuQemJ4TOlAs"},"next":{"title":"自定义View(6) - measure 测量过程","link":"2021/11/03/Qj9f1VMJJowv5Lfb"},"plink":"https://onion99.github.io/2021/11/03/ZyOr4iLxJj7nAQxR/","reward":true,"copyright":{"custom":"Copyright:自由转载-非商用-禁止演绎-保持署名（CC BY-NC-ND 4.0）"}}