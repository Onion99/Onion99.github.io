{"per_page":9,"total":5,"current":2,"data":[{"title":"Java并发(6) - 线程池","date":"2021-11-07T19:05:17.000Z","date_formatted":{"ll":"2021年11月7日","L":"2021/11/07","MM-DD":"11-07"},"excerpt":"<p>线程池对比new Thread()</p>\n<ul>\n<li>重用存在的线程，减少线程创建、消亡的开销，性能佳。</li>\n<li>可有效控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞</li>\n<li>提供定时执行、定期执行、单线程、并发数控制等功能</li>\n</ul>\n<p>ExecutorService 是最初的线程池接口，ThreadPoolExecutor 类是对线程池的具体实现:</p>\n<div class=\"φbq\"><div class=\"φbs\"><table><thead>\n<tr>\n<th style=\"text-align:center\">构造参数</th>\n<th style=\"text-align:right\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">corePoolSize</td>\n<td style=\"text-align:right\">核心线程的数量,默认情况下,即使核心线程没有任务在执行它也存在的,我们固定一定数量的核心线程且它一直存活,这样就避免了一般情况下CPU创建和销毁线程带来的开销。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">maximumPoolSize</td>\n<td style=\"text-align:right\">最大线程数，当任务数量超过最大线程数时其它任务可能就会被阻塞。最大线程数 = 核心线程 + 非核心线程。非核心线程只有当核心线程不够用且线程池有空余时才会被创建，执行完任务后非核心线程会被销毁。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">keepAliveTime</td>\n<td style=\"text-align:right\">非核心线程的超时时长,当执行时间超过这个时间时,非核心线程就会被回收。当 allowCoreThreadTimeOut设置为true时,此属性也作用在核心线程上</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">unit</td>\n<td style=\"text-align:right\">时间单位</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">workQueue</td>\n<td style=\"text-align:right\">任务队列,我们提交给线程池的 runnable 会被存储在这个对象上</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">threadFactory</td>\n<td style=\"text-align:right\">线程工厂,用于指定为线程池创建新线程的方式</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">handler</td>\n<td style=\"text-align:right\">拒绝策略</td>\n</tr>\n</tbody>\n</table></div></div>","link":"2021/11/07/oizxmTtLdVsaXZrZ","tags":["并发"],"categories":["Java"]},{"title":"Java并发(5) - 线程协作","date":"2021-11-07T19:04:05.000Z","date_formatted":{"ll":"2021年11月7日","L":"2021/11/07","MM-DD":"11-07"},"excerpt":"<h3 id=\"线程状态\">线程状态<a title=\"#线程状态\" href=\"#线程状态\"></a></h3>\n<p><img src=\"https://z3.ax1x.com/2021/11/05/InuMpd.png\" alt=\"InuMpd.png\" loading=\"lazy\" class=\"φbp\"></p>","link":"2021/11/07/WkWqwHwU8wgNL4cd","tags":["并发"],"categories":["Java"]},{"title":"Java并发(4) - CAS","date":"2021-11-07T18:59:57.000Z","date_formatted":{"ll":"2021年11月7日","L":"2021/11/07","MM-DD":"11-07"},"excerpt":"<p>锁机制问题:</p>\n<ul>\n<li>在多线程竞争下，加锁、释放锁会导致比较多的上下文切换和调度延时，引起性能问题</li>\n<li>一个线程持有锁会导致其它所有需要此锁的线程挂起</li>\n<li>如果一个优先级高的线程等待一个优先级低的线程释放锁会导致优先级倒置，引起性能风险</li>\n</ul>\n<p>volatile 是不错的机制，但是 volatile 不能保证原子性，因此对于同步最终还是要回到锁机制上来。独占锁是一种悲观锁，synchronized 就是一种独占锁，会导致其它所有需要锁的线程挂起，等待持有锁的线程释放锁。而另一个更加有效的锁就是乐观锁</p>\n<blockquote>\n<p>乐观锁即总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和 CAS 算法实现</p>\n</blockquote>","link":"2021/11/07/qX2v7eB61IheaBrH","tags":["并发"],"categories":["Android"]},{"title":"Java并发(3) - Lock","date":"2021-11-07T18:59:09.000Z","date_formatted":{"ll":"2021年11月7日","L":"2021/11/07","MM-DD":"11-07"},"excerpt":"<blockquote>\n<p>锁是用于通过多个线程控制对共享资源的访问的工具</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Lock lock = <span class=\"keyword\">new</span> ReentrantLock();</span><br><span class=\"line\">lock.lock();</span><br><span class=\"line\"><span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//临界区......</span></span><br><span class=\"line\">&#125;<span class=\"keyword\">finally</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//最好不要把获取锁的过程写在 try 语句块中，因为如果在获取锁时发生了异常，异常抛出的同时也会导致锁无法被释放</span></span><br><span class=\"line\">    lock.unlock();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","link":"2021/11/07/HcJi8WdXZ8E3DBWS","tags":["并发"],"categories":["Java"]},{"title":"Java并发(2) - synchronize","date":"2021-11-07T18:55:09.000Z","date_formatted":{"ll":"2021年11月7日","L":"2021/11/07","MM-DD":"11-07"},"excerpt":"<blockquote>\n<p>在 Java 中，关键字 synchronized 可以保证在同一个时刻，只有一个线程可以执行某个方法或者某个代码块,也可以保证一个线程的变化(主要是共享数据的变化)被其他线程所看到</p>\n</blockquote>\n<p>锁就是为达到这种互斥访问目的诞生的,从宏观上锁分为乐观锁和悲观锁</p>\n<ul>\n<li>乐观锁：认为读多写少，遇到并发写情况较少\n<ul>\n<li>Java 中 java.util.concurrent.atomic 包下面的原子变量类就是使用了乐观锁的一种实现方式 CAS 实现的</li>\n</ul>\n</li>\n<li>悲观锁：即认为写多，遇到并发写情况较多\n<ul>\n<li>Java 中 synchronized 和 ReentrantLock 等独占锁就是悲观锁思想的实现。</li>\n</ul>\n</li>\n</ul>","link":"2021/11/07/FEETAEwJ336KYqim","tags":["并发"],"categories":["Java"]},{"title":"Java并发(1) - volatile","date":"2021-11-07T15:50:26.000Z","date_formatted":{"ll":"2021年11月7日","L":"2021/11/07","MM-DD":"11-07"},"excerpt":"<h3 id=\"java内存模型\">JAVA内存模型<a title=\"#java内存模型\" href=\"#java内存模型\"></a></h3>\n<p><img src=\"https://z3.ax1x.com/2021/11/04/IZ6xs0.png\" alt=\"IZ6xs0.png\" loading=\"lazy\" class=\"φbp\"></p>\n<p>Java 内存模型规定了所有的变量都存储在主内存中。每条线程有自己的工作内存，线程的工作内存保存了被该线程所使用到的变量（从主内存中拷贝而来）。线程对变量的所有操作（读取，赋值）都必须在工作内存中进行。不同线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成</p>","link":"2021/11/07/VqykJCDZZcenZo3O","tags":["并发"],"categories":["Java"]},{"title":"自定义View(11) - 滚动速度和滚动计算","date":"2021-11-03T22:09:36.000Z","date_formatted":{"ll":"2021年11月3日","L":"2021/11/03","MM-DD":"11-03"},"excerpt":"<h3 id=\"velocitytracker\">VelocityTracker<a title=\"#velocitytracker\" href=\"#velocitytracker\"></a></h3>\n<blockquote>\n<p>跟踪手指在滑动过程中的速度，包括水平和竖直方向的速度</p>\n</blockquote>","link":"2021/11/03/cNDSpE5p4avS2tOi","tags":["图形绘制"],"categories":["Android"]},{"title":"自定义View(10) - GestureDetector","date":"2021-11-03T22:08:39.000Z","date_formatted":{"ll":"2021年11月3日","L":"2021/11/03","MM-DD":"11-03"},"excerpt":"<h3 id=\"gesturedetector\">GestureDetector<a title=\"#gesturedetector\" href=\"#gesturedetector\"></a></h3>\n<div class=\"φbq\"><div class=\"φbs\"><table><thead>\n<tr>\n<th>监听器</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>OnContextClickListener</td>\n<td>这个很容易让人联想到ContextMenu，然而它和ContextMenu并没有什么关系，它是在Android6.0(API 23)才添加的一个选项，是用于检测外部设备上的按钮是否按下的，例如蓝牙触控笔上的按钮，一般情况下，忽略即可。</td>\n</tr>\n<tr>\n<td>OnDoubleTapListener</td>\n<td>双击事件，有三个回调类型：双击(DoubleTap)、单击确认(SingleTapConfirmed) 和 双击事件回调(DoubleTapEvent)</td>\n</tr>\n<tr>\n<td>OnGestureListener</td>\n<td>手势检测，主要有以下类型事件：按下(Down)、 一扔(Fling)、长按(LongPress)、滚动(Scroll)、触摸反馈(ShowPress) 和 单击抬起(SingleTapUp)</td>\n</tr>\n<tr>\n<td>SimpleOnGestureListener</td>\n<td>这个是上述三个接口的空实现，一般情况下使用这个比较多，也比较方便</td>\n</tr>\n</tbody>\n</table></div></div>","link":"2021/11/03/dY7a31QepeVitGkX","tags":["图形绘制"],"categories":["Android"]},{"title":"自定义View(9) - 事件分发","date":"2021-11-03T22:07:31.000Z","date_formatted":{"ll":"2021年11月3日","L":"2021/11/03","MM-DD":"11-03"},"excerpt":"<blockquote>\n<p>事件分发的过程其实也就是事件传递过程。事件传递的顺序由Acticity传递到根View，这个根View 通常是一个ViewGroup(ViewGroup本身也是View的子类)，然后再传递给ViewGroup下的子View, 若事件在自上而下的传递过程中一直没有被消费，则事件会反向向上传递，此时父ViewGroup可以对事件进行消费，若仍然没有被消费的话，最后会回到Activity的onTouchEvent</p>\n</blockquote>\n<p>所以很多时候如果有冲突的话,最先消费的是最底部的子View<br>\n<img src=\"https://z3.ax1x.com/2021/11/03/IE3gqf.png\" alt=\"IE3gqf.png\" loading=\"lazy\"></p>","link":"2021/11/03/z3aQsRLVolBbFVsl","tags":["图形绘制"],"categories":["Android"]}]}