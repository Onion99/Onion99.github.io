{"title":"源码学习-OkHttp","date":"2021-10-31T21:28:18.000Z","date_formatted":{"ll":"2021年10月31日","L":"2021/10/31","MM-DD":"10-31"},"link":"2021/10/31/4SVquTFcR8Wyv4GV","comments":true,"tags":["源码解析"],"categories":["Android"],"updated":"2021-10-31T13:27:51.000Z","content":"<blockquote>\n<p>http的连接本质上是个socket，根据http协议，通过socket包装发送请求并获得返回结果</p>\n</blockquote>\n<p>网路连接库一开始的样子如下代码所示，其实只要符合Http协议的请求，就可以和网络进行交互，类似于OkHttp的网络请求库，帮助开发者方便和屏蔽了Http协议中类似于请求头，重连、合并、代理、返回结果解析等等Http协议细节的应用层实现。</p>\n<span id=\"more\"></span>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">val path = <span class=\"string\">&quot;http://www.baidu.com/&quot;</span></span><br><span class=\"line\">        val host = <span class=\"string\">&quot;www.baidu.com&quot;</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> socket: Socket? = <span class=\"keyword\">null</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> streamWriter: OutputStreamWriter? = <span class=\"keyword\">null</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> bufferedWriter: BufferedWriter? = <span class=\"keyword\">null</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            socket = Socket(host, <span class=\"number\">80</span>)</span><br><span class=\"line\">            streamWriter = OutputStreamWriter(socket.getOutputStream())</span><br><span class=\"line\">            bufferedWriter = BufferedWriter(streamWriter)</span><br><span class=\"line\">            bufferedWriter.write(<span class=\"string\">&quot;GET $path HTTP/1.1\\r\\n&quot;</span>)</span><br><span class=\"line\">            bufferedWriter.write(<span class=\"string\">&quot;Host: www.baidu.com\\r\\n&quot;</span>)</span><br><span class=\"line\">            bufferedWriter.write(<span class=\"string\">&quot;\\r\\n&quot;</span>)</span><br><span class=\"line\">            bufferedWriter.flush()</span><br><span class=\"line\">            val myRequest = BufferedReader(InputStreamReader(socket.getInputStream(), <span class=\"string\">&quot;UTF-8&quot;</span>))</span><br><span class=\"line\">            <span class=\"keyword\">var</span> d = -<span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (myRequest.read().also(&#123; d = it &#125;) != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                print(d.toChar())</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (e: IOException) &#123;</span><br><span class=\"line\">            e.printStackTrace()</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"整体流程\">整体流程<a title=\"#整体流程\" href=\"#整体流程\"></a></h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GetExample</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 核网络管理者 - 核心类</span></span><br><span class=\"line\">  <span class=\"keyword\">final</span> OkHttpClient client = <span class=\"keyword\">new</span> OkHttpClient();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\">String <span class=\"title\">run</span><span class=\"params\">(String url)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 请求搭建</span></span><br><span class=\"line\">    Request request = <span class=\"keyword\">new</span> Request.Builder().url(url).build();</span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">      阻塞式execute -&gt; 立即调用请求，并阻塞，直到响应可以处理或出现错误</span></span><br><span class=\"line\"><span class=\"comment\">      为了避免资源泄漏，调用者应该关闭Response，而Response又会关闭底层的ResponseBody。 //确保响应(和底层响应体)是关闭的</span></span><br><span class=\"line\"><span class=\"comment\">      注意，传输层的成功(接收HTTP响应代码、报头和正文)不一定表示应用层的成功:响应可能仍然表示不满意的HTTP响应代码，如404或500。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span> (Response response = client.newCall(request).execute()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> response.body().string();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    GetExample example = <span class=\"keyword\">new</span> GetExample();</span><br><span class=\"line\">    String response = example.run(<span class=\"string\">&quot;https://raw.github.com/square/okhttp/master/README.md&quot;</span>);</span><br><span class=\"line\">    System.out.println(response);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><img src=\"https://z3.ax1x.com/2021/10/25/5hiy4O.png\" alt=\"5hiy4O.png\" loading=\"lazy\" class=\"φbp\"></p>\n<h3 id=\"连接建立\">连接建立<a title=\"#连接建立\" href=\"#连接建立\"></a></h3>\n<p>Volley等很多网络请求框架很多底层都是通过 HTTPURLConnection 来与服务端建立连接的，而 OkHttp 就比较优秀了。因为 HTTP 协议是建立在 TCP/IP 协议基础之上的，底层还是走的 Socket，所以OkHttp 直接使用 Socket 来完成 HTTP 请求。</p>\n<h3 id=\"okhttpclient\">OkHttpClient<a title=\"#okhttpclient\" href=\"#okhttpclient\"></a></h3>\n<p>官方推荐我们使用单例去创建OkHttpClient，重用所有HTTP调用的时候，性能是最佳的， 这是因为每个客户端都拥有自己的连接池和线程池。 重用连接和线程可减少延迟并节省内存。 相反，为每个请求创建一个客户端会浪费空闲池上的资源</p>\n<h3 id=\"request\">Request<a title=\"#request\" href=\"#request\"></a></h3>\n<p>采用Builder的方式进行设计，主要包含了url、method、headers、body和CacheControl组成的各种配置项</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> Dispatcher dispatcher;  <span class=\"comment\">//分发器</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> Proxy proxy;  <span class=\"comment\">//代理</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> List&lt;Protocol&gt; protocols; <span class=\"comment\">//协议</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> List&lt;ConnectionSpec&gt; connectionSpecs; <span class=\"comment\">//传输层版本和连接协议</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> List&lt;Interceptor&gt; interceptors; <span class=\"comment\">//拦截器</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> List&lt;Interceptor&gt; networkInterceptors; <span class=\"comment\">//网络拦截器</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> ProxySelector proxySelector; <span class=\"comment\">//代理选择</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> CookieJar cookieJar; <span class=\"comment\">//cookie</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> Cache cache; <span class=\"comment\">//缓存</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> InternalCache internalCache;  <span class=\"comment\">//内部缓存</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> SocketFactory socketFactory;  <span class=\"comment\">//socket 工厂</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> SSLSocketFactory sslSocketFactory; <span class=\"comment\">//安全套接层socket 工厂，用于HTTPS</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> CertificateChainCleaner certificateChainCleaner; <span class=\"comment\">// 验证确认响应证书 适用 HTTPS 请求连接的主机名。</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> HostnameVerifier hostnameVerifier;    <span class=\"comment\">//  主机名字确认</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> CertificatePinner certificatePinner;  <span class=\"comment\">//  证书链</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> Authenticator proxyAuthenticator;     <span class=\"comment\">//代理身份验证</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> Authenticator authenticator;      <span class=\"comment\">// 本地身份验证</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> ConnectionPool connectionPool;    <span class=\"comment\">//连接池,复用连接</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> Dns dns;  <span class=\"comment\">//域名</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> followSslRedirects;  <span class=\"comment\">//安全套接层重定向</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> followRedirects;  <span class=\"comment\">//本地重定向</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> retryOnConnectionFailure; <span class=\"comment\">//重试连接失败</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> connectTimeout;    <span class=\"comment\">//连接超时</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> readTimeout; <span class=\"comment\">//read 超时</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> writeTimeout; <span class=\"comment\">//write 超时 </span></span><br></pre></td></tr></table></figure>\n<h3 id=\"call\">Call<a title=\"#call\" href=\"#call\"></a></h3>\n<blockquote>\n<p>一个提供 HTTP 请求执行相关接口的接口类，具体的实现类是 RealCall</p>\n</blockquote>\n<ul>\n<li>可以取消</li>\n<li>此对象表示单个请求/响应对(流),因此不能执行两次</li>\n</ul>\n<h4 id=\"realcall\">RealCall<a title=\"#realcall\" href=\"#realcall\"></a></h4>\n<blockquote>\n<p>OkHttp的应用层和网络层之间的桥梁,包含了网络的连接、请求、响应和流处理整个流程,也是OkHttp中最关键核心的类</p>\n</blockquote>\n<h5 id=\"asynctimeout\">AsyncTimeout<a title=\"#asynctimeout\" href=\"#asynctimeout\"></a></h5>\n<p>此超时用在在后台线程执行超时时执行操作。 使用它来实现本地不支持的超时，例如写入时被阻止的套接字,子类应该覆盖timedOut以在发生超时时采取行动。 此方法将由共享看门狗线程调用，因此不应执行任何长时间运行的操作。 否则，我们可能会面临触发其他超时的风险。<br>\n使用sink和source将此超时应用于流。 返回的值将超时应用于包装流上的每个操作。<br>\n调用者应该在执行可能超时的工作之前调用enter ，然后退出。 exit的返回值表示是否触发了超时。 请注意，对timedOut的调用是异步的，可以在exit之后调用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> val timeout = object : AsyncTimeout() &#123;  </span><br><span class=\"line\">  <span class=\"function\">override fun <span class=\"title\">timedOut</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"comment\">// 取消请求  </span></span><br><span class=\"line\">  cancel()  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;.apply &#123;  </span><br><span class=\"line\">  timeout(client.callTimeoutMillis.toLong(), MILLISECONDS)  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"execute\">execute<a title=\"#execute\" href=\"#execute\"></a></h5>\n<blockquote>\n<p>同步请求,  马上执行并阻塞直到可以处理响应或出现错误</p>\n</blockquote>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">execute</span><span class=\"params\">()</span></span>: Response &#123;</span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * Atomic就是原子性的意思，源码里用了Volatile属性，即能够保证在高并发的情况下只有一个线程能够访问这个属性值</span></span><br><span class=\"line\"><span class=\"comment\">   * executed 是一个原子变量，一般情况下，我们使用 AtomicBoolean 高效并发处理 “只初始化一次” 的功能要求,用 compareAndSet(false, true)</span></span><br><span class=\"line\"><span class=\"comment\">   * 判断多线程状态下，请求是否重新执行：如果值为false，则抛出一个IllegalStateException，并返回调用lazyMessage的结果。</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  check(executed.compareAndSet(<span class=\"literal\">false</span>, <span class=\"literal\">true</span>)) &#123; <span class=\"string\">&quot;Already Executed&quot;</span> &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 超时计数开始</span></span><br><span class=\"line\">  timeout.enter()</span><br><span class=\"line\">  <span class=\"comment\">// 执行请求前处理 -&gt; 栈跟踪，事件回调等等</span></span><br><span class=\"line\">  callStart()</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 调度器开始执行</span></span><br><span class=\"line\">    client.dispatcher.executed(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">    <span class=\"comment\">// 返回拦截器处理下的响应</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> getResponseWithInterceptorChain()</span><br><span class=\"line\">  &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 调度器返回完成信号</span></span><br><span class=\"line\">    client.dispatcher.finished(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"enqueue\">enqueue<a title=\"#enqueue\" href=\"#enqueue\"></a></h5>\n<blockquote>\n<p>异步调度,  将请求放到队列中等到执行</p>\n</blockquote>\n<p>RealCall.kt</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">enqueue</span><span class=\"params\">(responseCallback: <span class=\"type\">Callback</span>)</span></span> &#123;  </span><br><span class=\"line\">  <span class=\"comment\">// 首先判断当前请求是否已执行，如果已经执行则打印日志，并抛出 IllegalStateException 异常</span></span><br><span class=\"line\">  check(executed.compareAndSet(<span class=\"literal\">false</span>, <span class=\"literal\">true</span>)) &#123; <span class=\"string\">&quot;Already Executed&quot;</span> &#125;  </span><br><span class=\"line\">  callStart()  </span><br><span class=\"line\">  <span class=\"comment\">// 创建一个AsyncCall对象,放进分发器队列中</span></span><br><span class=\"line\">  client.dispatcher.enqueue(AsyncCall(responseCallback))  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">callStart</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 返回一个对象，该对象包含在执行此方法时创建的堆栈跟踪</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.callStackTrace = Platform.<span class=\"keyword\">get</span>().getStackTraceForCloseable(<span class=\"string\">&quot;response.body().close()&quot;</span>)</span><br><span class=\"line\">    eventListener.callStart(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Dispatcher.kt</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">///////////////////////////////////////////////////////////////////////////</span></span><br><span class=\"line\"><span class=\"comment\">// https://zhuanlan.zhihu.com/p/261397170</span></span><br><span class=\"line\"><span class=\"comment\">// ArrayDeque -  Java 集合中双端队列的数组实现</span></span><br><span class=\"line\"><span class=\"comment\">// ArrayDeque 几乎没有容量限制，设计为线程不安全的，禁止 null 元素</span></span><br><span class=\"line\"><span class=\"comment\">// ArrayDeque是Deque的实现类，可以作为栈来使用，效率高于Stack；也可以作为队列来使用，效率高于LinkedList。</span></span><br><span class=\"line\"><span class=\"comment\">// ArrayDeque 大多数的额操作都在固定时间内运行，例外情况包括 remove，removeFirstOccurrence，removeLastOccurrence，contains，iterator.remove()，和批量操作，这些将以线性时间运行</span></span><br><span class=\"line\"><span class=\"comment\">///////////////////////////////////////////////////////////////////////////</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">val</span> runningSyncCalls = ArrayDeque&lt;RealCall&gt;()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">internal</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">enqueue</span><span class=\"params\">(call: <span class=\"type\">AsyncCall</span>)</span></span> &#123;</span><br><span class=\"line\">  synchronized(<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 将请求 AsyncCall 添加到待执行队列</span></span><br><span class=\"line\">    readyAsyncCalls.add(call)</span><br><span class=\"line\">    <span class=\"comment\">// 判断当前请求是否已存在可复用的 hos</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!call.call.forWebSocket) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">val</span> existingCall = findExistingCallWithHost(call.host)</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (existingCall != <span class=\"literal\">null</span>) call.reuseCallsPerHostFrom(existingCall)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 将符合条件的Call从readyAsyncCalls 提升到runningAsyncCalls并在执行它们</span></span><br><span class=\"line\">  promoteAndExecute()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>RealCall.AsyncCall</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">run</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 给当前AsyncCall异步线程设置名称</span></span><br><span class=\"line\">    threadName(<span class=\"string\">&quot;OkHttp <span class=\"subst\">$&#123;redactedUrl()&#125;</span>&quot;</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> signalledCallback = <span class=\"literal\">false</span></span><br><span class=\"line\">      timeout.enter()</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 获取请求结果</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> response = getResponseWithInterceptorChain()</span><br><span class=\"line\">        signalledCallback = <span class=\"literal\">true</span></span><br><span class=\"line\">        <span class=\"comment\">// 触发相应回调</span></span><br><span class=\"line\">        responseCallback.onResponse(<span class=\"keyword\">this</span><span class=\"symbol\">@RealCall</span>, response)</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (e: IOException) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (signalledCallback) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// Do not signal the callback twice!</span></span><br><span class=\"line\">          Platform.<span class=\"keyword\">get</span>().log(<span class=\"string\">&quot;Callback failure for <span class=\"subst\">$&#123;toLoggableString()&#125;</span>&quot;</span>, Platform.INFO, e)</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          responseCallback.onFailure(<span class=\"keyword\">this</span><span class=\"symbol\">@RealCall</span>, e)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (t: Throwable) &#123;</span><br><span class=\"line\">        cancel()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!signalledCallback) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">val</span> canceledException = IOException(<span class=\"string\">&quot;canceled due to <span class=\"variable\">$t</span>&quot;</span>)</span><br><span class=\"line\">          canceledException.addSuppressed(t)</span><br><span class=\"line\">          responseCallback.onFailure(<span class=\"keyword\">this</span><span class=\"symbol\">@RealCall</span>, canceledException)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> t</span><br><span class=\"line\">      &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 关闭请求</span></span><br><span class=\"line\">        client.dispatcher.finished(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"dispatcher(分发器)\">Dispatcher(分发器)<a title=\"#dispatcher(分发器)\" href=\"#dispatcher(分发器)\"></a></h3>\n<blockquote>\n<p>用于管理其对应 OkHttpClient 的所有请求,对Call进行统一的控制，例如结束所有请求、获取线程池等等</p>\n</blockquote>\n<ul>\n<li>readyAsyncCalls：一个新的异步请求首先会被加入该队列中</li>\n<li>runningAsyncCalls：当前正在运行中的异步请求</li>\n<li>runningSyncCalls：当前正在运行的同步请求</li>\n</ul>\n<p>异步请求跟同步请求一样,最终都会调用到<code>getResponseWithInterceptorChain()</code></p>\n<h3 id=\"interceptor(拦截器)\">Interceptor(拦截器)<a title=\"#interceptor(拦截器)\" href=\"#interceptor(拦截器)\"></a></h3>\n<blockquote>\n<p>Interceptor 接口作为一个拦截器的抽象概念，被设计为责任链上的单位节点，用于观察、拦截、处理请求等，例如添加 Header、重定向、数据处理等等。<br>\nInterceptor 之间互相独立，每个 Interceptor 只负责自己关注的任务，不与其他 Interceptor 接触。</p>\n</blockquote>\n<p>RealCall.kt</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Throws(IOException::class)</span></span><br><span class=\"line\"><span class=\"keyword\">internal</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getResponseWithInterceptorChain</span><span class=\"params\">()</span></span>: Response &#123;</span><br><span class=\"line\">  <span class=\"comment\">// <span class=\"doctag\">TODO:</span> 2021/8/13 okhttp的核心是拦截器，而拦截器所采用的设计模式是责任链设计，即每个拦截器只处理与自己相关的业务逻辑 https://zhuanlan.zhihu.com/p/340090732</span></span><br><span class=\"line\">  <span class=\"comment\">// 构建整个网络请求拦截</span></span><br><span class=\"line\">  <span class=\"keyword\">val</span> interceptors = mutableListOf&lt;Interceptor&gt;()</span><br><span class=\"line\">  <span class=\"comment\">// 添加Client的拦截器</span></span><br><span class=\"line\">  interceptors += client.interceptors</span><br><span class=\"line\">  <span class=\"comment\">// 添加失败重连的拦截器</span></span><br><span class=\"line\">  interceptors += RetryAndFollowUpInterceptor(client)</span><br><span class=\"line\">  <span class=\"comment\">// 添加请求桥梁拦截器 - 在对用户的请求头部加了一些信息，然后在获取到的响应中也做了一些处理。而这些处理对用户是透明的，减少了客户请求的工作</span></span><br><span class=\"line\">  interceptors += BridgeInterceptor(client.cookieJar)</span><br><span class=\"line\">  <span class=\"comment\">// 添加缓存拦截器 - 理来自缓存的请求并将响应写入缓存。</span></span><br><span class=\"line\">  interceptors += CacheInterceptor(client.cache)</span><br><span class=\"line\">  <span class=\"comment\">// 添加请求中拦截器 - 打开与目标服务器的连接并继续下一个拦截器。 网络可能用于返回的响应，或使用条件 GET 验证缓存的响应</span></span><br><span class=\"line\">  interceptors += ConnectInterceptor</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!forWebSocket) &#123;</span><br><span class=\"line\">    interceptors += client.networkInterceptors</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 这是链中的最后一个拦截器。 它对服务器进行网络调用,真正的网络请求从这里开始</span></span><br><span class=\"line\">  interceptors += CallServerInterceptor(forWebSocket)</span><br><span class=\"line\">  <span class=\"comment\">// 构建网络请求链 - 一个具体的拦截器链，承载着整个拦截器链：所有应用程序拦截器、OkHttp核心、所有网络拦截器，最后是网络调用者。</span></span><br><span class=\"line\">  <span class=\"keyword\">val</span> chain = RealInterceptorChain(</span><br><span class=\"line\">      call = <span class=\"keyword\">this</span>,</span><br><span class=\"line\">      interceptors = interceptors,</span><br><span class=\"line\">      index = <span class=\"number\">0</span>,</span><br><span class=\"line\">      exchange = <span class=\"literal\">null</span>,</span><br><span class=\"line\">      request = originalRequest,</span><br><span class=\"line\">      connectTimeoutMillis = client.connectTimeoutMillis,</span><br><span class=\"line\">      readTimeoutMillis = client.readTimeoutMillis,</span><br><span class=\"line\">      writeTimeoutMillis = client.writeTimeoutMillis</span><br><span class=\"line\">  )</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> calledNoMoreExchanges = <span class=\"literal\">false</span></span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> response = chain.proceed(originalRequest)</span><br><span class=\"line\">    <span class=\"comment\">// 是否取消请求</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isCanceled()) &#123;</span><br><span class=\"line\">      response.closeQuietly()</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> IOException(<span class=\"string\">&quot;Canceled&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> response</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (e: IOException) &#123;</span><br><span class=\"line\">    calledNoMoreExchanges = <span class=\"literal\">true</span></span><br><span class=\"line\">    <span class=\"keyword\">throw</span> noMoreExchanges(e) <span class=\"keyword\">as</span> Throwable</span><br><span class=\"line\">  &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!calledNoMoreExchanges) &#123;</span><br><span class=\"line\">      noMoreExchanges(<span class=\"literal\">null</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>RealInterceptorChain.kt</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Throws(IOException::class)</span></span><br><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">proceed</span><span class=\"params\">(request: <span class=\"type\">Request</span>)</span></span>: Response &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 判断拦截器是否为空</span></span><br><span class=\"line\">  check(index &lt; interceptors.size)</span><br><span class=\"line\">  <span class=\"comment\">// 请求数加1</span></span><br><span class=\"line\">  calls++</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (exchange != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    check(exchange.finder.sameHostAndPort(request.url)) &#123;</span><br><span class=\"line\">      <span class=\"string\">&quot;network interceptor <span class=\"subst\">$&#123;interceptors[index - <span class=\"number\">1</span>]&#125;</span> must retain the same host and port&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    check(calls == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">      <span class=\"string\">&quot;network interceptor <span class=\"subst\">$&#123;interceptors[index - <span class=\"number\">1</span>]&#125;</span> must call proceed() exactly once&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// Call the next interceptor in the chain. 调用链中的下一个拦截器</span></span><br><span class=\"line\">  <span class=\"keyword\">val</span> next = copy(index = index + <span class=\"number\">1</span>, request = request)</span><br><span class=\"line\">  <span class=\"comment\">// 获取当前的拦截器</span></span><br><span class=\"line\">  <span class=\"keyword\">val</span> interceptor = interceptors[index]</span><br><span class=\"line\">  <span class=\"comment\">// 开始一个个的执行每一个拦截器，每个拦截器的intercept都会调到 当前类的proceed ，直至最后一个CallServerInterceptor执行完</span></span><br><span class=\"line\">  <span class=\"meta\">@Suppress(<span class=\"meta-string\">&quot;USELESS_ELVIS&quot;</span>)</span></span><br><span class=\"line\">  <span class=\"keyword\">val</span> response = interceptor.intercept(next) ?: <span class=\"keyword\">throw</span> NullPointerException(<span class=\"string\">&quot;interceptor <span class=\"variable\">$interceptor</span> returned null&quot;</span>)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (exchange != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    check(index + <span class=\"number\">1</span> &gt;= interceptors.size || next.calls == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">      <span class=\"string\">&quot;network interceptor <span class=\"variable\">$interceptor</span> must call proceed() exactly once&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  check(response.body != <span class=\"literal\">null</span>) &#123; <span class=\"string\">&quot;interceptor <span class=\"variable\">$interceptor</span> returned a response with no body&quot;</span> &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> response</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"chain\">Chain<a title=\"#chain\" href=\"#chain\"></a></h4>\n<blockquote>\n<p>Interceptor 与 Chain 彼此互相依赖，互相调用，共同发展，形成了一个完美的调用链</p>\n</blockquote>\n<p>Chain 被用来描述责任链，通过其中的 process 方法开始依次执行链上的每个节点，并返回处理后的 Response。<br>\nChain 的唯一实现为 RealInterceptorChain（下文简称 RIC），RIC 可以称之为<strong>拦截器责任链</strong>，其中的节点由 RealCall 中添加进来的 Interceptor 们组成。由于 Interceptor 的互相独立性，RIC 中还会包含一些公共参数及共享的对象。</p>\n<p><img src=\"https://z3.ax1x.com/2021/10/25/5hbpJx.png\" alt=\"5hbpJx.png\" loading=\"lazy\" class=\"φbp\"></p>\n<h3 id=\"about\">About<a title=\"#about\" href=\"#about\"></a></h3>\n<p><a href=\"https://zhuanlan.zhihu.com/p/116777864\" target=\"_blank\">OkHttp源码深度解析</a><br>\n<a href=\"https://zhuanlan.zhihu.com/p/104813091\" target=\"_blank\">OkHttp源码解析</a><br>\n<a href=\"https://juejin.cn/post/7020027832977850381\" target=\"_blank\">OkHttp源码原理</a></p>\n","prev":{"title":"源码学习-Glide","link":"2021/10/31/15jfHwStpctgCeeA"},"next":{"title":"安卓优化-布局优化","link":"2021/10/31/5FIszA6Ut2OHE8Sg"},"plink":"https://onion99.github.io/2021/10/31/4SVquTFcR8Wyv4GV/","reward":true,"copyright":{"custom":"Copyright:自由转载-非商用-禁止演绎-保持署名（CC BY-NC-ND 4.0）"}}