{
    "version": "https://jsonfeed.org/version/1",
    "title": "Stay hungry , Stay foolish • All posts by \"黑科技\" tag",
    "description": "巴拉巴拉",
    "home_page_url": "https://onion99.github.io",
    "items": [
        {
            "id": "https://onion99.github.io/2022/03/08/yriIudTcpjYyMHli/",
            "url": "https://onion99.github.io/2022/03/08/yriIudTcpjYyMHli/",
            "title": "Android黑科技 - 插件化",
            "date_published": "2022-03-07T22:46:11.000Z",
            "content_html": "<p>插件化技术最初源于免安装运行apk的想法，这个免安装的apk可以理解为插件。支持插件化的app可以在运行时加载和运行插件，这样便可以将app中一些不常用的功能模块做成插件，一方面减小了安装包的大小，另一方面可以实现app功能的动态扩展。</p>\n<p>想要实现插件化，主要是解决下面三个问题：</p>\n<ul>\n<li>插件中代码的加载和与主工程的互相调用</li>\n<li>插件中资源的加载和与主工程的互相访问</li>\n<li>四大组件生命周期的管理</li>\n</ul>\n<span id=\"more\"></span>\n<h3 id=\"插件化发展\">插件化发展<a title=\"#插件化发展\" href=\"#插件化发展\"></a></h3>\n<p><img src=\"https://s1.ax1x.com/2022/03/07/byn21s.png\" alt=\"byn21s.png\" loading=\"lazy\" class=\"φbp\"></p>\n<p><strong>第一代</strong>：dynamic-load-apk最早使用ProxyActivity这种静态代理技术，由ProxyActivity去控制插件中PluginActivity的生命周期。该种方式缺点明显，插件中的activity必须继承PluginActivity，开发时要小心处理context。而DroidPlugin通过Hook系统服务的方式启动插件中的Activity，使得开发插件的过程和开发普通的app没有什么区别，但是由于hook过多系统服务，异常复杂且不够稳定。</p>\n<p><strong>第二代</strong>：为了同时达到插件开发的低侵入性（像开发普通app一样开发插件）和框架的稳定性，在实现原理上都是趋近于选择尽量少的hook，并通过在manifest中预埋一些组件实现对四大组件的插件化。另外各个框架根据其设计思想都做了不同程度的扩展，其中Small更是做成了一个跨平台，组件化的开发框架。</p>\n<p><strong>第三代</strong>：VirtualApp比较厉害，能够完全模拟app的运行环境，能够实现app的免安装运行和双开技术。Atlas是阿里今年开源出来的一个结合组件化和热修复技术的一个app基础框架，其广泛的应用与阿里系的各个app，其号称是一个容器化框架</p>\n<h3 id=\"插件化方案\">插件化方案<a title=\"#插件化方案\" href=\"#插件化方案\"></a></h3>\n<h4 id=\"静态方案-通过proxyactivity统一加载插件中的所有activity，以that框架为代表\">静态方案-通过ProxyActivity统一加载插件中的所有Activity，以that框架为代表<a title=\"#静态方案-通过proxyactivity统一加载插件中的所有activity，以that框架为代表\" href=\"#静态方案-通过proxyactivity统一加载插件中的所有activity，以that框架为代表\"></a></h4>\n<blockquote>\n<p>ProxyActivity代理的方式最早是由dynamic-load-apk提出的，其思想很简单，在主工程中放一个ProxyActivy，启动插件中的Activity时会先启动ProxyActivity，在ProxyActivity中创建插件Activity，并同步生命周期</p>\n</blockquote>\n<p><img src=\"https://s1.ax1x.com/2022/03/07/byKLex.png\" alt=\"byKLex.png\" loading=\"lazy\" class=\"φbp\"></p>\n<h5 id=\"流程:\">流程:<a title=\"#流程:\" href=\"#流程:\"></a></h5>\n<ol>\n<li>首先需要通过统一的入口（如图中的PluginManager）启动插件Activity，其内部会将启动的插件Activity信息保存下来，并将intent替换为启动ProxyActivity的intent。</li>\n<li>ProxyActivity根据插件的信息拿到该插件的ClassLoader和Resource，通过反射创建PluginActivity并调用其onCreate方法。</li>\n<li>PluginActivty调用的setContentView被重写了，会去调用ProxyActivty的setContentView。由于ProxyActivity重写了getResource返回的是插件的Resource，所以setContentView能够访问到插件中的资源。同样findViewById也是调用ProxyActivity的。</li>\n<li>ProxyActivity中的其他生命周期回调函数中调用相应PluginActivity的生命周期</li>\n</ol>\n<h5 id=\"实现\">实现<a title=\"#实现\" href=\"#实现\"></a></h5>\n<p>模拟Activty基本实现:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ProxyActivityInterface</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//生命周期的activity</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">attach</span><span class=\"params\">(Activity proxyActivity)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onStart</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onResume</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onPause</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onStop</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onDestroy</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onSaveInstanceState</span><span class=\"params\">(Bundle outState)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onTouchEvent</span><span class=\"params\">(MotionEvent event)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onBackPressed</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>插件BaseActivty类:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这是插件的基类，所有的activity都要继承这个类，</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BaseActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">Activity</span> <span class=\"keyword\">implements</span> <span class=\"title\">ProxyActivityInterface</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> Activity that;<span class=\"comment\">//这里的that 指的是我们的宿主app，因为插件是没有安装的 是没有上下文的</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">attach</span><span class=\"params\">(Activity proxyActivity)</span> </span>&#123;</span><br><span class=\"line\">        that = proxyActivity;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setContentView</span><span class=\"params\">(View view)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//可以看到,最终调用主App(宿主)的activity 函数</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (that != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            that.setContentView(view);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">super</span>.setContentView(view);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setContentView</span><span class=\"params\">(<span class=\"keyword\">int</span> layoutResID)</span> </span>&#123;</span><br><span class=\"line\">        that.setContentView(layoutResID);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> View <span class=\"title\">findViewById</span><span class=\"params\">(<span class=\"keyword\">int</span> id)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> that.findViewById(id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Intent <span class=\"title\">getIntent</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (that != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> that.getIntent();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.getIntent();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ClassLoader <span class=\"title\">getClassLoader</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> that.getClassLoader();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@NonNull</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> LayoutInflater <span class=\"title\">getLayoutInflater</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> that.getLayoutInflater();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ApplicationInfo <span class=\"title\">getApplicationInfo</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> that.getApplicationInfo();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Window <span class=\"title\">getWindow</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> that.getWindow();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> WindowManager <span class=\"title\">getWindowManager</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> that.getWindowManager();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">startActivity</span><span class=\"params\">(Intent intent)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//        ProxyActivity ---&gt;className</span></span><br><span class=\"line\">        Intent m = <span class=\"keyword\">new</span> Intent();</span><br><span class=\"line\">        m.putExtra(<span class=\"string\">&quot;ClassName&quot;</span>, intent.getComponent().getClassName());</span><br><span class=\"line\">        that.startActivity(m);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onStart</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onResume</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onPause</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onStop</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onDestroy</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onSaveInstanceState</span><span class=\"params\">(Bundle outState)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n<p>插件ProxyActivity(): 主要通过这个去 New 一个Activity 来模拟原生Activity管理</p>\n<blockquote>\n<p>插件内部的跳转其实也就是在开同一个activity</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProxyActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">AppCompatActivity</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> ProxyActivityInterface pluginObj;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\">        <span class=\"comment\">//在这里拿到了真实跳转的activity 拿出来 再去启动真实的activity</span></span><br><span class=\"line\"></span><br><span class=\"line\">        String className = getIntent().getStringExtra(<span class=\"string\">&quot;ClassName&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//通过反射在去启动一个真实的activity 拿到Class对象</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Class&lt;?&gt; plugClass = getClassLoader().loadClass(className);</span><br><span class=\"line\">            Constructor&lt;?&gt; pluginConstructor = plugClass.getConstructor(<span class=\"keyword\">new</span> Class[]&#123;&#125;);</span><br><span class=\"line\">            <span class=\"comment\">//因为插件的activity实现了我们的标准</span></span><br><span class=\"line\">            pluginObj = (ProxyActivityInterface) pluginConstructor.newInstance(<span class=\"keyword\">new</span> Object[]&#123;&#125;);</span><br><span class=\"line\">            pluginObj.attach(<span class=\"keyword\">this</span>);<span class=\"comment\">//注入上下文</span></span><br><span class=\"line\">            pluginObj.onCreate(<span class=\"keyword\">new</span> Bundle());<span class=\"comment\">//一定要调用onCreate </span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (e.getClass().getSimpleName() .equals(<span class=\"string\">&quot;ClassCastException&quot;</span>))&#123;</span><br><span class=\"line\">                <span class=\"comment\">//我这里是直接拿到异常判断的 ，也可的 拿到上面的plugClass对象判断有没有实现我们的接口</span></span><br><span class=\"line\">                finish();</span><br><span class=\"line\">                Toast.makeText(<span class=\"keyword\">this</span>,<span class=\"string\">&quot;非法页面&quot;</span>,Toast.LENGTH_LONG).show();</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">]</span><br><span class=\"line\">    <span class=\"comment\">//为什么要重写这个呢 因为这个是插件内部startactivity调用的 将真正要开启的activity的类名穿过来</span></span><br><span class=\"line\">    <span class=\"comment\">//然后取出来，启动我们的占坑的activity 在我们真正要启动的赛进去</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">startActivity</span><span class=\"params\">(Intent intent)</span> </span>&#123;</span><br><span class=\"line\">        String className1=intent.getStringExtra(<span class=\"string\">&quot;ClassName&quot;</span>);</span><br><span class=\"line\">        Intent intent1 = <span class=\"keyword\">new</span> Intent(<span class=\"keyword\">this</span>, ProxyActivity.class);</span><br><span class=\"line\">        intent1.putExtra(<span class=\"string\">&quot;ClassName&quot;</span>, className1);</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.startActivity(intent1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//重写classLoader</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ClassLoader <span class=\"title\">getClassLoader</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> HookManager.getInstance().getClassLoader();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//重写Resource</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Resources <span class=\"title\">getResources</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> HookManager.getInstance().getResource();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onStart</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onStart();</span><br><span class=\"line\">        pluginObj.onStart();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onDestroy</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onDestroy();</span><br><span class=\"line\">        pluginObj.onDestroy();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onPause</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onPause();</span><br><span class=\"line\">        pluginObj.onPause();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>插件apk和资源加载处理-Hookmanager:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HookManager</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> HookManager ourInstance = <span class=\"keyword\">new</span> HookManager();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Resources resources;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> DexClassLoader loader;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> PackageInfo packageInfo;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> HookManager <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ourInstance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">HookManager</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 复制插件到缓存目录,方便加载</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">loadPlugin</span><span class=\"params\">(Activity activity)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 假如这里是从网络获取的插件 我们直接从sd卡获取 然后读取到我们的cache目录</span></span><br><span class=\"line\">        String pluginName = <span class=\"string\">&quot;plugin.apk&quot;</span>;</span><br><span class=\"line\">        File filesDir = activity.getDir(<span class=\"string\">&quot;plugin&quot;</span>, activity.MODE_PRIVATE);</span><br><span class=\"line\">        String filePath = <span class=\"keyword\">new</span> File(filesDir, pluginName).getAbsolutePath();</span><br><span class=\"line\">        File file = <span class=\"keyword\">new</span> File(filePath);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (file.exists()) &#123;</span><br><span class=\"line\">            file.delete();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        FileInputStream is = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        FileOutputStream os = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"comment\">//读取的目录</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            is = <span class=\"keyword\">new</span> FileInputStream(<span class=\"keyword\">new</span> File(Environment.getExternalStorageDirectory(), pluginName));</span><br><span class=\"line\">            <span class=\"comment\">//要输入的目录</span></span><br><span class=\"line\">            os = <span class=\"keyword\">new</span> FileOutputStream(filePath);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (FileNotFoundException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> len = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">byte</span>[] buffer = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">1024</span>];</span><br><span class=\"line\">            <span class=\"keyword\">while</span> ((len = is.read(buffer)) != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                os.write(buffer, <span class=\"number\">0</span>, len);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            File f = <span class=\"keyword\">new</span> File(filePath);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (f.exists()) &#123;</span><br><span class=\"line\">                Toast.makeText(activity, <span class=\"string\">&quot;dex overwrite&quot;</span>, Toast.LENGTH_SHORT).show();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            loadPathToPlugin(activity);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// TODO Auto-generated catch block</span></span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                os.close();</span><br><span class=\"line\">                is.close();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// TODO Auto-generated catch block</span></span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">loadPathToPlugin</span><span class=\"params\">(Activity activity)</span> </span>&#123;</span><br><span class=\"line\">        File filesDir = activity.getDir(<span class=\"string\">&quot;plugin&quot;</span>, activity.MODE_PRIVATE);</span><br><span class=\"line\">        String name = <span class=\"string\">&quot;plugin.apk&quot;</span>;</span><br><span class=\"line\">        String path = <span class=\"keyword\">new</span> File(filesDir, name).getAbsolutePath();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//然后我们开始加载我们的apk 使用DexClassLoader</span></span><br><span class=\"line\">        File dexOutDir = activity.getDir(<span class=\"string\">&quot;dex&quot;</span>, activity.MODE_PRIVATE);</span><br><span class=\"line\">        loader = <span class=\"keyword\">new</span> DexClassLoader(path, dexOutDir.getAbsolutePath(), <span class=\"keyword\">null</span>, activity.getClassLoader());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//通过PackAgemanager 来获取插件的第一个activity是哪一个</span></span><br><span class=\"line\">        PackageManager packageManager = activity.getPackageManager();</span><br><span class=\"line\">        packageInfo = packageManager.getPackageArchiveInfo(path, PackageManager.GET_ACTIVITIES);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//然后开始加载我们的资源 肯定要使用Resource 但是它是AssetManager创建出来的 就是AssertManager 有一个addAssertPath 这个方法 但是私有的 所有使用反射</span></span><br><span class=\"line\">        Class&lt;?&gt; assetManagerClass = AssetManager.class;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            AssetManager assertManagerObj = (AssetManager) assetManagerClass.newInstance();</span><br><span class=\"line\">            Method addAssetPathMethod = assetManagerClass.getMethod(<span class=\"string\">&quot;addAssetPath&quot;</span>, String.class);</span><br><span class=\"line\">            addAssetPathMethod.setAccessible(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">            addAssetPathMethod.invoke(assertManagerObj, path);</span><br><span class=\"line\">            <span class=\"comment\">//在创建一个Resource</span></span><br><span class=\"line\">            resources = <span class=\"keyword\">new</span> Resources(assertManagerObj, activity.getResources().getDisplayMetrics(), activity.getResources().getConfiguration());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//对外提供插件的classLoader</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ClassLoader <span class=\"title\">getClassLoader</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> loader;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//插件中的Resource</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Resources <span class=\"title\">getResource</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> resources;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在主App可以实现插件化功能了</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 加载对应插件</span></span><br><span class=\"line\">HookManager.getInstance().loadPlugin(<span class=\"keyword\">this</span>)</span><br><span class=\"line\"><span class=\"comment\">// 通过跳到ProxyActivity 来模拟实现对应插件Activity</span></span><br><span class=\"line\">Intent intent = <span class=\"keyword\">new</span> Intent(<span class=\"keyword\">this</span>, ProxyActivity.class);<span class=\"comment\">//这里就是一个占坑的activity</span></span><br><span class=\"line\"><span class=\"comment\">//这里是拿到我们加载的插件的第一个activity的全类名</span></span><br><span class=\"line\">intent.putExtra(<span class=\"string\">&quot;ClassName&quot;</span>,HookManager.getInstance().packageInfo.activities[<span class=\"number\">0</span>].name);</span><br><span class=\"line\">startActivity(intent);</span><br></pre></td></tr></table></figure>\n<p>通过这种代理模拟方式也可以实现 Service、BroadcastReceiver、ContentProvider组件的代理</p>\n<h5 id=\"问题\">问题<a title=\"#问题\" href=\"#问题\"></a></h5>\n<p>注意事项：</p>\n<ul>\n<li>ProxyActivity中需要重写getResouces，getAssets，getClassLoader方法返回插件的相应对象。生命周期函数以及和用户交互相关函数，如onResume，onStop，onBackPressedon，KeyUponWindow，FocusChanged等需要转发给插件。</li>\n<li>PluginActivity中所有调用context的相关的方法，如setContentView，getLayoutInflater，getSystemService等都需要调用ProxyActivity的相应方法。</li>\n</ul>\n<p>缺点</p>\n<ul>\n<li>插件中的Activity必须继承PluginActivity，开发侵入性强。</li>\n<li>如果想支持Activity的singleTask，singleInstance等launchMode时，需要自己管理Activity栈，实现起来很繁琐。</li>\n<li>插件中需要小心处理Context，容易出错。</li>\n<li>如果想把之前的模块改造成插件需要很多额外的工作。</li>\n</ul>\n<p>该方式虽然能够很好的实现启动插件Activity的目的，但是由于开发式侵入性很强，dynamic-load-apk之后的插件化方案很少继续使用该方式，而是通过hook系统启动Activity的过程，让启动插件中的Activity像启动主工程的Activity一样简单。</p>\n<h4 id=\"动态替换方案：提供对android底层的各种类进行hook，来实现加载插件中的四大组件，以droidplugin框架为代表\">动态替换方案：提供对Android底层的各种类进行Hook，来实现加载插件中的四大组件，以DroidPlugin框架为代表<a title=\"#动态替换方案：提供对android底层的各种类进行hook，来实现加载插件中的四大组件，以droidplugin框架为代表\" href=\"#动态替换方案：提供对android底层的各种类进行hook，来实现加载插件中的四大组件，以droidplugin框架为代表\"></a></h4>\n<p>实现方案:</p>\n<ul>\n<li>Hook Instrument实现</li>\n<li>Hook Handler实现</li>\n</ul>\n<p>代码Demo:<a href=\"https://github.com/Onion99/AndroidComponentPlugin\" target=\"_blank\">Onion99/AndroidComponentPlugin: Android上简单实现四大组件的插件化</a><br>\n参考 : <a href=\"https://developer.aliyun.com/article/873723?spm=a2c6h.12883283.0.0.67d543078VqvHa&amp;scm=20140722.ID_873723.P_121.MO_938-ST_5186-V_1-ID_873723-OR_rec\" target=\"_blank\">Android Hook告诉你 如何启动未注册的Activity</a></p>\n<h3 id=\"refer\">Refer<a title=\"#refer\" href=\"#refer\"></a></h3>\n<p><a href=\"https://www.jianshu.com/p/71585d744076\" target=\"_blank\">Android插件化(一))</a><br>\n<a href=\"https://zhuanlan.zhihu.com/p/33017826\" target=\"_blank\">深入理解Android插件化技术 - 知乎 (zhihu.com)</a><br>\n<a href=\"https://blog.csdn.net/n_fly/article/details/113865650\" target=\"_blank\">Android插件化实现方案_安卓插件化</a></p>\n",
            "tags": [
                "黑科技"
            ]
        },
        {
            "id": "https://onion99.github.io/2022/03/08/phzbEh3JEzAC0XwD/",
            "url": "https://onion99.github.io/2022/03/08/phzbEh3JEzAC0XwD/",
            "title": "Android黑科技 - 热修复",
            "date_published": "2022-03-07T22:38:05.000Z",
            "content_html": "<blockquote>\n<p>热修复本质就是将错误的代码替换成正确的代码,但这里的替换不是改写原有的代码,而是提供一份新的正确的代码,让应用运行时绕过错误的代码,从而执行正确的代码</p>\n</blockquote>\n<p><img src=\"https://s1.ax1x.com/2022/03/06/bDtcIx.png\" alt=\"bDtcIx.png\" loading=\"lazy\" class=\"φbp\"></p>\n<span id=\"more\"></span>\n<p>基础知识:</p>\n<ul>\n<li><a href=\"https://fullstackaction.com/pages/ccf9c0/#%E4%B8%80%E3%80%81dex-class-%E6%B5%85%E6%9E%90\" target=\"_blank\">热修复与插件化基础 - dex与class</a></li>\n<li><a href=\"https://fullstackaction.com/pages/1084c4/\" target=\"_blank\">热修复与插件化基础 - Java与Android虚拟机</a></li>\n<li><a href=\"https://fullstackaction.com/pages/a5eb80/\" target=\"_blank\">热修复与插件化基础 - Java与Android的类加载器</a></li>\n</ul>\n<h2 id=\"实现方案\">实现方案<a title=\"#实现方案\" href=\"#实现方案\"></a></h2>\n<h3 id=\"native层替换方案\">Native层替换方案<a title=\"#native层替换方案\" href=\"#native层替换方案\"></a></h3>\n<blockquote>\n<p>底层替换，修改java方法在native层的函数指针，指向修复后的方法以达到修复目的</p>\n</blockquote>\n<p>Android/Java代码的最小组织方式是方法（Method，实际上，每一个dex文件最多可以包含65536（0xffff）个方法），每个方法在ART虚拟机中都有一个ArtMethod结构体指针与之对应，ArtMethod结构体中包含了Java方法的所有信息，包括执行入口、访问权限、所属类和代码执行地址等等。换句话说，虚拟机就是通过ArtMethod结构体来操纵Java方法的。ArtMethod结构如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ArtMethod</span> <span class=\"title\">FINAL</span> &#123;</span></span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">  GcRoot&lt;mirror::Class&gt; declaring_class_;</span><br><span class=\"line\"></span><br><span class=\"line\">  std::atomic&lt;std::<span class=\"keyword\">uint32_t</span>&gt; access_flags_;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Offset to the CodeItem.</span></span><br><span class=\"line\">  <span class=\"keyword\">uint32_t</span> dex_code_item_offset_;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Index into method_ids of the dex file associated with this method.</span></span><br><span class=\"line\">  <span class=\"keyword\">uint32_t</span> dex_method_index_;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">uint16_t</span> method_index_;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">uint16_t</span> hotness_count_;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">PtrSizedFields</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// Depending on the method type, the data is</span></span><br><span class=\"line\">    <span class=\"comment\">//   - native method: pointer to the JNI function registered to this method</span></span><br><span class=\"line\">    <span class=\"comment\">//                    or a function to resolve the JNI function,</span></span><br><span class=\"line\">    <span class=\"comment\">//   - conflict method: ImtConflictTable,</span></span><br><span class=\"line\">    <span class=\"comment\">//   - abstract/interface method: the single-implementation if any,</span></span><br><span class=\"line\">    <span class=\"comment\">//   - proxy method: the original interface method or constructor,</span></span><br><span class=\"line\">    <span class=\"comment\">//   - other methods: the profiling data.</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span>* data_;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Method dispatch from quick compiled code invokes this pointer which may cause bridging into</span></span><br><span class=\"line\">    <span class=\"comment\">// the interpreter.</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span>* entry_point_from_quick_compiled_code_;</span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">  ptr_sized_fields_;</span><br><span class=\"line\">...</span><br><span class=\"line\">｝</span><br></pre></td></tr></table></figure>\n<p>其中有一个关键指针，它是方法的执行入口：<br>\n<code>entry_point_from_quick_compiled_code_</code><br>\n也就是说，这个指针指向方法体编译后对应的汇编指令。那么，如果我们能hook这个指针，由原来指向有bug的方法，变成指向正确的方法，就达到了修复的目的。这就是native层替换方案的核心原理。具体实现方案可以是改变指针指向（AndFix），也可以直接替换整个结构体（Sophix）。</p>\n<p>需要注意的是，底层替换方案虽然是即使生效的，但是因为不会加载新类，而是直接修改原类，所以修改的代码不能增加新的方法，否则会造成索引数与方法数不匹配，无法通过索引找到正确方法，字段同理</p>\n<h3 id=\"类加载方案\">类加载方案<a title=\"#类加载方案\" href=\"#类加载方案\"></a></h3>\n<blockquote>\n<p>加载一个类的时候，都会去循环dexElements数组取出里面的dex文件，然后从dex文件中找目标类，只要目标类找到，则直接退出循环，也就是后面的dex文件就没有被取到的机会。将热修复的类放在dexElements[]的最前面，这样加载类时 <strong>会优先加载到要修复的类</strong>以达到修复目的</p>\n</blockquote>\n<p><img src=\"https://s1.ax1x.com/2022/03/06/bDduwj.png\" alt=\"bDduwj.png\" loading=\"lazy\" class=\"φbp\"></p>\n<p>基于jvm的java应用是通过ClassLoader来加载应用中的class的，Android对JVM优化过，使用的是ART(以前是Dalvik)，class文件会被打包进dex文件中，底层虚拟机有所不同，那么它们的类加载器也会有所区别，在Android中，要加载dex文件中的class文件就需要用到 PathClassLoader 或 DexClassLoader 这两个Android专用的类加载器。</p>\n<p><img src=\"https://s1.ax1x.com/2022/03/07/bsEKiR.png\" alt=\"bsEKiR.png\" loading=\"lazy\" class=\"φbp\"></p>\n<h4 id=\"原理\">原理<a title=\"#原理\" href=\"#原理\"></a></h4>\n<p><img src=\"https://s1.ax1x.com/2022/03/07/bsdsXT.png\" alt=\"bsdsXT.png\" loading=\"lazy\" class=\"φbp\"></p>\n<h4 id=\"生成修复dex\">生成修复Dex<a title=\"#生成修复dex\" href=\"#生成修复dex\"></a></h4>\n<p>1.将出bug的类修改正确，然后执行打包流程  <a href=\"https://imgtu.com/i/bsNkSf\" target=\"_blank\"><img src=\"https://s1.ax1x.com/2022/03/07/bsNkSf.png\" alt=\"bsNkSf.png\" loading=\"lazy\"></a></p>\n<p>2.此时取出工程目录下的/build/intermediates/javac/debug/classes/包路径/文件夹下对应的class文件</p>\n<p>3.在复制这个class文件时，需要把它所在的完整包目录一起复制，然后在命令行下cd到该目录，执行<code>dx --dex --output=patch.dex 包名路径/需要修复的类文件</code>,此时会在当前目录下生成patch.dex文件  <a href=\"https://imgtu.com/i/bsNQf0\" target=\"_blank\"><img src=\"https://s1.ax1x.com/2022/03/07/bsNQf0.png\" alt=\"bsNQf0.png\" loading=\"lazy\"></a></p>\n<p>4.然后将patch.dex文件当成补丁包放入资源文件夹raw下即可。</p>\n<p>指令为：dx --dex --output=patch.dex com/xxx/xxx/fixbug.class -&gt; 生成patch.dex文件</p>\n<p>也可以写成：dx --dex --output=patch.jar com/xxx/xxx/fixbug.class -&gt; 生成patch.jar文件</p>\n<p>ClassLoader可以加载.dex文件，或者.zip、.jar、.apk中包含的.dex文件</p>\n<h4 id=\"实践\">实践<a title=\"#实践\" href=\"#实践\"></a></h4>\n<p>Application:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 之所以要在本类中做补丁包的安装是因为怕如果在后面的流程中做安装会造成有些带bug的类如果已经被系统加载的话，后续补丁包安装之后</span></span><br><span class=\"line\"><span class=\"comment\"> * 补丁包中的类得不到执行，因为类加载有缓存机制，系统会将加载过的类做一份内存缓存。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApplication</span> <span class=\"keyword\">extends</span> <span class=\"title\">Application</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate();</span><br><span class=\"line\">        <span class=\"comment\">// 此处为加载补丁包，其实真实应用场景是从服务端下载补丁文件，因为本工程为示例所以直接将其放在raw资源文件目录下去读取，省去了下载过程</span></span><br><span class=\"line\">        File patchFile = <span class=\"keyword\">new</span> File(getCacheDir().getAbsolutePath() + File.separator + <span class=\"string\">&quot;patch.dex&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 为了高版本Android访问外部存储需要分区等问题，因为此处仅做示例讲解所以就直接将包拷贝到私有目录中</span></span><br><span class=\"line\">            <span class=\"comment\">// 拷贝到私有目录中还有一个好处是避免在补丁包安装过程中包文件被删除造成安装失败</span></span><br><span class=\"line\">            copyFile(patchFile);</span><br><span class=\"line\">            <span class=\"comment\">// 安装补丁包</span></span><br><span class=\"line\">            HotFix.installPatch(<span class=\"keyword\">this</span>, patchFile);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">copyFile</span><span class=\"params\">(File dest)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        InputStream input = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        OutputStream output = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 由于本项目是测试功能，所以这里直接将补丁包放在工程内，真实开发环境中应该是放在服务器然后下载下来</span></span><br><span class=\"line\">            input = getResources().openRawResource(R.raw.patch);</span><br><span class=\"line\">            output = <span class=\"keyword\">new</span> FileOutputStream(dest);</span><br><span class=\"line\">            <span class=\"keyword\">byte</span>[] buf = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">1024</span>];</span><br><span class=\"line\">            <span class=\"keyword\">int</span> bytesRead;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> ((bytesRead = input.read(buf)) != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                output.write(buf, <span class=\"number\">0</span>, bytesRead);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            input.close();</span><br><span class=\"line\">            output.close();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>HotFix.installPatch:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HotFix</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">installPatch</span><span class=\"params\">(Application application, File patch)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (patch == <span class=\"keyword\">null</span> || !patch.exists()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">             * 1.获取当前的类加载器z</span></span><br><span class=\"line\"><span class=\"comment\">             */</span></span><br><span class=\"line\">            ClassLoader classLoader = application.getClassLoader();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">             * 2.获取到dexElements属性以便后续向前追加patch.dex</span></span><br><span class=\"line\"><span class=\"comment\">             */</span></span><br><span class=\"line\">            Field pathListField = ReflectUtils.findField(classLoader, <span class=\"string\">&quot;pathList&quot;</span>);</span><br><span class=\"line\">            Object pathList = pathListField.get(classLoader);</span><br><span class=\"line\">            Field dexElementsField = ReflectUtils.findField(pathList, <span class=\"string\">&quot;dexElements&quot;</span>);</span><br><span class=\"line\">            Object[] dexElements = (Object[]) dexElementsField.get(pathList);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">             * 3.通过反射调用DexPathList类中的makePathElements()方法将patch.dex最终转换为Element[]数组，</span></span><br><span class=\"line\"><span class=\"comment\">             * DexPathList一系列方法都是用来将补丁包转换为Element[]数组的，如makePathElements，makeDexElements..</span></span><br><span class=\"line\"><span class=\"comment\">             * 具体的API根据真实API的版本不同方法参数等可能会有出入，所以这里在使用过程中实际上应该通过判断去兼容各个版本，</span></span><br><span class=\"line\"><span class=\"comment\">             * 此处因为是示例所以没做兼容</span></span><br><span class=\"line\"><span class=\"comment\">             */</span></span><br><span class=\"line\">            List&lt;File&gt; files = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">            files.add(patch);</span><br><span class=\"line\">            Method method = ReflectUtils.findMethod(pathList, <span class=\"string\">&quot;makePathElements&quot;</span>, List.class, File.class, List.class);</span><br><span class=\"line\">            ArrayList&lt;IOException&gt; suppressedExceptions = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">            Object[] patchElements = (Object[]) method.invoke(pathList, files, application.getCacheDir(), suppressedExceptions);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">             * 4.合并patchElements+dexElements,将补丁包的.dex文件插入数组最前面，后续在加载类的时候会优先从第一个开始遍历查找类</span></span><br><span class=\"line\"><span class=\"comment\">             */</span></span><br><span class=\"line\">            Object[] newElements = (Object[]) Array.newInstance(dexElements.getClass().getComponentType(), dexElements.length + patchElements.length);</span><br><span class=\"line\">            System.arraycopy(patchElements, <span class=\"number\">0</span>, newElements, <span class=\"number\">0</span>, patchElements.length);</span><br><span class=\"line\">            System.arraycopy(dexElements, <span class=\"number\">0</span>, newElements, patchElements.length, dexElements.length);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">             * 5.将新数组置换掉BaseDexClassLoader -&gt; pathList -&gt; dexElements属性，至此工作完成</span></span><br><span class=\"line\"><span class=\"comment\">             */</span></span><br><span class=\"line\">            dexElementsField.set(pathList, newElements);</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReflectUtils</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/* 找到反射属性 **/</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Field <span class=\"title\">findField</span><span class=\"params\">(Object instance, String name)</span> </span>&#123;</span><br><span class=\"line\">        Class&lt;?&gt; clz = instance.getClass();</span><br><span class=\"line\">        Field field = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (clz != Object.class) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                field = clz.getDeclaredField(name);</span><br><span class=\"line\">                field.setAccessible(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> field;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (NoSuchFieldException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//向父类寻找属性</span></span><br><span class=\"line\">            clz = clz.getSuperclass();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> field;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/* 找到反射函数 **/</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Method <span class=\"title\">findMethod</span><span class=\"params\">(Object instance, String name, Class&lt;?&gt;... parameterTypes)</span> </span>&#123;</span><br><span class=\"line\">        Class&lt;?&gt; clz = instance.getClass();</span><br><span class=\"line\">        Method method = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (clz != Object.class) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                method = clz.getDeclaredMethod(name, parameterTypes);</span><br><span class=\"line\">                method.setAccessible(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> method;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (NoSuchMethodException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//向父类寻找属性</span></span><br><span class=\"line\">            clz = clz.getSuperclass();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> method;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/* 找到反射所有函数数组 **/</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Method[] findAllMethods(Object instance) &#123;</span><br><span class=\"line\">        Class&lt;?&gt; clz = instance.getClass();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> clz.getDeclaredMethods();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>实际上，类替换方案的核心思想就是：将修改后的patch（包含bug类文件）打包成dex文件，然后hook ClassLoader加载流程，将这个dex文件插入到Element数组的第一个元素。因为加载类是依次进行的，所以虚拟机从第一个Element找到类后，就不会再加载bug类了。</p>\n<p>类加载方案也有缺点，因为类加载后无法卸载，所以类加载方案必须重启App，让bug类重新加载后才能生效</p>\n<h3 id=\"instant-run方案\">Instant Run方案<a title=\"#instant-run方案\" href=\"#instant-run方案\"></a></h3>\n<blockquote>\n<p>Instant Run 方案的核心思想是——插桩，在编译时通过插桩在每一个方法中插入代码，修改代码逻辑，在需要时绕过错误方法，调用patch类的正确方法</p>\n</blockquote>\n<p>首先，在编译时Instant Run为每个类插入IncrementalChange变量：<br>\n<code>IncrementalChange  $change;</code></p>\n<p>为每一个方法添加类似如下代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">        IncrementalChange var2 = $change;</span><br><span class=\"line\">        <span class=\"comment\">//$change不为null，表示该类有修改，需要重定向</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(var2 != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//通过access$dispatch方法跳转到patch类的正确方法</span></span><br><span class=\"line\">            var2.access$dispatch(<span class=\"string\">&quot;onCreate.(Landroid/os/Bundle;)V&quot;</span>, <span class=\"keyword\">new</span> Object[]&#123;<span class=\"keyword\">this</span>, savedInstanceState&#125;);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.setContentView(<span class=\"number\">2130968601</span>);</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.tv = (TextView)<span class=\"keyword\">this</span>.findViewById(<span class=\"number\">2131492944</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>如上代码，当一个类被修改后，Instant Run会为这个类新建一个类，命名为xxx&amp;override，且实现IncrementalChange接口，并且赋值给原类的$change变量。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainActivity</span>$<span class=\"title\">override</span> <span class=\"keyword\">implements</span> <span class=\"title\">IncrementalChange</span> </span>&#123;</span><br><span class=\"line\">｝</span><br></pre></td></tr></table></figure>\n<p>此时，在运行时原类中每个方法的var2 != null，通过accessdispatch（参数是方法名和原参数）定位到patch类MainActivityoverride中修改后的方法。</p>\n<p>Instant Run是google在AS2.0时用来实现“热部署”的，同时也为“热修复”提供了一个绝佳的思路。美团的Robust就是基于此。</p>\n<h3 id=\"so库修复\">SO库修复<a title=\"#so库修复\" href=\"#so库修复\"></a></h3>\n<h4 id=\"接口调用替换\">接口调用替换<a title=\"#接口调用替换\" href=\"#接口调用替换\"></a></h4>\n<p>sdk提供接口替换System默认加载so库的接口</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SOPatchManger.loadLibrary(String libName)</span><br><span class=\"line\"><span class=\"comment\">//代替</span></span><br><span class=\"line\">System.loadLibrary(String libName)</span><br></pre></td></tr></table></figure>\n<p>SOPatchManger.loadLibrary接口加载so库的时候优先尝试去加载sdk指定目录下补丁的so。若不存在，则再去加载安装apk目录下的so库</p>\n<p>优点：不需要对不同sdk版本进行兼容，所以sdk版本都是System.loadLibrary这个接口<br>\n缺点：需要侵入业务代码，替换掉System默认加载so库的接口</p>\n<h4 id=\"反射注入\">反射注入<a title=\"#反射注入\" href=\"#反射注入\"></a></h4>\n<p>采取类似类修复反射注入方式，只要把补丁so库的路径插入到nativeLibraryDirectories数组的最前面，就能够达到加载so库的时候是补丁so库而不是原来so库的目录，从而达到修复。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"built_in\">String</span> <span class=\"function\"><span class=\"title\">findLibrary</span>(<span class=\"params\"><span class=\"built_in\">String</span> libraryName</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">String</span> fileName = System.mapLibraryName(libraryName);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (NativeLibraryElement element : nativeLibraryPathElements) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">String</span> path = element.findNativeLibrary(fileName);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (path != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> path;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>优点：不需侵入用户接口调用<br>\n缺点：需要做版本兼容控制，兼容性较差</p>\n<h2 id=\"热修复技术方案选型\">热修复技术方案选型<a title=\"#热修复技术方案选型\" href=\"#热修复技术方案选型\"></a></h2>\n<p><img src=\"https://s1.ax1x.com/2022/03/06/bDwH8x.png\" alt=\"bDwH8x.png\" loading=\"lazy\" class=\"φbp\"></p>\n<h2 id=\"热修复和插件化区别\">热修复和插件化区别<a title=\"#热修复和插件化区别\" href=\"#热修复和插件化区别\"></a></h2>\n<blockquote>\n<p>插件化和热修复的原理，都是动态加载 dex／apk 中的类／资源，让宿主正常的加载和运行插件（补丁）中的内容</p>\n</blockquote>\n<ul>\n<li>\n<p>插件化目标是想把需要实现的模块或功能当做一个独立的提取出来，减少宿主的规模。重在解决组件的生命周期，以及资源的问题</p>\n</li>\n<li>\n<p>热修复目标在修复已有的问题。重在解决替换已有的有问题的类／方法／资源等</p>\n</li>\n</ul>\n<h2 id=\"deemo\">Deemo<a title=\"#deemo\" href=\"#deemo\"></a></h2>\n<p><a href=\"https://github.com/jiangzhengnan/Syringe\" target=\"_blank\">jiangzhengnan/Syringe: 📌 插件化注入工程(热修复+插件化)</a></p>\n<h2 id=\"refer\">Refer<a title=\"#refer\" href=\"#refer\"></a></h2>\n<p><a href=\"https://www.jianshu.com/p/cb1f0702d59f\" target=\"_blank\">热修复——深入浅出原理与实现</a><br>\n<a href=\"https://www.cnblogs.com/not2/p/11392733.html\" target=\"_blank\">热修复 - 西贝雪</a><br>\n<a href=\"https://zhuanlan.zhihu.com/p/109169752\" target=\"_blank\">Android热修复技术,你会怎么选？</a><br>\n<a href=\"https://github.com/BigSweet/hotFixALL\" target=\"_blank\">BigSweet/hotFixALL: 整理andfix,thinker,robust热修复使用方法和原理</a><br>\n<a href=\"https://github.com/yoyiyi/SoleilNotes/blob/master/Android/%E7%83%AD%E4%BF%AE%E5%A4%8D.md\" target=\"_blank\">SoleilNotes/热修复.md at master · yoyiyi/SoleilNotes</a></p>\n",
            "tags": [
                "黑科技"
            ]
        },
        {
            "id": "https://onion99.github.io/2022/03/08/ukYPIjylHjywfytF/",
            "url": "https://onion99.github.io/2022/03/08/ukYPIjylHjywfytF/",
            "title": "Android黑科技 - 热修复和插件化基础",
            "date_published": "2022-03-07T22:31:41.000Z",
            "content_html": "<h3 id=\"dalvik和-art\">Dalvik和 ART<a title=\"#dalvik和-art\" href=\"#dalvik和-art\"></a></h3>\n<p>DVM也是实现了JVM规范的一个虚拟器，默认使用CMS垃圾回收器，但是与JVM运行 Class 字节码不同，DVM 执行 Dex(Dalvik Executable Format) ——专为 Dalvik 设计的一种压缩格式。Dex 文件是很多 .class 文件处理压缩后的产物，最终可以在 Android 运行时环境执行。</p>\n<span id=\"more\"></span>\n<p>ART（Android Runtime） 是在 Android 4.4 中引入的一个开发者选项，也是 Android 5.0 及更高版本的默认 Android 运行时。</p>\n<p>ART 和 Dalvik 都是运行 Dex 字节码的兼容运行时，因此针对 Dalvik 开发的应用也能在 ART 环境中运作。</p>\n<p>Dalvik和 ART编译区别<br>\n<img src=\"https://s1.ax1x.com/2022/03/07/bydjWn.png\" alt=\"bydjWn.png\" loading=\"lazy\"></p>\n<p><a href=\"https://source.android.google.cn/devices/tech/dalvik/gc-debug\" target=\"_blank\">source.android.google.cn/devices/tec…</a></p>\n<p>dexopt与dexaot区别:</p>\n<ul>\n<li>dexopt<br>\n在Dalvik中虚拟机在加载一个dex文件时，对 dex 文件 进行 验证 和 优化的操作，其对 dex 文件的优化结果变成了 odex(Optimized dex) 文件，这个文件和 dex 文件很像，只是使用了一些优化操作码。</li>\n<li>dex2oat<br>\nART 预先编译机制，在安装时对 dex 文件执行dexopt优化之后再将odex进行 AOT 提前编译操作，编译为OAT（实际上是ELF文件）可执行文件（机器码）。（相比做过ODEX优化，未做过优化的DEX转换成OAT要花费更长的时间）</li>\n</ul>\n<h3 id=\"类加载\">类加载<a title=\"#类加载\" href=\"#类加载\"></a></h3>\n<blockquote>\n<p>任何一个 Java 程序都是由一个或多个 class 文件组成，在程序运行时，需要将 class 文件加载到 JVM 中才可以使用，负责加载这些 class 文件的就是 Java 的类加载机制。</p>\n</blockquote>\n<p>Android中常用的有两种类加载器，DexClassLoader和PathClassLoader，它们都继承于BaseDexClassLoader。相关源码如下：</p>\n<p><img src=\"https://pic1.zhimg.com/80/v2-43a7045200722c1aea24966765f82570_720w.jpg\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<p>区别在于调用父类构造器时，DexClassLoader多传了一个optimizedDirectory参数，这个目录必须是内部存储路径，用来缓存系统创建的Dex文件。而PathClassLoader该参数为null，只能加载内部存储目录的Dex文件。所以我们可以用DexClassLoader去加载外部的apk，用法如下：</p>\n<p><img src=\"https://pic3.zhimg.com/80/v2-280d8e49c4b6aab388bc1f8b906f13f2_720w.jpg\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<h4 id=\"refer\">Refer<a title=\"#refer\" href=\"#refer\"></a></h4>\n<p><a href=\"https://juejin.cn/post/7018534681620512805\" target=\"_blank\">Android 热修复核心原理，ClassLoader类加载 </a><br>\n<a href=\"https://blog.csdn.net/qq_35090026/article/details/122909541#:~:text=Android%E4%B8%AD%E7%9A%84ClassLoader%E7%B1%BB%E5%9E%8B%E5%88%86%E5%88%AB%E6%98%AF%E7%B3%BB%E7%BB%9F%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%92%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8A%A0%E8%BD%BD%E5%99%A8%E3%80%82%20%E5%85%B6%E4%B8%AD%E7%B3%BB%E7%BB%9F%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E4%B8%BB%E8%A6%81%E5%8C%85%E6%8B%AC3%E7%A7%8D%EF%BC%8C%E5%88%86%E5%88%AB%E6%98%AF%20BootClassLoader%20%E3%80%81,PathClassLoader%20%E5%92%8C%20DexClassLoader%20%E3%80%82\" target=\"_blank\">Android ClassLoader类加载机制</a><br>\n<a href=\"https://blog.csdn.net/qq_32506429/article/details/122783941\" target=\"_blank\">Android ClassLoader机制与热修复</a><br>\n<a href=\"https://blog.csdn.net/xiangzhihong8/article/details/52880327\" target=\"_blank\">Android ClassLoader详解</a></p>\n<h3 id=\"双亲委托机制\">双亲委托机制<a title=\"#双亲委托机制\" href=\"#双亲委托机制\"></a></h3>\n<p>ClassLoader调用loadClass方法加载类，代码如下：</p>\n<p><img src=\"https://pic2.zhimg.com/80/v2-20dca70a7fca2413de158563cb7d27d1_720w.jpg\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<p>可以看出ClassLoader加载类时，先查看自身是否已经加载过该类，如果没有加载过会首先让父加载器去加载，如果父加载器无法加载该类时才会调用自身的findClass方法加载，该机制很大程度上避免了类的重复加载。</p>\n<h3 id=\"dexclassloader的dexpathlist\">DexClassLoader的DexPathList<a title=\"#dexclassloader的dexpathlist\" href=\"#dexclassloader的dexpathlist\"></a></h3>\n<blockquote>\n<p>DexPathList是在构造DexClassLoader时生成的，其内部包含了DexFile</p>\n</blockquote>\n<p><img src=\"https://s1.ax1x.com/2022/03/07/by01BT.png\" alt=\"by01BT.png\" loading=\"lazy\" class=\"φbp\"></p>\n<p>DexPathList的loadClass会去遍历DexFile直到找到需要加载的类。</p>\n<p><img src=\"https://pic3.zhimg.com/80/v2-ddf43519948c3b9ab3f15ff19cf77dfe_720w.jpg\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<p>腾讯的qq空间热修复技术正是利用了DexClassLoader的加载机制，将需要替换的类添加到dexElements的前面，这样系统会使用先找到的修复过的类。</p>\n<h3 id=\"资源加载\">资源加载<a title=\"#资源加载\" href=\"#资源加载\"></a></h3>\n<p>Android系统通过Resource对象加载资源，下面代码展示了该对象的生成过程。</p>\n<p><img src=\"https://pic1.zhimg.com/80/v2-ab6ea5aad79904422d2fa7d8bc87a64c_720w.jpg\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<p>因此，只要将插件apk的路径加入到AssetManager中，便能够实现对插件资源的访问。</p>\n<p>具体实现时，由于AssetManager并不是一个public的类，需要通过反射去创建，并且部分Rom对创建的Resource类进行了修改，所以需要考虑不同Rom的兼容性。</p>\n<h3 id=\"refer-1\">Refer<a title=\"#refer-1\" href=\"#refer-1\"></a></h3>\n<p><a href=\"https://zhuanlan.zhihu.com/p/33017826\" target=\"_blank\">深入理解Android插件化技术 </a></p>\n",
            "tags": [
                "黑科技"
            ]
        }
    ]
}