{
    "version": "https://jsonfeed.org/version/1",
    "title": "Stay hungry , Stay foolish • All posts by \"性能优化\" tag",
    "description": "巴拉巴拉",
    "home_page_url": "http://onion66.gitee.io/blog",
    "items": [
        {
            "id": "http://onion66.gitee.io/blog/2021/11/01/5FIszA6Ut2OHE8Sg/",
            "url": "http://onion66.gitee.io/blog/2021/11/01/5FIszA6Ut2OHE8Sg/",
            "title": "安卓优化-布局优化",
            "date_published": "2021-10-31T20:50:14.000Z",
            "content_html": "<h3 id=\"布局耗时统计\">布局耗时统计<a title=\"#布局耗时统计\" href=\"#布局耗时统计\"></a></h3>\n<ul>\n<li>手动埋点</li>\n<li>AOP/ArtHook\n<ul>\n<li>切入Activity的setContentView</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"布局加载优化\">布局加载优化<a title=\"#布局加载优化\" href=\"#布局加载优化\"></a></h3>\n<ul>\n<li>代码写布局\n<ul>\n<li>Java代码写布局</li>\n<li>Anko</li>\n<li>JetpackCompose</li>\n</ul>\n</li>\n<li>X2C</li>\n<li>Litho</li>\n</ul>\n<span id=\"more\"></span>\n<h3 id=\"视图绘制优化\">视图绘制优化<a title=\"#视图绘制优化\" href=\"#视图绘制优化\"></a></h3>\n<ul>\n<li>优化布局层级以及嵌套\n<ul>\n<li>使用ConstraintLayout</li>\n</ul>\n</li>\n<li>避免过度绘制,自定义View避免多次调用 onDraw,onMeasure</li>\n<li>其他\n<ul>\n<li>ViewStub: 延迟初始化</li>\n<li>onDraw,onMeasure中避免创建大对象,耗时操作</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"include\">Include<a title=\"#include\" href=\"#include\"></a></h4>\n<blockquote>\n<p>提高布局复用性</p>\n</blockquote>\n<p>login.xml</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">include</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:layout_width</span>=<span class=\"string\">&quot;match_parent&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:layout_height</span>=<span class=\"string\">&quot;40dp&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">layout</span>=<span class=\"string\">&quot;@layout/titlebar&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n<p>include所在的layout的布局有给其设置id, 而include标签里面又给自己的根容器设置id,最好两个id都相同,否则findview时拿到空对象</p>\n<h4 id=\"merge\">Merge<a title=\"#merge\" href=\"#merge\"></a></h4>\n<blockquote>\n<p>帮助include标签排除多余的一层ViewGroup容器，减少view hierarchy的结构，提升UI渲染的性能</p>\n</blockquote>\n<p>titlebar.xml</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">merge</span> <span class=\"attr\">xmlns:android</span>=<span class=\"string\">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;</span></span><br><span class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">Button</span> </span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:layout_width</span>=<span class=\"string\">&quot;match_parent&quot;</span>  </span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:layout_height</span>=<span class=\"string\">&quot;wrap_content&quot;</span>  </span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:layout_marginLeft</span>=<span class=\"string\">&quot;20dp&quot;</span>  </span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:layout_marginRight</span>=<span class=\"string\">&quot;20dp&quot;</span>  </span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:text</span>=<span class=\"string\">&quot;标题&quot;</span> /&gt;</span>  </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">merge</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>因为merge标签并不是View,所以在通过LayoutInflate.inflate()方法渲染的时候,第二个参数必须指定一个父容器(parent),且第三个参数(attachToRoot)必须为true</li>\n<li>merge标签必须使用在根布局，并且ViewStub标签中的layout布局不能使用merge标签</li>\n</ul>\n<h4 id=\"viewstub\">ViewStub<a title=\"#viewstub\" href=\"#viewstub\"></a></h4>\n<blockquote>\n<p>延迟绘制View</p>\n</blockquote>\n<p>layout.xml</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ViewStub</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:id</span>=<span class=\"string\">&quot;@+id/viewstub&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:layout_width</span>=<span class=\"string\">&quot;match_parent&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:layout_height</span>=<span class=\"string\">&quot;wrap_content&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:layout</span>=<span class=\"string\">&quot;@layout/info&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n<p>activity.java</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ViewStub stub = ((ViewStub) findViewById(R.id.viewstub));</span><br><span class=\"line\"><span class=\"keyword\">if</span>(stub!=<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">    View stubView = stub.inflate();</span><br><span class=\"line\">    EditText editText = (EditText) stubView.findViewById(R.id.edit_password);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>ViewStub标签不支持merge标签</li>\n<li>ViewStub的inflate只能被调用一次,第二次调用会抛出异常</li>\n<li>虽然ViewStub是不占用任何空间的，但是每个布局都必须要指定layout_width和layout_height属性，否则运行就会报错</li>\n</ul>\n",
            "tags": [
                "性能优化"
            ]
        },
        {
            "id": "http://onion66.gitee.io/blog/2021/11/01/6JN9JxpnRSjVeWry/",
            "url": "http://onion66.gitee.io/blog/2021/11/01/6JN9JxpnRSjVeWry/",
            "title": "安卓优化-线程优化",
            "date_published": "2021-10-31T20:48:51.000Z",
            "content_html": "<h3 id=\"线程调度\">线程调度<a title=\"#线程调度\" href=\"#线程调度\"></a></h3>\n<blockquote>\n<p>任意时刻，只有一个线程占用CPU，处于运行状态</p>\n</blockquote>\n<p>多线程并发：轮流获取cpu使用权<br>\nJVM负责线程调度：按照特定调度模型分配CPU使用权</p>\n<h4 id=\"调度模型\">调度模型<a title=\"#调度模型\" href=\"#调度模型\"></a></h4>\n<ul>\n<li>分时调度模型: 轮流获取,均匀分配cpu时间</li>\n<li>抢占式调度模型:  按照优先级来</li>\n</ul>\n<span id=\"more\"></span>\n<h3 id=\"android异步方式\">Android异步方式<a title=\"#android异步方式\" href=\"#android异步方式\"></a></h3>\n<ul>\n<li>Thread\n<ul>\n<li>最简单、常见的方式</li>\n<li>不易复用，频繁创建销毁开销大</li>\n</ul>\n</li>\n<li>HandlerThread\n<ul>\n<li>自带消息循环的线程</li>\n<li>串行执行,长时间运行，不断从队列中获取任务</li>\n</ul>\n</li>\n<li>IntentService\n<ul>\n<li>继承自Service在内部创建HandlerThread</li>\n<li>异步、不占用主线程</li>\n<li>优先级高，不易被系统kil</li>\n</ul>\n</li>\n<li>AsyncTask\n<ul>\n<li>Android提供的工具类</li>\n<li>无需自己处理线程切换</li>\n</ul>\n</li>\n<li>线程池\n<ul>\n<li>jdk提供的线程池</li>\n<li>易复用，减少频繁创建、销毁的时间</li>\n<li>功能强大：定时、任务列队、并发数控制等</li>\n</ul>\n</li>\n<li>RxJava\n<ul>\n<li>由强大的Scheduler集合提供</li>\n<li>不同类型的区分：IO密集型、CPU密集型</li>\n</ul>\n</li>\n<li>协程</li>\n</ul>\n<h3 id=\"线程使用准则\">线程使用准则<a title=\"#线程使用准则\" href=\"#线程使用准则\"></a></h3>\n<p>1、严禁使用new Thread,因为这样不便控制,可能产生预期之外的事情<br>\n2、提供基础线程池供各个业务栈使用（避免各个业务栈各自维护一套线程池，导致线程数过多）<br>\n3、根据任务类型选择合适的异步方式（优先级低长时间执行-HandlerThread，定时执行-线程池）<br>\n4、创建线程必须命名（方便定位线程归属，运行期Thread.currentThread().setName修改名字）<br>\n5、关键异步任务监控（异步不等于不耗时，AOP的方式来做监控）<br>\n6、重视优先级的设置（Process.setThreadPriority(),可以设置多次）</p>\n",
            "tags": [
                "性能优化"
            ]
        },
        {
            "id": "http://onion66.gitee.io/blog/2021/11/01/9LsQhIFgDkllFt0Q/",
            "url": "http://onion66.gitee.io/blog/2021/11/01/9LsQhIFgDkllFt0Q/",
            "title": "安卓优化-包体积",
            "date_published": "2021-10-31T20:48:08.000Z",
            "content_html": "<p><a href=\"https://cloud.tencent.com/developer/article/1425318\" target=\"_blank\">Android APP 终极瘦身指南</a></p>\n<ul>\n<li>图片转WebP</li>\n<li>去掉不必要的so库</li>\n<li>开启shrinkResources去除无用资源</li>\n<li>开启minifyEnabled混淆代码</li>\n<li>删除无用的语言资源</li>\n<li>使用微信资源压缩打包工具</li>\n<li>避免重复库,以及避免不同版本的库</li>\n<li>AndroidManifest中 -&gt; android:extractNativeLibs=“true”</li>\n</ul>\n",
            "tags": [
                "性能优化"
            ]
        },
        {
            "id": "http://onion66.gitee.io/blog/2021/11/01/UYa5EEntsM9sKTYz/",
            "url": "http://onion66.gitee.io/blog/2021/11/01/UYa5EEntsM9sKTYz/",
            "title": "安卓优化-卡顿优化",
            "date_published": "2021-10-31T20:47:12.000Z",
            "content_html": "<blockquote>\n<p>卡顿产生的根本原因就是CPU和GPU没有及时处理好数据，针对卡顿的优化就有思路了：尽可能减少 CPU 和 GPU 资源的消耗</p>\n</blockquote>\n<ul>\n<li>CPU：中央处理器（CPU，central processing unit）作为计算机系统的运算和控制核心，是信息处理、程序运行的最终执行单元</li>\n<li>GPU：图形处理器（英语：Graphics Processing Unit，缩写：GPU），又称显示核心,做图像和图形相关运算工作的微处理器</li>\n</ul>\n<h3 id=\"卡顿检测\">卡顿检测<a title=\"#卡顿检测\" href=\"#卡顿检测\"></a></h3>\n<p><a href=\"https://blog.csdn.net/lmj623565791/article/details/58626355\" target=\"_blank\">Android UI性能优化 检测应用中的UI卡顿</a></p>\n<p><a href=\"https://www.jianshu.com/p/9e8f88eac490\" target=\"_blank\">Android性能优化-检测App卡顿 - 简书 (jianshu.com)</a></p>\n<span id=\"more\"></span>\n<h4 id=\"用ui线程looper打印的日志\">用UI线程Looper打印的日志<a title=\"#用ui线程looper打印的日志\" href=\"#用ui线程looper打印的日志\"></a></h4>\n<p>开源工具:<br>\n<a href=\"https://github.com/Kyson/AndroidGodEye\" target=\"_blank\">Kyson/AndroidGodEye: An app performance monitor(APM) , like “Android Studio profiler”, you can easily monitor the performance of your app real time in browser (github.com)</a></p>\n<p><a href=\"https://github.com/markzhai/AndroidPerformanceMonitor\" target=\"_blank\">markzhai/AndroidPerformanceMonitor: A transparent ui-block detection library for Android. (known as BlockCanary) </a></p>\n<p><a href=\"https://github.com/BzCoder/BlockCanaryCompat\" target=\"_blank\">BzCoder/BlockCanaryCompat: 卡顿监控，BlockCanary 适配Android O 以上系统 (github.com)</a></p>\n<h4 id=\"choreographer\">Choreographer<a title=\"#choreographer\" href=\"#choreographer\"></a></h4>\n<p>Android系统每隔16ms发出VSYNC信号，触发对UI进行渲染。开发者可以使用Choreographer#postFrameCallback设置自己的callback与Choreographer交互，你设置的FrameCallCack（doFrame方法）会在下一个frame被渲染时触发。理论上来说两次回调的时间周期应该在16ms，如果超过了16ms我们则认为发生了卡顿，我们主要就是利用两次回调间的时间周期来判断</p>\n<p>开源工具:<br>\n<a href=\"https://github.com/wasabeef/Takt\" target=\"_blank\">wasabeef/Takt: Takt is Android library for measuring the FPS using Choreographer</a></p>\n<p><a href=\"https://github.com/friendlyrobotnyc/TinyDancer\" target=\"_blank\">friendlyrobotnyc/TinyDancer: An android library for displaying fps from the choreographer and percentage of time with two or more frames dropped </a></p>\n<h3 id=\"anr分析\">ANR分析<a title=\"#anr分析\" href=\"#anr分析\"></a></h3>\n<blockquote>\n<p>Application Not Responding，也就是应用程序无响应</p>\n</blockquote>\n<h4 id=\"产生原因\">产生原因<a title=\"#产生原因\" href=\"#产生原因\"></a></h4>\n<ul>\n<li>InputDispatching Timeout：5秒内无法响应屏幕触摸事件或键盘输入事件</li>\n<li>BroadcastQueue Timeout ：在执行前台广播（BroadcastReceiver）的<code>onReceive()</code>函数时10秒没有处理完成，后台为60秒</li>\n<li>Service Timeout：前台服务20秒内，后台服务在200秒内没有执行完毕</li>\n<li>ContentProvider Timeout：ContentProvider的publish在10s内没进行完</li>\n<li>其他\n<ul>\n<li>主线程阻塞或主线程数据读取</li>\n<li>CPU满负荷，I/O阻塞</li>\n<li>内存不足</li>\n</ul>\n</li>\n</ul>\n<p>分析:</p>\n<ul>\n<li>log上的anr reason</li>\n<li>adb 导出ANR日志\n<ul>\n<li><code>adb pull /data/anr/traces.txt</code></li>\n</ul>\n</li>\n</ul>\n",
            "tags": [
                "性能优化"
            ]
        },
        {
            "id": "http://onion66.gitee.io/blog/2021/11/01/T8ghe13OAeLx6NBP/",
            "url": "http://onion66.gitee.io/blog/2021/11/01/T8ghe13OAeLx6NBP/",
            "title": "安卓优化-内存优化",
            "date_published": "2021-10-31T20:46:21.000Z",
            "content_html": "<h3 id=\"内存信息查看\">内存信息查看<a title=\"#内存信息查看\" href=\"#内存信息查看\"></a></h3>\n<p><a href=\"https://www.jianshu.com/p/28b9cd87e667\" target=\"_blank\">App内存优化实践：一步一步做内存分析与优化</a></p>\n<p>查看每个App进程可以分配到的最大内存</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">adb shell getprop | grep dalvik.vm.heapsize</span><br></pre></td></tr></table></figure>\n<p>App的内存使用情况概览</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">adb shell dumpsys meminfo 包名</span><br></pre></td></tr></table></figure>\n<h3 id=\"优化工具\">优化工具<a title=\"#优化工具\" href=\"#优化工具\"></a></h3>\n<ul>\n<li>CPU Profiler</li>\n<li>Memory Analyzer（MAT）</li>\n<li>LeakCannary</li>\n</ul>\n<span id=\"more\"></span>\n<h3 id=\"优化方向\">优化方向<a title=\"#优化方向\" href=\"#优化方向\"></a></h3>\n<p><a href=\"https://www.cnblogs.com/wangjie1990/p/11327112.html\" target=\"_blank\">Android 如何优化APP内存 </a></p>\n<ul>\n<li>谨慎使用Services\n<ul>\n<li>启动一个Service时， 系统需要始终保持运行该Service的进程,该Service占用的RAM对其他进程不共享</li>\n<li>避免使用持久性服务,如<code>JobScheduler</code>之类</li>\n</ul>\n</li>\n<li>使用经过优化的多数据容器\n<ul>\n<li>如SparseArray，SparseBooleanArray和LongSparseArray</li>\n<li>如有必要，您可以随时切换到原始数组以获得精简的数据结构</li>\n</ul>\n</li>\n<li>使用nano protobufs进行序列化数据</li>\n<li>避免内存泄漏\n<ul>\n<li>内存泄露会导致大量的垃圾收集事件发生,从而导致系统执行其他内容(如渲染或者传输)的时间变少</li>\n</ul>\n</li>\n<li>移除内存密集型资源，以及lib库\n<ul>\n<li>减小APK的大小</li>\n<li>请使用不进行反射扫描的依赖注入库(Dagger2),频繁的反射需要更多的CPU和内存消耗</li>\n<li>谨慎使用外部库,外部库可能对同一个功能有不一样的实现,这可能导致预期之外的事情</li>\n</ul>\n</li>\n</ul>\n",
            "tags": [
                "性能优化"
            ]
        },
        {
            "id": "http://onion66.gitee.io/blog/2021/11/01/4LlbPfdOOCp58LMK/",
            "url": "http://onion66.gitee.io/blog/2021/11/01/4LlbPfdOOCp58LMK/",
            "title": "安卓优化-启动优化",
            "date_published": "2021-10-31T20:43:04.000Z",
            "content_html": "<h3 id=\"启动流程\">启动流程<a title=\"#启动流程\" href=\"#启动流程\"></a></h3>\n<h4 id=\"相关\">相关<a title=\"#相关\" href=\"#相关\"></a></h4>\n<blockquote>\n<p>启动的流程就是通过这六个大类在这三个进程之间不断通信的过程</p>\n</blockquote>\n<h5 id=\"三个进程\">三个进程<a title=\"#三个进程\" href=\"#三个进程\"></a></h5>\n<ul>\n<li>Launcher进程: 整个App启动流程的起点,负责处理桌面与用户之间的交互事件,可以想象为一个桌面启动器</li>\n<li>SystemServer进程: Android中的所有SystemServer都由其孵化(Fork)出来,例如AMS,WindowsMannager,PackageManagerService等</li>\n<li>App进程: 启动的App所在的进程</li>\n</ul>\n<span id=\"more\"></span>\n<h5 id=\"六个大类\">六个大类<a title=\"#六个大类\" href=\"#六个大类\"></a></h5>\n<ul>\n<li>ActivityManagerService:  即AMS,负责管理系统中四大组件的启动,切换,调度以及应用进程的管理</li>\n<li>Instrumentation: 监控应用程序和系统的交互</li>\n<li>ActivityThread: 应用的入口类，通过调用main方法，开启消息循环队列。ActivityThread所在的线程被称为主线程</li>\n<li>ApplicationThread: 提供Binder通讯接口，AMS则通过代理调用此App进程的本地方法</li>\n<li>ActivityManagerProxy：AMS服务在当前进程的代理类，负责与AMS通信</li>\n<li>ApplicationThreadProxy：ApplicationThread在AMS服务中的代理类，负责与ApplicationThread通信</li>\n</ul>\n<h4 id=\"顺序\">顺序<a title=\"#顺序\" href=\"#顺序\"></a></h4>\n<p><a href=\"https://blog.csdn.net/huangliniqng/article/details/89364064\" target=\"_blank\">APP启动流程解析,墙裂推荐</a><br>\n<a href=\"https://www.cnblogs.com/not2/p/14326090.html\" target=\"_blank\">App启动速度优化 T2</a><br>\n<a href=\"https://blog.csdn.net/huangliniqng/article/details/89364064\" target=\"_blank\">具体代码流程</a></p>\n<ol>\n<li>Launcher通知AMS, 要启动某一应用,并说明对应的LauncherActivity</li>\n<li>AMS表示收到, 等待Launcher进入Pause状态</li>\n<li>Launcher进入Pause状态, 通知AMS可以启动某一应用了</li>\n<li>AMS开始检查某一应用是否启动\n<ul>\n<li>是,则直接启动,流程终止</li>\n<li>否,AMS则在的进程中创建ActivityThread对象,并启动main函数</li>\n</ul>\n</li>\n<li>某一应用通知AMS启动准备就绪</li>\n<li>AMS通知某一应用要启动的页面,某一应用启动对应页面</li>\n</ol>\n<p><img src=\"https://z3.ax1x.com/2021/10/27/57Z1PJ.png\" alt=\"57Z1PJ.png\" loading=\"lazy\" class=\"φbp\"></p>\n<h3 id=\"启动分类\">启动分类<a title=\"#启动分类\" href=\"#启动分类\"></a></h3>\n<ul>\n<li>冷启动\n<ul>\n<li>耗时最多,优化重点</li>\n<li><img src=\"https://z3.ax1x.com/2021/10/27/57ZxJJ.png\" alt=\"57ZxJJ.png\" loading=\"lazy\" class=\"φbp\"></li>\n</ul>\n</li>\n<li>热启动\n<ul>\n<li>最快.即后台到前台的切换</li>\n</ul>\n</li>\n<li>温启动\n<ul>\n<li>较快,只重走Activity的生命周期,即销毁后重建</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"耗时统计\">耗时统计<a title=\"#耗时统计\" href=\"#耗时统计\"></a></h3>\n<h4 id=\"systrace\">Systrace<a title=\"#systrace\" href=\"#systrace\"></a></h4>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TraceCompat.beginSection(<span class=\"string\">&quot;sectionName&quot;</span>)</span><br><span class=\"line\">TraceCompat.endSection();</span><br></pre></td></tr></table></figure>\n<p><code>python systrace.py -t 10 [other-options] [categories]</code></p>\n<h4 id=\"traceview\">Traceview<a title=\"#traceview\" href=\"#traceview\"></a></h4>\n<p><img src=\"https://z3.ax1x.com/2021/10/27/57llge.png\" alt=\"57llge.png\" loading=\"lazy\" class=\"φbp\"></p>\n<p>使用方式</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Debug.startMethodTracing(<span class=\"string\">&quot;fileName&quot;</span>)</span><br><span class=\"line\">Debug.stopMethodTracing()</span><br></pre></td></tr></table></figure>\n<p>运行之后可以在目录下生成文件：内部存储/android/data/${application}/files/fileName.trace，此文件可以使用Android Studio Profile打开</p>\n<ul>\n<li>Wall Clock time : 是线程真正执行的时间</li>\n<li>Thread time : CPU执行的时间,比Wall Clock Time少,不包含锁时间,等待时间</li>\n<li>Top Down:就是函数的调用列表</li>\n<li>Call Chart: 系统Api黄色，应用调用的方法绿色，第三方Api(java sdk也属于第三方)蓝色</li>\n<li>Flame Chart:  主要的作用是收集调用方法的时间，比如多次调用LayoutInflate.inflate，Flame Chart会把他们都收集到一起。</li>\n<li>Bottom Up: 和Top Down是相反的</li>\n</ul>\n<h4 id=\"adb-命令统计\">Adb 命令统计<a title=\"#adb-命令统计\" href=\"#adb-命令统计\"></a></h4>\n<p><code>adb shell am start -S -W 包名/启动类的全限定名</code></p>\n<p>ThisTime : 最后一个 Activity 的启动耗时<br>\nTotalTime : 启动一连串的 Activity 总耗时<br>\nWaitTime : 应用进程的创建过程 + TotalTime</p>\n<h4 id=\"系统日志统计\">系统日志统计<a title=\"#系统日志统计\" href=\"#系统日志统计\"></a></h4>\n<p>过滤<code>displayed</code>输出的启动日志</p>\n<p><img src=\"https://z3.ax1x.com/2021/10/27/57mU4e.png\" alt=\"57mU4e.png\" loading=\"lazy\" class=\"φbp\"></p>\n<h3 id=\"冷启动优化\">冷启动优化<a title=\"#冷启动优化\" href=\"#冷启动优化\"></a></h3>\n<p><a href=\"https://jishuin.proginn.com/p/763bfbd345f0\" target=\"_blank\"> App 启动时间优化详解</a></p>\n<p>优化方向:</p>\n<ul>\n<li>延迟加载 / 懒加载</li>\n<li>异步线程执行耗时操作，如图片加载、网络访问、IO操作等</li>\n<li>ViewStub的使用</li>\n<li>减少布局层次和嵌套布局</li>\n</ul>\n",
            "tags": [
                "性能优化"
            ]
        }
    ]
}