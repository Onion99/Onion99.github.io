{
    "version": "https://jsonfeed.org/version/1",
    "title": "Stay hungry , Stay foolish",
    "description": "巴拉巴拉",
    "home_page_url": "https://onion99.github.io",
    "items": [
        {
            "id": "https://onion99.github.io/2022/03/02/uVaapTCHAYrYDaHP/",
            "url": "https://onion99.github.io/2022/03/02/uVaapTCHAYrYDaHP/",
            "title": "源码学习-Lifecycle",
            "date_published": "2022-03-01T17:33:23.000Z",
            "content_html": "<p>![bQ1f9s.png](<img src=\"https://developer.android.google.cn/images/topic/libraries/architecture/lifecycle-states.svg\" alt=\"生命周期状态示意图\" loading=\"lazy\"></p>\n<blockquote>\n<p>Jetpack Lifecycle 提供了可用于构建生命周期感知型组件的类和接口,从而根据 Activity 或 Fragment 的当前生命周期状态自动调整其行为,记住我们要解析的是Jet Pack Lifecycle ,而不是 原有Activity/Fragment的生命周期流程</p>\n</blockquote>\n<h3 id=\"使用\">使用<a title=\"#使用\" href=\"#使用\"></a></h3>\n<h4 id=\"通过-defaultlifecycleobserver-实现\">通过 DefaultLifecycleObserver 实现<a title=\"#通过-defaultlifecycleobserver-实现\" href=\"#通过-defaultlifecycleobserver-实现\"></a></h4>\n<blockquote>\n<p>类可以通过实现 DefaultLifecycleObserver 并替换相应的方法（如 onCreate 和 onStart 等）来监控组件的生命周期状态。然后，您可以通过调用 Lifecycle 类的 addObserver() 方法并传递观察器的实例来添加观察器</p>\n</blockquote>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 构建生命周期感知型组件</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyObserver</span> : <span class=\"type\">DefaultLifecycleObserver &#123;</span></span></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onResume</span><span class=\"params\">(owner: <span class=\"type\">LifecycleOwner</span>)</span></span> &#123;</span><br><span class=\"line\">        connect() <span class=\"comment\">// 在页面 onResume 时连接</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onPause</span><span class=\"params\">(owner: <span class=\"type\">LifecycleOwner</span>)</span></span> &#123;</span><br><span class=\"line\">        disconnect() <span class=\"comment\">// 在页面 onStop 时连接</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 添加生命周期观察器</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyActivity</span> : <span class=\"type\">AppCompatActivity</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onCreate</span><span class=\"params\">(...)</span></span> &#123;</span><br><span class=\"line\">\t    myLifecycleOwner.getLifecycle().addObserver(MyObserver())</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"通过注解实现licecycle-observer\">通过注解实现Licecycle Observer<a title=\"#通过注解实现licecycle-observer\" href=\"#通过注解实现licecycle-observer\"></a></h4>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ILifecycleObserver</span> : <span class=\"type\">LifecycleObserver &#123;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@OnLifecycleEvent(Lifecycle.Event.ON_CREATE)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onCreate</span><span class=\"params\">(owner: <span class=\"type\">LifecycleOwner</span>)</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@OnLifecycleEvent(Lifecycle.Event.ON_START)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onStart</span><span class=\"params\">(owner: <span class=\"type\">LifecycleOwner</span>)</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@OnLifecycleEvent(Lifecycle.Event.ON_RESUME)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onResume</span><span class=\"params\">(owner: <span class=\"type\">LifecycleOwner</span>)</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@OnLifecycleEvent(Lifecycle.Event.ON_PAUSE)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onPause</span><span class=\"params\">(owner: <span class=\"type\">LifecycleOwner</span>)</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@OnLifecycleEvent(Lifecycle.Event.ON_STOP)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onStop</span><span class=\"params\">(owner: <span class=\"type\">LifecycleOwner</span>)</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@OnLifecycleEvent(Lifecycle.Event.ON_DESTROY)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onDestroy</span><span class=\"params\">(owner: <span class=\"type\">LifecycleOwner</span>)</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@OnLifecycleEvent(Lifecycle.Event.ON_ANY)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onLifecycleChanged</span><span class=\"params\">(owner: <span class=\"type\">LifecycleOwner</span>, event: <span class=\"type\">Lifecycle</span>.<span class=\"type\">Event</span>)</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyObserver</span> : <span class=\"type\">ILifecycleObserver &#123;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onCreate</span><span class=\"params\">(owner: <span class=\"type\">LifecycleOwner</span>)</span></span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onStart</span><span class=\"params\">(owner: <span class=\"type\">LifecycleOwner</span>)</span></span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onResume</span><span class=\"params\">(owner: <span class=\"type\">LifecycleOwner</span>)</span></span> &#123;</span><br><span class=\"line\">        connect() <span class=\"comment\">// 在页面 onResume 时连接</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onPause</span><span class=\"params\">(owner: <span class=\"type\">LifecycleOwner</span>)</span></span> &#123;</span><br><span class=\"line\">        disconnect() <span class=\"comment\">// 在页面 onStop 时连接</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onStop</span><span class=\"params\">(owner: <span class=\"type\">LifecycleOwner</span>)</span></span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onDestroy</span><span class=\"params\">(owner: <span class=\"type\">LifecycleOwner</span>)</span></span> &#123;&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onLifecycleChanged</span><span class=\"params\">(owner: <span class=\"type\">LifecycleOwner</span>, event: <span class=\"type\">Lifecycle</span>.<span class=\"type\">Event</span>)</span></span> &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"解析\">解析<a title=\"#解析\" href=\"#解析\"></a></h3>\n<h4 id=\"class组成\">Class组成<a title=\"#class组成\" href=\"#class组成\"></a></h4>\n<ol>\n<li>首先我们得知道Activity/Fragment是如何实现LifecycleOwner的</li>\n</ol>\n<p>LifecycleOwner:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">LifecycleOwner</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Returns the Lifecycle of the provider.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@NonNull</span></span><br><span class=\"line\">    <span class=\"function\">Lifecycle <span class=\"title\">getLifecycle</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到Fragment 和Activity都实现了相关的LifecycleOwner接口</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Fragment</span> <span class=\"keyword\">implements</span> <span class=\"title\">ComponentCallbacks</span>, <span class=\"title\">OnCreateContextMenuListener</span>, <span class=\"title\">LifecycleOwner</span>,</span></span><br><span class=\"line\"><span class=\"class\">        <span class=\"title\">ViewModelStoreOwner</span>, <span class=\"title\">HasDefaultViewModelProviderFactory</span>, <span class=\"title\">SavedStateRegistryOwner</span>,</span></span><br><span class=\"line\"><span class=\"class\">        <span class=\"title\">ActivityResultCaller</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    LifecycleRegistry mLifecycleRegistry;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">initLifecycle</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        mLifecycleRegistry = <span class=\"keyword\">new</span> LifecycleRegistry(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Lifecycle <span class=\"title\">getLifecycle</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mLifecycleRegistry;</span><br><span class=\"line\">    &#125;    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">        </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ComponentActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">androidx</span>.<span class=\"title\">core</span>.<span class=\"title\">app</span>.<span class=\"title\">ComponentActivity</span> <span class=\"keyword\">implements</span></span></span><br><span class=\"line\"><span class=\"class\">        <span class=\"title\">ContextAware</span>,</span></span><br><span class=\"line\"><span class=\"class\">        <span class=\"title\">LifecycleOwner</span>,</span></span><br><span class=\"line\"><span class=\"class\">        <span class=\"title\">ViewModelStoreOwner</span>,</span></span><br><span class=\"line\"><span class=\"class\">        <span class=\"title\">HasDefaultViewModelProviderFactory</span>,</span></span><br><span class=\"line\"><span class=\"class\">        <span class=\"title\">SavedStateRegistryOwner</span>,</span></span><br><span class=\"line\"><span class=\"class\">        <span class=\"title\">OnBackPressedDispatcherOwner</span>,</span></span><br><span class=\"line\"><span class=\"class\">        <span class=\"title\">ActivityResultRegistryOwner</span>,</span></span><br><span class=\"line\"><span class=\"class\">        <span class=\"title\">ActivityResultCaller</span> </span>&#123;&#125; </span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>明确LifecycleRegistry主要作用</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 定义一个具有 Android 生命周期的对象 */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Lifecycle</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@MainThread</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">addObserver</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> LifecycleObserver observer)</span></span>;</span><br><span class=\"line\">    <span class=\"meta\">@MainThread</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">removeObserver</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> LifecycleObserver observer)</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">// 生命周期事件,表明已被分发的生命周期事件,映射到Activity和Fragment中的回调事件 </span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">Event</span> </span>&#123;</span><br><span class=\"line\">        ON_CREATE,ON_START,ON_RESUME,ON_PAUSE,ON_STOP,ON_DESTROY,ON_ANY;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 生命周期状态,表明组件的当前状态</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">State</span> </span>&#123;</span><br><span class=\"line\">        DESTROYED,INITIALIZED,CREATED,STARTED,RESUMED;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 可以处理多个Observer的Lifecycle实现,Fragment和Activity使用 */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LifecycleRegistry</span> <span class=\"keyword\">extends</span> <span class=\"title\">Lifecycle</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">LifecycleRegistry</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> LifecycleOwner provider, <span class=\"keyword\">boolean</span> enforceMainThread)</span> </span>&#123;</span><br><span class=\"line\">        mLifecycleOwner = <span class=\"keyword\">new</span> WeakReference&lt;&gt;(provider);</span><br><span class=\"line\">        mState = INITIALIZED;</span><br><span class=\"line\">        mEnforceMainThread = enforceMainThread;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>到这里我们就可以大致这么认为了, LifecycleOwner 通过获取当前对应的 LifecycleRegistry  管理多个LicecycleObserver,然后在生命周期状态发生变化时,处理不同状态事件的分放</li>\n</ol>\n<h4 id=\"activity-是如何实现jetpack-lifecycle事件分放的?\">Activity 是如何实现Jetpack Lifecycle事件分放的?<a title=\"#activity-是如何实现jetpack-lifecycle事件分放的?\" href=\"#activity-是如何实现jetpack-lifecycle事件分放的?\"></a></h4>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> androidx.core.app;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ComponentActivity</span> <span class=\"title\">extends</span> <span class=\"title\">Activity</span> <span class=\"title\">implements</span> <span class=\"title\">LifecycleOwner</span>,<span class=\"type\">KeyEventDispatcher.Component &#123;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> LifecycleRegistry mLifecycleRegistry = new LifecycleRegistry(<span class=\"keyword\">this</span>); <span class=\"comment\">//1</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">protected</span> void onCreate(<span class=\"meta\">@Nullable</span> Bundle savedInstanceState) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\">        ReportFragment.injectIfNeededIn(<span class=\"keyword\">this</span>); <span class=\"comment\">// 3</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Lifecycle getLifecycle() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mLifecycleRegistry; <span class=\"comment\">// 2</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意看ReportFragment:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReportFragment</span> <span class=\"keyword\">extends</span> <span class=\"title\">Fragment</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String REPORT_FRAGMENT_TAG = <span class=\"string\">&quot;androidx.lifecycle&quot;</span></span><br><span class=\"line\">            + <span class=\"string\">&quot;.LifecycleDispatcher.report_fragment_tag&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">injectIfNeededIn</span><span class=\"params\">(Activity activity)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Build.VERSION.SDK_INT &gt;= <span class=\"number\">29</span>) &#123;</span><br><span class=\"line\">         activity.registerActivityLifecycleCallbacks(<span class=\"keyword\">new</span> LifecycleCallbacks());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">       </span><br><span class=\"line\">        android.app.FragmentManager manager = activity.getFragmentManager();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (manager.findFragmentByTag(REPORT_FRAGMENT_TAG) == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            manager.beginTransaction().add(<span class=\"keyword\">new</span> ReportFragment(), REPORT_FRAGMENT_TAG).commit();</span><br><span class=\"line\">            <span class=\"comment\">// Hopefully, we are the first to make a transaction.</span></span><br><span class=\"line\">            manager.executePendingTransactions();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@SuppressWarnings(&quot;deprecation&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">dispatch</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Activity activity, <span class=\"meta\">@NonNull</span> Lifecycle.Event event)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//已经被标注为@Deprecated</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (activity <span class=\"keyword\">instanceof</span> LifecycleRegistryOwner) &#123;</span><br><span class=\"line\">            ((LifecycleRegistryOwner) activity).getLifecycle().handleLifecycleEvent(event);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (activity <span class=\"keyword\">instanceof</span> LifecycleOwner) &#123;</span><br><span class=\"line\">            Lifecycle lifecycle = ((LifecycleOwner) activity).getLifecycle();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (lifecycle <span class=\"keyword\">instanceof</span> LifecycleRegistry) &#123;</span><br><span class=\"line\">                ((LifecycleRegistry) lifecycle).handleLifecycleEvent(event);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> ReportFragment <span class=\"title\">get</span><span class=\"params\">(Activity activity)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (ReportFragment) activity.getFragmentManager().findFragmentByTag(</span><br><span class=\"line\">                REPORT_FRAGMENT_TAG);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onActivityCreated</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onActivityCreated(savedInstanceState);</span><br><span class=\"line\">        dispatchCreate(mProcessListener);</span><br><span class=\"line\">        dispatch(Lifecycle.Event.ON_CREATE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onStart</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onStart();</span><br><span class=\"line\">        dispatchStart(mProcessListener);</span><br><span class=\"line\">        dispatch(Lifecycle.Event.ON_START);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onResume</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onResume();</span><br><span class=\"line\">        dispatchResume(mProcessListener);</span><br><span class=\"line\">        dispatch(Lifecycle.Event.ON_RESUME);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onPause</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onPause();</span><br><span class=\"line\">        dispatch(Lifecycle.Event.ON_PAUSE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onStop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onStop();</span><br><span class=\"line\">        dispatch(Lifecycle.Event.ON_STOP);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onDestroy</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onDestroy();</span><br><span class=\"line\">        dispatch(Lifecycle.Event.ON_DESTROY);</span><br><span class=\"line\">        <span class=\"comment\">// just want to be sure that we won&#x27;t leak reference to an activity</span></span><br><span class=\"line\">        mProcessListener = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">dispatch</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Lifecycle.Event event)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Build.VERSION.SDK_INT &lt; <span class=\"number\">29</span>) &#123;</span><br><span class=\"line\">            dispatch(getActivity(), event);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//API29及以上直接使用Application.ActivityLifecycleCallbacks来监听生命周期</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LifecycleCallbacks</span> <span class=\"keyword\">implements</span> <span class=\"title\">Application</span>.<span class=\"title\">ActivityLifecycleCallbacks</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onActivityCreated</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Activity activity,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                <span class=\"meta\">@Nullable</span> Bundle bundle)</span> </span>&#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onActivityPostCreated</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Activity activity,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                <span class=\"meta\">@Nullable</span> Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">            dispatch(activity, Lifecycle.Event.ON_CREATE);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onActivityStarted</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Activity activity)</span> </span>&#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onActivityPostStarted</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Activity activity)</span> </span>&#123;</span><br><span class=\"line\">            dispatch(activity, Lifecycle.Event.ON_START);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onActivityResumed</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Activity activity)</span> </span>&#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onActivityPostResumed</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Activity activity)</span> </span>&#123;</span><br><span class=\"line\">            dispatch(activity, Lifecycle.Event.ON_RESUME);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onActivityPrePaused</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Activity activity)</span> </span>&#123;</span><br><span class=\"line\">            dispatch(activity, Lifecycle.Event.ON_PAUSE);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onActivityPaused</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Activity activity)</span> </span>&#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onActivityPreStopped</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Activity activity)</span> </span>&#123;</span><br><span class=\"line\">            dispatch(activity, Lifecycle.Event.ON_STOP);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onActivityStopped</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Activity activity)</span> </span>&#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onActivitySaveInstanceState</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Activity activity,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                <span class=\"meta\">@NonNull</span> Bundle bundle)</span> </span>&#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onActivityPreDestroyed</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Activity activity)</span> </span>&#123;</span><br><span class=\"line\">            dispatch(activity, Lifecycle.Event.ON_DESTROY);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onActivityDestroyed</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Activity activity)</span> </span>&#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过一个透明的Fragment来分发生命周期事件，这样对于Activity来说是无侵入的。分成两部分逻辑：</p>\n<ul>\n<li>当API&gt;=29时，直接使用Application.ActivityLifecycleCallbacks来分发生命周期事件</li>\n<li>而当API&lt;29时，在Fragment的生命周期回调中进行了事件分发。<br>\n但殊途同归，两者最终都会走到<code>dispatch(Activity activity, Lifecycle.Event event)</code>方法</li>\n</ul>\n<h4 id=\"lifecycleobserver-是如何被响应的?\">LifecycleObserver 是如何被响应的?<a title=\"#lifecycleobserver-是如何被响应的?\" href=\"#lifecycleobserver-是如何被响应的?\"></a></h4>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 1 */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReportFragment</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 事件分发</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">dispatch</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Activity activity, <span class=\"meta\">@NonNull</span> Lifecycle.Event event)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (activity <span class=\"keyword\">instanceof</span> LifecycleRegistryOwner) &#123;</span><br><span class=\"line\">            ((LifecycleRegistryOwner) activity).getLifecycle().handleLifecycleEvent(event);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (activity <span class=\"keyword\">instanceof</span> LifecycleOwner) &#123;</span><br><span class=\"line\">            Lifecycle lifecycle = ((LifecycleOwner) activity).getLifecycle();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (lifecycle <span class=\"keyword\">instanceof</span> LifecycleRegistry) &#123;</span><br><span class=\"line\">                ((LifecycleRegistry) lifecycle).handleLifecycleEvent(event);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/* 2 */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LifecycleRegistry</span> <span class=\"keyword\">extends</span> <span class=\"title\">Lifecycle</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 2.1-处理生命周期事件</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleLifecycleEvent</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Lifecycle.Event event)</span> </span>&#123;</span><br><span class=\"line\">        enforceMainThreadIfNeeded(<span class=\"string\">&quot;handleLifecycleEvent&quot;</span>);</span><br><span class=\"line\">        moveToState(event.getTargetState());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 2.2-判断生命周期状态</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">moveToState</span><span class=\"params\">(State next)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mState == next) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        mState = next;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mHandlingEvent || mAddingObserverCounter != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            mNewEventOccurred = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            <span class=\"comment\">// we will figure out what to do on upper level.</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        mHandlingEvent = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        sync();</span><br><span class=\"line\">        mHandlingEvent = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 2-3 同步状态至LifecycleObserver</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">sync</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        LifecycleOwner lifecycleOwner = mLifecycleOwner.get();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (lifecycleOwner == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">&quot;LifecycleOwner of this LifecycleRegistry is already&quot;</span></span><br><span class=\"line\">                    + <span class=\"string\">&quot;garbage collected. It is too late to change lifecycle state.&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!isSynced()) &#123;</span><br><span class=\"line\">            mNewEventOccurred = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            <span class=\"comment\">// no need to check eldest for nullability, because isSynced does it for us.</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mState.compareTo(mObserverMap.eldest().getValue().mState) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                backwardPass(lifecycleOwner);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            Entry&lt;LifecycleObserver, ObserverWithState&gt; newest = mObserverMap.newest();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!mNewEventOccurred &amp;&amp; newest != <span class=\"keyword\">null</span></span><br><span class=\"line\">                    &amp;&amp; mState.compareTo(newest.getValue().mState) &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                forwardPass(lifecycleOwner);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        mNewEventOccurred = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">forwardPass</span><span class=\"params\">(LifecycleOwner lifecycleOwner)</span> </span>&#123;</span><br><span class=\"line\">        Iterator&lt;Entry&lt;LifecycleObserver, ObserverWithState&gt;&gt; ascendingIterator =</span><br><span class=\"line\">                mObserverMap.iteratorWithAdditions();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (ascendingIterator.hasNext() &amp;&amp; !mNewEventOccurred) &#123;</span><br><span class=\"line\">            Entry&lt;LifecycleObserver, ObserverWithState&gt; entry = ascendingIterator.next();</span><br><span class=\"line\">            ObserverWithState observer = entry.getValue();</span><br><span class=\"line\">            <span class=\"keyword\">while</span> ((observer.mState.compareTo(mState) &lt; <span class=\"number\">0</span> &amp;&amp; !mNewEventOccurred</span><br><span class=\"line\">                    &amp;&amp; mObserverMap.contains(entry.getKey()))) &#123;</span><br><span class=\"line\">                pushParentState(observer.mState);</span><br><span class=\"line\">                <span class=\"keyword\">final</span> Event event = Event.upFrom(observer.mState);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (event == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">&quot;no event up from &quot;</span> + observer.mState);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                observer.dispatchEvent(lifecycleOwner, event);</span><br><span class=\"line\">                popParentState();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">backwardPass</span><span class=\"params\">(LifecycleOwner lifecycleOwner)</span> </span>&#123;</span><br><span class=\"line\">        Iterator&lt;Entry&lt;LifecycleObserver, ObserverWithState&gt;&gt; descendingIterator =</span><br><span class=\"line\">                mObserverMap.descendingIterator();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (descendingIterator.hasNext() &amp;&amp; !mNewEventOccurred) &#123;</span><br><span class=\"line\">            Entry&lt;LifecycleObserver, ObserverWithState&gt; entry = descendingIterator.next();</span><br><span class=\"line\">            ObserverWithState observer = entry.getValue();</span><br><span class=\"line\">            <span class=\"keyword\">while</span> ((observer.mState.compareTo(mState) &gt; <span class=\"number\">0</span> &amp;&amp; !mNewEventOccurred</span><br><span class=\"line\">                    &amp;&amp; mObserverMap.contains(entry.getKey()))) &#123;</span><br><span class=\"line\">                Event event = Event.downFrom(observer.mState);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (event == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">&quot;no event down from &quot;</span> + observer.mState);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                pushParentState(event.getTargetState());</span><br><span class=\"line\">                observer.dispatchEvent(lifecycleOwner, event);</span><br><span class=\"line\">                popParentState();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"refer\">Refer<a title=\"#refer\" href=\"#refer\"></a></h3>\n<p><a href=\"https://www.mo4tech.com/analysis-of-the-basic-use-and-rationale-of-android-jetpack-component-lifecycle.html\" target=\"_blank\">Analysis of the basic use and rationale of Android Jetpack component Lifecycle - Moment For Technology (mo4tech.com)</a></p>\n<p><a href=\"https://blog.csdn.net/u013700502/article/details/118469311\" target=\"_blank\">Android Jetpack系列之Lifecycle_小马快跑的博客-CSDN博客_android中lifecycle</a></p>\n",
            "tags": [
                "源码解析"
            ]
        },
        {
            "id": "https://onion99.github.io/2021/11/30/9S5c1rplpdSAbIxR/",
            "url": "https://onion99.github.io/2021/11/30/9S5c1rplpdSAbIxR/",
            "title": "源码学习-ViewModel",
            "date_published": "2021-11-29T23:30:53.000Z",
            "content_html": "<p>首先看看ViewModel是怎么样实例化</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">open</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;T : ViewModel?&gt;</span> <span class=\"title\">getFragmentScopeViewModel</span><span class=\"params\">(modelClass: <span class=\"type\">Class</span>&lt;<span class=\"type\">T</span>&gt;)</span></span>: T &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!::fragmentProvider.isInitialized) &#123;</span><br><span class=\"line\">        fragmentProvider = ViewModelProvider(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fragmentProvider.<span class=\"keyword\">get</span>(modelClass)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">open</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;T : ViewModel?&gt;</span> <span class=\"title\">getActivityScopeViewModel</span><span class=\"params\">(modelClass: <span class=\"type\">Class</span>&lt;<span class=\"type\">T</span>&gt;)</span></span>: T &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!::activityProvider.isInitialized) &#123;</span><br><span class=\"line\">        activityProvider = ViewModelProvider(requireActivity())</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> activityProvider.<span class=\"keyword\">get</span>(modelClass)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我超,原来是通过一个ViewModelProvider去get到的,他妈的这是干什么的呢,为什么要通过ViewModelProvider获取呢<br>\n<img src=\"http://img.doutula.com/production/uploads/image/2019/06/06/20190606755268_TSvBec.jpg\" alt=\"\" loading=\"lazy\"><br>\n我怎么知道,瞧瞧官方正儿八经的回答吧<br>\n<code>ViewModel</code>:旨在以注重生命周期的方式存储和管理界面相关的数据。ViewModel 类让数据可在发生屏幕旋转等配置更改后继续留存<br>\n<code>ViewModelProvider</code>: ViewModel的辅助程序类，该类负责为界面准备数据。在配置更改期间会自动保留 ViewModel 对象，以便它们存储的数据立即可供下一个 activity 或 fragment 实例使用</p>\n<span id=\"more\"></span>\n<p>好家伙,原来是这对组合,以生命周期的方式耶,看看有什么不同</p>\n<h3 id=\"activty与viewmodel的生命周期\">Activty与ViewModel的生命周期<a title=\"#activty与viewmodel的生命周期\" href=\"#activty与viewmodel的生命周期\"></a></h3>\n<blockquote>\n<p>牛逼,战斗直至Finish</p>\n</blockquote>\n<p><img src=\"https://z3.ax1x.com/2021/11/08/I8L0jU.png\" alt=\"I8L0jU.png\" loading=\"lazy\" class=\"φbp\"></p>\n<p>官方说:ViewModel对象存在的时间范围是获取 ViewModel 时传递给 ViewModelProvider 的Lifecycle。ViewModel将一直留在内存中，直到限定其存在时间范围的Lifecycle永久消失：<br>\n对于activity，是在activity完成时；<br>\n对于fragment，是在 fragment分离时</p>\n<p>好了,来看看ViewModelProvider是怎样实现构造的</p>\n<h3 id=\"viewmodelprovider()\">ViewModelProvider()<a title=\"#viewmodelprovider()\" href=\"#viewmodelprovider()\"></a></h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ViewModelProvider</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> ViewModelStoreOwner owner)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 尼玛的,偷偷调用另一构造函数</span></span><br><span class=\"line\">        <span class=\"comment\">// 1.创建用来存储ViewModel的ViewModelStore, 2. 创建用于实例化新ViewModel的Factory</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>(owner.getViewModelStore(), owner <span class=\"keyword\">instanceof</span> HasDefaultViewModelProviderFactory</span><br><span class=\"line\">                ? ((HasDefaultViewModelProviderFactory) owner).getDefaultViewModelProviderFactory()</span><br><span class=\"line\">                : NewInstanceFactory.getInstance());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"viewmodelstore\">ViewModelStore<a title=\"#viewmodelstore\" href=\"#viewmodelstore\"></a></h4>\n<p>这个是接口何许玩意,原来到后面Activity,Fragment等都实现了这个接口,以来获取跟当前生命周期相关的ViewModelStore,看到没有,有图有真相<br>\n<img src=\"https://z3.ax1x.com/2021/11/08/I8xIk4.png\" alt=\"I8xIk4.png\" loading=\"lazy\"><br>\n看看<code>ComponentActivity.getViewModelStore()</code>:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ViewModelStore <span class=\"title\">getViewModelStore</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (getApplication() == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">&quot;Your activity is not yet attached to the &quot;</span></span><br><span class=\"line\">                + <span class=\"string\">&quot;Application instance. You can&#x27;t request ViewModel before onCreate call.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 叉,这里照我猜想肯定是实现ViewModelStore的单例</span></span><br><span class=\"line\">    ensureViewModelStore();</span><br><span class=\"line\">    <span class=\"comment\">// 返回与此Activity关联的ViewModelStore</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> mViewModelStore;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//...</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">ensureViewModelStore</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mViewModelStore == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 检索先前由onRetainNonConfigurationInstance()返回的配置变更后的缓存配置</span></span><br><span class=\"line\">        NonConfigurationInstances nc = (NonConfigurationInstances) getLastNonConfigurationInstance();</span><br><span class=\"line\">        <span class=\"comment\">// 如果缓存配置不为空,则取缓存配置的viewModelStore</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nc != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            mViewModelStore = nc.viewModelStore;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 否则自己实例一个</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mViewModelStore == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            mViewModelStore = <span class=\"keyword\">new</span> ViewModelStore();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;    </span><br></pre></td></tr></table></figure>\n<p>嘿嘿,存储ViewModel的ViewModelStore,牛逼啊,用一个HashMap来缓存看到有木有:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ViewModelStore</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> HashMap&lt;String, ViewModel&gt; mMap = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">put</span><span class=\"params\">(String key, ViewModel viewModel)</span> </span>&#123;</span><br><span class=\"line\">        ViewModel oldViewModel = mMap.put(key, viewModel);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (oldViewModel != <span class=\"keyword\">null</span>) oldViewModel.onCleared();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">final</span> ViewModel <span class=\"title\">get</span><span class=\"params\">(String key)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mMap.get(key);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">Set&lt;String&gt; <span class=\"title\">keys</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> HashSet&lt;&gt;(mMap.keySet());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">clear</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (ViewModel vm : mMap.values()) &#123;</span><br><span class=\"line\">            vm.clear();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        mMap.clear();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://z3.ax1x.com/2021/11/08/IG8UgA.png\" alt=\"IG8UgA.png\" loading=\"lazy\" class=\"φbp\"></p>\n<h4 id=\"viewmodelproviderfactory\">ViewModelProviderFactory<a title=\"#viewmodelproviderfactory\" href=\"#viewmodelproviderfactory\"></a></h4>\n<p>同样的后面Activity,Fragment等也实现了HasDefaultViewModelProviderFactory接口,实现自己创建ViewModel的ViewModelProviderFactory, 来看图<br>\n<img src=\"https://z3.ax1x.com/2021/11/08/IGEOT1.png\" alt=\"IGEOT1.png\" loading=\"lazy\"><br>\n再来看看<code>ComponentActivity.getViewModelStore()</code>:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> ViewModelProvider.<span class=\"function\">Factory <span class=\"title\">getDefaultViewModelProviderFactory</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (getApplication() == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">&quot;Your activity is not yet attached to the &quot;</span></span><br><span class=\"line\">                + <span class=\"string\">&quot;Application instance. You can&#x27;t request ViewModel before onCreate call.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 妈的,就是这么简单,直接实例化</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mDefaultFactory == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        mDefaultFactory = <span class=\"keyword\">new</span> SavedStateViewModelFactory(</span><br><span class=\"line\">                getApplication(),</span><br><span class=\"line\">                <span class=\"keyword\">this</span>,</span><br><span class=\"line\">                getIntent() != <span class=\"keyword\">null</span> ? getIntent().getExtras() : <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> mDefaultFactory;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>有点东西,这样就实例<code>SavedStateViewModelFactory</code>了,看看具体怎么<code>get()</code>霍</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 第一步:小get</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;T extends ViewModel&gt; <span class=\"function\">T <span class=\"title\">get</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Class&lt;T&gt; modelClass)</span> </span>&#123;</span><br><span class=\"line\">    String canonicalName = modelClass.getCanonicalName();</span><br><span class=\"line\">    <span class=\"comment\">// 好家伙,看到没有,如果这里判断是局部类或者匿名类,就直接给crash了,谷歌就是牛逼</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (canonicalName == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">&quot;Local and anonymous classes can not be ViewModels&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 嘿,继续get下去</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> get(DEFAULT_KEY + <span class=\"string\">&quot;:&quot;</span> + canonicalName, modelClass);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 第二步:大get</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;T extends ViewModel&gt; <span class=\"function\">T <span class=\"title\">get</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> String key, <span class=\"meta\">@NonNull</span> Class&lt;T&gt; modelClass)</span> </span>&#123;</span><br><span class=\"line\">    ViewModel viewModel = mViewModelStore.get(key);</span><br><span class=\"line\">    <span class=\"comment\">// 首先是判断是否有缓存</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (modelClass.isInstance(viewModel)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mFactory <span class=\"keyword\">instanceof</span> OnRequeryFactory) &#123;</span><br><span class=\"line\">            ((OnRequeryFactory) mFactory).onRequery(viewModel);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (T) viewModel;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 然后如果为null,则通过具体工厂类去实例化ViewModel</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mFactory <span class=\"keyword\">instanceof</span> KeyedFactory) &#123;</span><br><span class=\"line\">        viewModel = ((KeyedFactory) mFactory).create(key, modelClass);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        viewModel = mFactory.create(modelClass);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 嘿嘿,放进缓存</span></span><br><span class=\"line\">    mViewModelStore.put(key, viewModel);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (T) viewModel;</span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"comment\">// ViewModel的实例化</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;T extends ViewModel&gt; <span class=\"function\">T <span class=\"title\">create</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> String key, <span class=\"meta\">@NonNull</span> Class&lt;T&gt; modelClass)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> isAndroidViewModel = AndroidViewModel.class.isAssignableFrom(modelClass);</span><br><span class=\"line\">    Constructor&lt;T&gt; constructor;</span><br><span class=\"line\">    <span class=\"comment\">// 通过反射,去找到当前ViewModel的构造函数</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isAndroidViewModel &amp;&amp; mApplication != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        constructor = findMatchingConstructor(modelClass, ANDROID_VIEWMODEL_SIGNATURE);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        constructor = findMatchingConstructor(modelClass, VIEWMODEL_SIGNATURE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (constructor == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mFactory.create(modelClass);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    SavedStateHandleController controller = SavedStateHandleController.create(</span><br><span class=\"line\">            mSavedStateRegistry, mLifecycle, key, mDefaultArgs);</span><br><span class=\"line\">    <span class=\"comment\">// 嘿嘿,调用构造函数,实例化        </span></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        T viewmodel;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isAndroidViewModel &amp;&amp; mApplication != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            viewmodel = constructor.newInstance(mApplication, controller.getHandle());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            viewmodel = constructor.newInstance(controller.getHandle());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        viewmodel.setTagIfAbsent(TAG_SAVED_STATE_HANDLE_CONTROLLER, controller);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> viewmodel;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (IllegalAccessException e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">&quot;Failed to access &quot;</span> + modelClass, e);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (InstantiationException e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">&quot;A &quot;</span> + modelClass + <span class=\"string\">&quot; cannot be instantiated.&quot;</span>, e);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (InvocationTargetException e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">&quot;An exception happened in constructor of &quot;</span></span><br><span class=\"line\">                + modelClass, e.getCause());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;   </span><br></pre></td></tr></table></figure>\n<h3 id=\"viewmodel的架构作用\">ViewModel的架构作用<a title=\"#viewmodel的架构作用\" href=\"#viewmodel的架构作用\"></a></h3>\n<p>向官方敬礼,懂不懂这张图的含金量,懂不懂MMVM<br>\n<img src=\"https://z3.ax1x.com/2021/11/08/IGd3ff.png\" alt=\"IGd3ff.png\" loading=\"lazy\"><br>\n<img src=\"https://z3.ax1x.com/2021/11/08/IGwfKg.png\" alt=\"IGwfKg.png\" loading=\"lazy\"></p>\n",
            "tags": [
                "源码解析"
            ]
        },
        {
            "id": "https://onion99.github.io/2021/11/30/4diQitvVwGPnicN5/",
            "url": "https://onion99.github.io/2021/11/30/4diQitvVwGPnicN5/",
            "title": "源码学习-HashMap",
            "date_published": "2021-11-29T23:28:47.000Z",
            "content_html": "<blockquote>\n<p>Map是什么,可以是一个键到值的Object,可以是一个键值对的集合, 是函数抽象的数学模型</p>\n</blockquote>\n<p>似不似?</p>\n<p>HashMap就是Map实现的佼佼者,它使用哈希表作为底层数据结构</p>\n<blockquote>\n<p>注意哦,作为性能的最上层,HashMap是不考虑线程安全的,这是上层人的优越,多线程情况下,可以选用<code>ConcurrentHashMap</code> &gt; <code>Collections.synchronizedMap(HashMap&lt;&gt;())</code></p>\n</blockquote>\n<span id=\"more\"></span>\n<h3 id=\"结构\">结构<a title=\"#结构\" href=\"#结构\"></a></h3>\n<blockquote>\n<p>当Node数组的长度大于8时,会转变红黑树来存储</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HashMap</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">AbstractMap</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Map</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt;, <span class=\"title\">Cloneable</span>, <span class=\"title\">Serializable</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 存储数据的Node数组,一枪秒了有木有,一看就是链表结构 </span></span><br><span class=\"line\">  <span class=\"keyword\">transient</span> Node&lt;K,V&gt;[] table;   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://z3.ax1x.com/2021/11/22/Iz66S0.png\" alt=\"Iz66S0.png\" loading=\"lazy\" class=\"φbp\"></p>\n<h3 id=\"解析\">解析<a title=\"#解析\" href=\"#解析\"></a></h3>\n<h4 id=\"hashmap()\">HashMap()<a title=\"#hashmap()\" href=\"#hashmap()\"></a></h4>\n<blockquote>\n<p>初始化部分主要决定当前容量(loadFactor ),以及存储的阀值(loadFactor)</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 最大容量，当两个构造函数中任何一个带参数的函数隐式指定较大的值时使用。必须是2的幂&lt;= 1&lt;&lt;30</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MAXIMUM_CAPACITY = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">30</span>;</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"comment\">// 默认扩容比例</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> DEFAULT_LOAD_FACTOR = <span class=\"number\">0.75f</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HashMap</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity)</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HashMap</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity, <span class=\"keyword\">float</span> loadFactor)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 针对煞笔的处理,不会真的有人给0吧</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (initialCapacity &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">&quot;Illegal initial capacity:&quot;</span> +initialCapacity);</span><br><span class=\"line\">    <span class=\"comment\">// 当前最大容量    </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY;</span><br><span class=\"line\">    <span class=\"comment\">// 判断扩容比例</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (loadFactor &lt;= <span class=\"number\">0</span> || Float.isNaN(loadFactor))</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">&quot;Illegal load factor: &quot;</span> +loadFactor);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.loadFactor = loadFactor;</span><br><span class=\"line\">    <span class=\"comment\">// 决定下一次调整容量的大小(临界值)</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 返回给定目标容量的2次幂大小</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">tableSizeFor</span><span class=\"params\">(<span class=\"keyword\">int</span> cap)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = cap - <span class=\"number\">1</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">2</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">4</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">8</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">16</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (n &lt; <span class=\"number\">0</span>) ? <span class=\"number\">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用指定的初始容量和默认的加载因子来初始化HashMap。这里应该注意的是，有时它不是您指定的初始容量。例如新HashMap (20,0.8);那么实际的初始容量是32，因为tablesize()方法严格要求初始容量增加到2的幂，只能是16、32、64、128</p>\n",
            "tags": [
                "源码解析"
            ]
        },
        {
            "id": "https://onion99.github.io/2021/11/30/hu0861X6Ltf32fYt/",
            "url": "https://onion99.github.io/2021/11/30/hu0861X6Ltf32fYt/",
            "title": "源码学习-DataBinding",
            "date_published": "2021-11-29T23:27:07.000Z",
            "content_html": "<h3 id=\"sameple\">Sameple<a title=\"#sameple\" href=\"#sameple\"></a></h3>\n<p>首先,我们来看看DataBinding使用:</p>\n<ol>\n<li>给layout文件套娃:</li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">layout</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">FrameLayout</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">androidx.viewpager.widget.ViewPager</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:id</span>=<span class=\"string\">&quot;@+id/home_pager&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">com.flyco.tablayout.SlidingTabLayout</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:id</span>=<span class=\"string\">&quot;@+id/home_tab&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">FrameLayout</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">layout</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>在Fragment或者View中获取binding对象</li>\n</ol>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">binding = DataBindingUtil.inflate(inflater,layoutRes,container,<span class=\"literal\">false</span>)</span><br></pre></td></tr></table></figure>\n<p>超,就是这么简单,来从<code>inflate</code>开始解析</p>\n<span id=\"more\"></span>\n<h3 id=\"databindingutil.inflate梳理\">DataBindingUtil.inflate梳理<a title=\"#databindingutil.inflate梳理\" href=\"#databindingutil.inflate梳理\"></a></h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T extends ViewDataBinding&gt; <span class=\"function\">T <span class=\"title\">inflate</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">        <span class=\"meta\">@NonNull</span> LayoutInflater inflater, <span class=\"keyword\">int</span> layoutId, <span class=\"meta\">@Nullable</span> ViewGroup parent,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">        <span class=\"keyword\">boolean</span> attachToParent, <span class=\"meta\">@Nullable</span> DataBindingComponent bindingComponent)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 检查康康是不是子layout附加到父layout,一般是false,因为如果为ture会导致子layout的layoutparams 失效</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> useChildren = parent != <span class=\"keyword\">null</span> &amp;&amp; attachToParent;</span><br><span class=\"line\">    <span class=\"comment\">// 上面一般为false,那这里一般也是零蛋啊</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> startChildren = useChildren ? parent.getChildCount() : <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 解析xml生成View,放空大脑就是这样,深究的话,我只能甩一篇郭神的文章了:https://blog.csdn.net/guolin_blog/article/details/12921889</span></span><br><span class=\"line\">    <span class=\"comment\">// 什么具体inflate是怎么样,不听不听王八念经</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> View view = inflater.inflate(layoutId, parent, attachToParent);</span><br><span class=\"line\">    <span class=\"comment\">// 嘿嘿,这里开始binding</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (useChildren) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> bindToAddedViews(bindingComponent, parent, startChildren, layoutId);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> bind(bindingComponent, view, layoutId);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> DataBinderMapper sMapper = <span class=\"keyword\">new</span> DataBinderMapperImpl();</span><br><span class=\"line\"><span class=\"keyword\">static</span> &lt;T extends ViewDataBinding&gt; <span class=\"function\">T <span class=\"title\">bind</span><span class=\"params\">(DataBindingComponent bindingComponent, View root,<span class=\"keyword\">int</span> layoutId)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 不理了,这里就拿到binding了,可以直接引用View了,停止思考</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (T) sMapper.getDataBinder(bindingComponent, root, layoutId);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>问题来了,它是怎么取得我要的DataBinding对象且又是怎么实现View绑定的?</p>\n<ol>\n<li>好,来康康,这个<code>DataBinderMapperImpl</code>,这是编译阶段下kapt自动生成的:</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> androidx.databinding;</span><br><span class=\"line\"><span class=\"comment\">// 好家伙,这里直接继承MergedDataBinderMapper </span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DataBinderMapperImpl</span> <span class=\"keyword\">extends</span> <span class=\"title\">MergedDataBinderMapper</span> </span>&#123;</span><br><span class=\"line\">  DataBinderMapperImpl() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 添加kapt下生成当前Module的DataBinderMapperImpl</span></span><br><span class=\"line\">    addMapper(<span class=\"keyword\">new</span> com.xxx.xxx.DataBinderMapperImpl());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"comment\">// 合并其他Mapper的DataBindingMapper </span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MergedDataBinderMapper</span> <span class=\"keyword\">extends</span> <span class=\"title\">DataBinderMapper</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Set&lt;Class&lt;? extends DataBinderMapper&gt;&gt; mExistingMappers = <span class=\"keyword\">new</span> HashSet&lt;&gt;();</span><br><span class=\"line\">    <span class=\"comment\">// 添加Mapper,如果已经存在则忽略</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addMapper</span><span class=\"params\">(DataBinderMapper mapper)</span> </span>&#123;</span><br><span class=\"line\">        Class&lt;? extends DataBinderMapper&gt; mapperClass = mapper.getClass();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mExistingMappers.add(mapperClass)) &#123;</span><br><span class=\"line\">            mMappers.add(mapper);</span><br><span class=\"line\">            <span class=\"keyword\">final</span> List&lt;DataBinderMapper&gt; dependencies = mapper.collectDependencies();</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(DataBinderMapper dependency : dependencies) &#123;</span><br><span class=\"line\">                addMapper(dependency);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li><code>MergedDataBinderMapper.getDataBinder</code>:</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ViewDataBinding <span class=\"title\">getDataBinder</span><span class=\"params\">(DataBindingComponent bindingComponent, View view,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">        <span class=\"keyword\">int</span> layoutId)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 遍历之前添加的mMappers    </span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(DataBinderMapper mapper : mMappers) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 好了,这里获取对应的Mapper的DataBinder,超,想想之前添加了哪个Mapper</span></span><br><span class=\"line\">        <span class=\"comment\">// 没错,不正好对上tmd的上面1的com.xxx.xxx.DataBinderMapperImpl()</span></span><br><span class=\"line\">        ViewDataBinding result = mapper.getDataBinder(bindingComponent, view, layoutId);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (result != <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (loadFeatures()) <span class=\"keyword\">return</span> getDataBinder(bindingComponent, view, layoutId);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>让我们来康康kapt生成的<code>com.xxx.xxx.DataBinderMapperImpl()</code>到底有什么</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DataBinderMapperImpl</span> <span class=\"keyword\">extends</span> <span class=\"title\">DataBinderMapper</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// layout id 索引</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> LAYOUT_FRAGMENTHOME = <span class=\"number\">40</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> SparseIntArray INTERNAL_LAYOUT_ID_LOOKUP = <span class=\"keyword\">new</span> SparseIntArray(<span class=\"number\">1</span>);</span><br><span class=\"line\">  <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">    INTERNAL_LAYOUT_ID_LOOKUP.put(com.xmiles.callshow.R.layout.fragment_home, LAYOUT_FRAGMENTHOME);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> ViewDataBinding <span class=\"title\">getDataBinder</span><span class=\"params\">(DataBindingComponent component, View view, <span class=\"keyword\">int</span> layoutId)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 拿到索引的id</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> localizedLayoutId = INTERNAL_LAYOUT_ID_LOOKUP.get(layoutId);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(localizedLayoutId &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">final</span> Object tag = view.getTag();</span><br><span class=\"line\">      <span class=\"comment\">// 判断tag</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span>(tag == <span class=\"keyword\">null</span>)<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">&quot;view must have a tag&quot;</span>);</span><br><span class=\"line\">      <span class=\"comment\">// 这里如果布局数量超50,为避免一个方法体过大,会额外新建另外一个函数去处理,这里为好展示,整个类我就删除了很多其他布局参数</span></span><br><span class=\"line\">      <span class=\"keyword\">int</span> methodIndex = (localizedLayoutId - <span class=\"number\">1</span>) / <span class=\"number\">50</span>;</span><br><span class=\"line\">      <span class=\"comment\">// 跟据对应componet生成对应的ViewDetaBinding</span></span><br><span class=\"line\">      <span class=\"keyword\">switch</span>(methodIndex) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">0</span>: &#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> internalGetViewDataBinding0(component, view, localizedLayoutId, tag);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">1</span>: &#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> internalGetViewDataBinding1(component, view, localizedLayoutId, tag);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// GetViewDataBinding</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ViewDataBinding <span class=\"title\">internalGetViewDataBinding0</span><span class=\"params\">(DataBindingComponent component,View view, <span class=\"keyword\">int</span> internalId, Object tag)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span>(internalId) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">case</span>  LAYOUT_FRAGMENTHOME: &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"string\">&quot;layout/fragment_home_0&quot;</span>.equals(tag)) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> FragmentHomeBindingImpl(component, view);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">&quot;The tag for fragment_home is invalid. Received: &quot;</span> + tag);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"refer\">Refer<a title=\"#refer\" href=\"#refer\"></a></h3>\n<p><a href=\"https://www.jianshu.com/p/4be20cc58f17\" target=\"_blank\">Android架构组件之DataBinding源码解析 - 简书 (jianshu.com)</a><br>\n<a href=\"https://www.jianshu.com/p/4e9a1ab05bb5\" target=\"_blank\">DataBinding源码分析 - 简书 (jianshu.com)</a></p>\n",
            "tags": [
                "源码解析"
            ]
        },
        {
            "id": "https://onion99.github.io/2021/11/08/MpHTUCP7P1OgtydO/",
            "url": "https://onion99.github.io/2021/11/08/MpHTUCP7P1OgtydO/",
            "title": "Java并发(7) - ThreadLocal",
            "date_published": "2021-11-07T19:06:09.000Z",
            "content_html": "<blockquote>\n<p>ThreadLocal 是一个关于创建线程局部变量的类。通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。而使用 ThreadLocal 建的变量只能被当前线程访问，其他线程则无法访问和修改</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">testThreadLocal</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Thread t = <span class=\"keyword\">new</span> Thread() &#123;</span><br><span class=\"line\">        ThreadLocal&lt;String&gt; mStringThreadLocal = <span class=\"keyword\">new</span> ThreadLocal&lt;&gt;();</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">super</span>.run();</span><br><span class=\"line\">            mStringThreadLocal.set(<span class=\"string\">&quot;name&quot;</span>);</span><br><span class=\"line\">            mStringThreadLocal.get();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\">    t.start();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<span id=\"more\"></span>\n<h3 id=\"threadlocal实例化\">ThreadLocal实例化<a title=\"#threadlocal实例化\" href=\"#threadlocal实例化\"></a></h3>\n<blockquote>\n<p>为 ThreadLocal 设置默认的 get 初始值，需要重写 initialValue 方法</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ThreadLocal&lt;String&gt; mThreadLocal = <span class=\"keyword\">new</span> ThreadLocal&lt;String&gt;() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> String <span class=\"title\">initialValue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> Thread.currentThread().getName();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>在 Android 中的应用，Looper 类就是利用了 ThreadLocal 的特性，保证每个线程只存在一个 Looper 对象:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ThreadLocal&lt;Looper&gt; sThreadLocal = <span class=\"keyword\">new</span> ThreadLocal&lt;Looper&gt;();</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">prepare</span><span class=\"params\">(<span class=\"keyword\">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sThreadLocal.get() != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">&quot;Only one Looper may be created per thread&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sThreadLocal.set(<span class=\"keyword\">new</span> Looper(quitAllowed));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"原理\">原理<a title=\"#原理\" href=\"#原理\"></a></h3>\n<h4 id=\"threadlocal.set()\">ThreadLocal.set()<a title=\"#threadlocal.set()\" href=\"#threadlocal.set()\"></a></h4>\n<p>首先获取当前线程，利用当前线程作为句柄获取一个 ThreadLocalMap 的对象，如果上述 ThreadLocalMap 对象不为空，则设置值，否则创建这个 ThreadLocalMap 对象并设置值</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">set</span><span class=\"params\">(T value)</span> </span>&#123;</span><br><span class=\"line\">    Thread t = Thread.currentThread();</span><br><span class=\"line\">    ThreadLocalMap map = getMap(t);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (map != <span class=\"keyword\">null</span>) map.set(<span class=\"keyword\">this</span>, value);</span><br><span class=\"line\">    <span class=\"keyword\">else</span> createMap(t, value);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>获取Thread 对象的threadLocals 变量</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ThreadLocalMap <span class=\"title\">getMap</span><span class=\"params\">(Thread t)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> t.threadLocals;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Thread</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\">    ThreadLocal.ThreadLocalMap threadLocals = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果一开始未设置,则新建 ThreadLocalMap 对象，并设置初始值</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">createMap</span><span class=\"params\">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class=\"line\">    t.threadLocals = <span class=\"keyword\">new</span> ThreadLocalMap(<span class=\"keyword\">this</span>, firstValue);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://z3.ax1x.com/2021/11/05/InDvFg.png\" alt=\"InDvFg.png\" loading=\"lazy\" class=\"φbp\"></p>\n<h4 id=\"threadlocal.get()\">ThreadLocal.get()<a title=\"#threadlocal.get()\" href=\"#threadlocal.get()\"></a></h4>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Thread t = Thread.currentThread();</span><br><span class=\"line\">    ThreadLocalMap map = getMap(t);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (map != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        ThreadLocalMap.Entry e = map.getEntry(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"meta\">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class=\"line\">            T result = (T)e.value;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> setInitialValue();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"对象存放\">对象存放<a title=\"#对象存放\" href=\"#对象存放\"></a></h3>\n<ul>\n<li>在 Java 中,栈内存归属于线程私有,每个线程都会有一个栈内存,其存储的变量只能在其所属线程中可见,即栈内存可以理解成线程的私有内存</li>\n<li>堆内存中的对象对所有线程可见,堆内存中的对象可以被所有线程访问</li>\n<li>ThreadLocal 实例实际上也是被其创建的类持有（更顶端应该是被线程持有）,位于堆上</li>\n</ul>\n<h3 id=\"内存泄露问题\">内存泄露问题<a title=\"#内存泄露问题\" href=\"#内存泄露问题\"></a></h3>\n<p>当使用 ThreadLocal 保存一个 value 时，会在 ThreadLocalMap 中的数组插入一个Entry对象，ThreadLocal 在没有外部强引用时，发生 GC 时会被回收，但如果创建 ThreadLocal 的线程一直持续运行，那么这个 Entry 对象中的 value 就有可能一直得不到回收，发生内存泄露</p>\n<p>解决:使用完 ThreadLocal 之后,记得调用 remove 方法</p>\n",
            "tags": [
                "并发"
            ]
        },
        {
            "id": "https://onion99.github.io/2021/11/08/oizxmTtLdVsaXZrZ/",
            "url": "https://onion99.github.io/2021/11/08/oizxmTtLdVsaXZrZ/",
            "title": "Java并发(6) - 线程池",
            "date_published": "2021-11-07T19:05:17.000Z",
            "content_html": "<p>线程池对比new Thread()</p>\n<ul>\n<li>重用存在的线程，减少线程创建、消亡的开销，性能佳。</li>\n<li>可有效控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞</li>\n<li>提供定时执行、定期执行、单线程、并发数控制等功能</li>\n</ul>\n<p>ExecutorService 是最初的线程池接口，ThreadPoolExecutor 类是对线程池的具体实现:</p>\n<div class=\"φbq\"><div class=\"φbs\"><table><thead>\n<tr>\n<th style=\"text-align:center\">构造参数</th>\n<th style=\"text-align:right\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">corePoolSize</td>\n<td style=\"text-align:right\">核心线程的数量,默认情况下,即使核心线程没有任务在执行它也存在的,我们固定一定数量的核心线程且它一直存活,这样就避免了一般情况下CPU创建和销毁线程带来的开销。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">maximumPoolSize</td>\n<td style=\"text-align:right\">最大线程数，当任务数量超过最大线程数时其它任务可能就会被阻塞。最大线程数 = 核心线程 + 非核心线程。非核心线程只有当核心线程不够用且线程池有空余时才会被创建，执行完任务后非核心线程会被销毁。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">keepAliveTime</td>\n<td style=\"text-align:right\">非核心线程的超时时长,当执行时间超过这个时间时,非核心线程就会被回收。当 allowCoreThreadTimeOut设置为true时,此属性也作用在核心线程上</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">unit</td>\n<td style=\"text-align:right\">时间单位</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">workQueue</td>\n<td style=\"text-align:right\">任务队列,我们提交给线程池的 runnable 会被存储在这个对象上</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">threadFactory</td>\n<td style=\"text-align:right\">线程工厂,用于指定为线程池创建新线程的方式</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">handler</td>\n<td style=\"text-align:right\">拒绝策略</td>\n</tr>\n</tbody>\n</table></div></div><span id=\"more\"></span>\n<h3 id=\"线程池分配原则\">线程池分配原则<a title=\"#线程池分配原则\" href=\"#线程池分配原则\"></a></h3>\n<ul>\n<li>当 currentSize &lt; corePoolSize 时,直接启动一个核心线程执行任务</li>\n<li>当 currentSize &gt;= corePoolSize 并且<code>workQueue</code>未满时，添加进来的任务会被安排到<code>workQueue</code>中等待执行</li>\n<li>当<code>workQueue</code>已满，但是 currentSize &lt; maximumPoolSize 时，会立即开启一个非核心线程来执行任务</li>\n<li>当 currentSize &gt;= corePoolSize并且workQueue 已满和currentSize &gt; maximumPoolSize 时, 线程池则拒绝执行该任务,且 ThreadPoolExecutor 会调用 RejectedtionHandler 的<code>rejectedExecution()</code>来通知调用者</li>\n</ul>\n<h3 id=\"任务队列\">任务队列<a title=\"#任务队列\" href=\"#任务队列\"></a></h3>\n<blockquote>\n<p>对于新的任务.要根据任务场景考虑使用什么类型的容器缓存新任务</p>\n</blockquote>\n<div class=\"φbq\"><div class=\"φbs\"><table><thead>\n<tr>\n<th style=\"text-align:center\">实现类</th>\n<th style=\"text-align:center\">类型</th>\n<th style=\"text-align:center\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">SynchronousQueue</td>\n<td style=\"text-align:center\">同步队列</td>\n<td style=\"text-align:center\">该队列不存储元素，每个插入操作必须等待另一个线程调用移除操作，否则插入操作会一直阻塞</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">ArrayBlockingQueue</td>\n<td style=\"text-align:center\">有界队列</td>\n<td style=\"text-align:center\">基于数组的阻塞队列，按照 FIFO 原则对元素进行排序</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">LinkedBlockingQueue</td>\n<td style=\"text-align:center\">无界队列</td>\n<td style=\"text-align:center\">基于链表的阻塞队列，按照 FIFO 原则对元素进行排序</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">PriorityBlockingQueue</td>\n<td style=\"text-align:center\">优先级队列</td>\n<td style=\"text-align:center\">具有优先级的阻塞队列</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">DelayQueue</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">类似于PriorityBlockingQueue，是二叉堆实现的无界优先级阻塞队列。要求元素都实现Delayed接口，通过执行时延从队列中提取任务，时间没到任务取不出来.</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">LinkedBlockingDeque</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">使用双向队列实现的有界双端阻塞队列。双端意味着可以像普通队列一样FIFO（先进先出），也可以像栈一样FILO（先进后出）</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">LinkedTransferQueue</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">它是ConcurrentLinkedQueue、LinkedBlockingQueue和SynchronousQueue的结合体,但是把它用在ThreadPoolExecutor中,和LinkedBlockingQueue行为一致，但是是无界的阻塞队列。</td>\n</tr>\n</tbody>\n</table></div></div><h3 id=\"线程工厂\">线程工厂<a title=\"#线程工厂\" href=\"#线程工厂\"></a></h3>\n<blockquote>\n<p>线程工厂指定创建线程的方式,需要实现 ThreadFactory 接口,并实现 newThread(Runnable r) 方法</p>\n</blockquote>\n<p>Executors 框架已经为我们实现了一个默认的线程工厂:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DefaultThreadFactory</span> <span class=\"keyword\">implements</span> <span class=\"title\">ThreadFactory</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> AtomicInteger poolNumber = <span class=\"keyword\">new</span> AtomicInteger(<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ThreadGroup group;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> AtomicInteger threadNumber = <span class=\"keyword\">new</span> AtomicInteger(<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String namePrefix;</span><br><span class=\"line\"> </span><br><span class=\"line\">    DefaultThreadFactory() &#123;</span><br><span class=\"line\">        SecurityManager s = System.getSecurityManager();</span><br><span class=\"line\">        group = (s != <span class=\"keyword\">null</span>) ? s.getThreadGroup() :</span><br><span class=\"line\">                              Thread.currentThread().getThreadGroup();</span><br><span class=\"line\">        namePrefix = <span class=\"string\">&quot;pool-&quot;</span> +poolNumber.getAndIncrement() +<span class=\"string\">&quot;-thread-&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Thread <span class=\"title\">newThread</span><span class=\"params\">(Runnable r)</span> </span>&#123;</span><br><span class=\"line\">        Thread t = <span class=\"keyword\">new</span> Thread(group, r,namePrefix + threadNumber.getAndIncrement(),<span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (t.isDaemon())</span><br><span class=\"line\">            t.setDaemon(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (t.getPriority() != Thread.NORM_PRIORITY)</span><br><span class=\"line\">            t.setPriority(Thread.NORM_PRIORITY);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> t;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"拒绝策略\">拒绝策略<a title=\"#拒绝策略\" href=\"#拒绝策略\"></a></h3>\n<blockquote>\n<p>线程数量大于等于 maximumPoolSize 且 workQueue 已满，则使用拒绝策略处理新任务</p>\n</blockquote>\n<div class=\"φbq\"><div class=\"φbs\"><table><thead>\n<tr>\n<th style=\"text-align:center\">实现类</th>\n<th style=\"text-align:center\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">AbortPolicy</td>\n<td style=\"text-align:center\">丢弃新任务，并抛出 RejectedExecutionException</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">DiscardPolicy</td>\n<td style=\"text-align:center\">不做任何操作，直接丢弃新任务</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">DiscardOldestPolicy</td>\n<td style=\"text-align:center\">丢弃队列队首的元素，并执行新任务</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">CallerRunsPolicy</td>\n<td style=\"text-align:center\">由调用线程执行新任务</td>\n</tr>\n</tbody>\n</table></div></div><h3 id=\"线程池\">线程池<a title=\"#线程池\" href=\"#线程池\"></a></h3>\n<h4 id=\"fixthreadpool\">FixThreadPool<a title=\"#fixthreadpool\" href=\"#fixthreadpool\"></a></h4>\n<blockquote>\n<p>FixThreadPool 只有核心线程，并且数量固定的，也不会被回收。使用 LinkedBlockingQueue 无界队列，所有线程都活动时，因为队列没有限制大小，新任务会等待执行。由于线程不会回收，FixThreadPool会更快地响应外界请求</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title\">newFixThreadPool</span><span class=\"params\">(<span class=\"keyword\">int</span> nThreads)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ThreadPoolExecutor(nThreads, nThreads, <span class=\"number\">0L</span>, TimeUnit.MILLISECONDS, </span><br><span class=\"line\">                        <span class=\"keyword\">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//使用</span></span><br><span class=\"line\">Executors.newFixThreadPool(<span class=\"number\">5</span>).execute(r);</span><br></pre></td></tr></table></figure>\n<h4 id=\"singlethreadpool\">SingleThreadPool<a title=\"#singlethreadpool\" href=\"#singlethreadpool\"></a></h4>\n<blockquote>\n<p>SingleThreadPool 只有一个核心线程，确保所有任务都在同一线程中按顺序完成。因此不需要处理线程同步的问题</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title\">newSingleThreadPool</span> <span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> FinalizableDelegatedExecutorService ( <span class=\"keyword\">new</span> ThreadPoolExecutor (<span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, TimeUnit. MILLISECONDS, </span><br><span class=\"line\">                        <span class=\"keyword\">new</span> LinkedBlockingQueue&lt;Runnable&gt;()) );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//使用</span></span><br><span class=\"line\">Executors.newSingleThreadPool ().execute(r);</span><br></pre></td></tr></table></figure>\n<h4 id=\"cachedthreadpool\">CachedThreadPool<a title=\"#cachedthreadpool\" href=\"#cachedthreadpool\"></a></h4>\n<blockquote>\n<p>CachedThreadPool 只有非核心线程，最大线程数非常大，所有线程都活动时，会为新任务创建新线程，否则利用空闲线程处理任务。采用 SynchronousQueue 同步队列相当于一个空集合，导致任何任务都会被立即执行。比较适合执行大量的耗时较少的任务。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title\">newCachedThreadPool</span><span class=\"params\">(<span class=\"keyword\">int</span> nThreads)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ThreadPoolExecutor(<span class=\"number\">0</span>, Integer.MAX_VALUE, <span class=\"number\">60L</span>, TimeUnit. SECONDS, </span><br><span class=\"line\">                        <span class=\"keyword\">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//使用</span></span><br><span class=\"line\">Executors.newCachedThreadPool().execute(r);</span><br></pre></td></tr></table></figure>\n<h4 id=\"scheduledthreadpool\">ScheduledThreadPool<a title=\"#scheduledthreadpool\" href=\"#scheduledthreadpool\"></a></h4>\n<blockquote>\n<p>核心线程数固定，非核心线程（闲着没活干会被立即回收）数没有限制</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ScheduledExecutorService <span class=\"title\">newScheduledThreadPool</span><span class=\"params\">(<span class=\"keyword\">int</span> corePoolSize)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ScheduledThreadPoolExecutor</span><span class=\"params\">(<span class=\"keyword\">int</span> corePoolSize)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(corePoolSize, Integer.MAX_VALUE, <span class=\"number\">0</span>, NANOSECONDS, <span class=\"keyword\">new</span> DelayedQueue ());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//使用，延迟1秒执行，每隔2秒执行一次Runnable r</span></span><br><span class=\"line\">Executors.newScheduledThreadPool(<span class=\"number\">5</span>).scheduleAtFixedRate(r, <span class=\"number\">1000</span>, <span class=\"number\">2000</span>, TimeUnit.MILLISECONDS);</span><br></pre></td></tr></table></figure>\n<h3 id=\"关闭线程池\">关闭线程池<a title=\"#关闭线程池\" href=\"#关闭线程池\"></a></h3>\n<ul>\n<li>shutdown()：执行后停止接受新任务，会把队列的任务执行完毕。将线程池状态变为 SHUTDOWN。</li>\n<li>shutdownNow()：也是停止接受新任务，但会中断所有的任务，将线程池状态变为 STOP</li>\n</ul>\n",
            "tags": [
                "并发"
            ]
        },
        {
            "id": "https://onion99.github.io/2021/11/08/WkWqwHwU8wgNL4cd/",
            "url": "https://onion99.github.io/2021/11/08/WkWqwHwU8wgNL4cd/",
            "title": "Java并发(5) - 线程协作",
            "date_published": "2021-11-07T19:04:05.000Z",
            "content_html": "<h3 id=\"线程状态\">线程状态<a title=\"#线程状态\" href=\"#线程状态\"></a></h3>\n<p><img src=\"https://z3.ax1x.com/2021/11/05/InuMpd.png\" alt=\"InuMpd.png\" loading=\"lazy\" class=\"φbp\"></p>\n<span id=\"more\"></span>\n<h3 id=\"wait、notify、notifyall\">wait、notify、notifyAll<a title=\"#wait、notify、notifyall\" href=\"#wait、notify、notifyall\"></a></h3>\n<blockquote>\n<p>实现线程间的协作</p>\n</blockquote>\n<h4 id=\"wait\">wait<a title=\"#wait\" href=\"#wait\"></a></h4>\n<ul>\n<li><code>wait()</code>将当前运行的线程挂起(即让其进入阻塞状态)，直到<code>notify</code>或<code>notifyAll</code>方法来唤醒线程</li>\n<li><code>wait(long timeout)</code>跟上面类似,但会超时唤醒</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WaitTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 写法错误:这里会抛出的 IllegalMonitorStateException 异常</span></span><br><span class=\"line\">    <span class=\"comment\">// 因为在调用wait方式时没有获取到monitor对象的所有权，那如何获取monitor对象所有权？Java中只能通过Synchronized关键字来完成</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testWait</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Start-----&quot;</span>);</span><br><span class=\"line\">        wait(<span class=\"number\">1000</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;End-------&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 写法正确</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">testWait</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Start-----&quot;</span>);</span><br><span class=\"line\">        wait(<span class=\"number\">1000</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;End-------&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> WaitTest test = <span class=\"keyword\">new</span> WaitTest();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">            test.testWait();</span><br><span class=\"line\">        &#125;).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>wait()</code>的使用必须在<code>synchronized </code>的范围内，否则就会抛出IllegalMonitorStateException异常，<code>wait()</code>的作用就是阻塞当前线程等待notify/notifyAll方法的唤醒，或等待超时后自动唤醒</p>\n<h4 id=\"notify/notifyall\">notify/notifyAll<a title=\"#notify/notifyall\" href=\"#notify/notifyall\"></a></h4>\n<ul>\n<li><code>notify()</code>唤醒monitor上的一个线程</li>\n<li><code>notifyAll()</code>唤醒所有的线程</li>\n</ul>\n<h3 id=\"sleep、yield、join\">sleep、yield、join<a title=\"#sleep、yield、join\" href=\"#sleep、yield、join\"></a></h3>\n<ul>\n<li><code>sleep()</code>延时</li>\n<li><code>start()</code>启动线程，让线程变成就绪状态等待 CPU 调度后执行</li>\n<li><code>yield()</code>让掉当前线程资源占有，使正在运行中的线程重新变成就绪状态，并重新竞争 CPU 的调度权。它可能会获取到，也有可能被其他线程获取到</li>\n<li><code>join()</code>使主线程进入等待池并等待当前线程执行完毕后才会被唤醒</li>\n</ul>\n<p><code>yield()</code>可以很好的控制多线程，如执行某项复杂的任务时，如果担心占用资源过多，可以在完成某个重要的工作后使用 yield 方法让掉当前 CPU 的调度权，等下次获取到再继续执行，这样不但能完成自己的重要工作，也能给其他线程一些运行的机会，避免一个线程长时间占有 CPU 资源。</p>\n",
            "tags": [
                "并发"
            ]
        },
        {
            "id": "https://onion99.github.io/2021/11/08/qX2v7eB61IheaBrH/",
            "url": "https://onion99.github.io/2021/11/08/qX2v7eB61IheaBrH/",
            "title": "Java并发(4) - CAS",
            "date_published": "2021-11-07T18:59:57.000Z",
            "content_html": "<p>锁机制问题:</p>\n<ul>\n<li>在多线程竞争下，加锁、释放锁会导致比较多的上下文切换和调度延时，引起性能问题</li>\n<li>一个线程持有锁会导致其它所有需要此锁的线程挂起</li>\n<li>如果一个优先级高的线程等待一个优先级低的线程释放锁会导致优先级倒置，引起性能风险</li>\n</ul>\n<p>volatile 是不错的机制，但是 volatile 不能保证原子性，因此对于同步最终还是要回到锁机制上来。独占锁是一种悲观锁，synchronized 就是一种独占锁，会导致其它所有需要锁的线程挂起，等待持有锁的线程释放锁。而另一个更加有效的锁就是乐观锁</p>\n<blockquote>\n<p>乐观锁即总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和 CAS 算法实现</p>\n</blockquote>\n<span id=\"more\"></span>\n<h3 id=\"原子操作\">原子操作<a title=\"#原子操作\" href=\"#原子操作\"></a></h3>\n<blockquote>\n<p>所谓“原子”操作，是指一组不可分割的操作：操作者对目标对象进行操作时，要么完成所有操作后其他操作者才能操作；要么这个操作者不能进行任何操作</p>\n</blockquote>\n<p><img src=\"https://z3.ax1x.com/2021/11/04/Ie5YA1.png\" alt=\"Ie5YA1.png\" loading=\"lazy\" class=\"φbp\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestAtomic</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 实例化了一个AtomicInteger类的对象atomic并定义初始值为1</span></span><br><span class=\"line\">        AtomicInteger atomic = <span class=\"keyword\">new</span> AtomicInteger(<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 进行atomic的原子化操作：增加1并且获取这个增加后的新值</span></span><br><span class=\"line\">        atomic.incrementAndGet();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"cas-原理\">CAS 原理<a title=\"#cas-原理\" href=\"#cas-原理\"></a></h3>\n<blockquote>\n<p>CAS 的思想很简单，三个参数：当前内存值 V、旧的预期值 A、即将更新的值 B，当且仅当预期值 A 和内存值 V 相同时，将内存值修改为 B 并返回 true，否则什么都不做，并返回 false。我们拿 AtomicInteger 类来分析，先来看看 AtomicInteger 静态代码块片段</p>\n</blockquote>\n<h3 id=\"cas缺点\">CAS缺点<a title=\"#cas缺点\" href=\"#cas缺点\"></a></h3>\n<ul>\n<li>循环时间长开销很大</li>\n<li>只能保证一个共享变量的原子操作</li>\n<li>ABA问题</li>\n</ul>\n",
            "tags": [
                "并发"
            ]
        },
        {
            "id": "https://onion99.github.io/2021/11/08/HcJi8WdXZ8E3DBWS/",
            "url": "https://onion99.github.io/2021/11/08/HcJi8WdXZ8E3DBWS/",
            "title": "Java并发(3) - Lock",
            "date_published": "2021-11-07T18:59:09.000Z",
            "content_html": "<blockquote>\n<p>锁是用于通过多个线程控制对共享资源的访问的工具</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Lock lock = <span class=\"keyword\">new</span> ReentrantLock();</span><br><span class=\"line\">lock.lock();</span><br><span class=\"line\"><span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//临界区......</span></span><br><span class=\"line\">&#125;<span class=\"keyword\">finally</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//最好不要把获取锁的过程写在 try 语句块中，因为如果在获取锁时发生了异常，异常抛出的同时也会导致锁无法被释放</span></span><br><span class=\"line\">    lock.unlock();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<span id=\"more\"></span>\n<h3 id=\"特性和方法\">特性和方法<a title=\"#特性和方法\" href=\"#特性和方法\"></a></h3>\n<p>提供synchronized不具备的主要特性:</p>\n<div class=\"φbq\"><div class=\"φbs\"><table><thead>\n<tr>\n<th style=\"text-align:center\">特性</th>\n<th style=\"text-align:center\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">以非阻塞地获取锁</td>\n<td style=\"text-align:center\">当前线程尝试获取锁，如果这一时刻锁没有被其他线程获取到，则成功获取并持有锁</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">可以被中断地获取锁</td>\n<td style=\"text-align:center\">获取到锁的线程能够响应中断，当获取到锁的线程被中断时，中断异常将会被抛出，同时锁会被释放</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">超时的方式获取锁</td>\n<td style=\"text-align:center\">在指定的截止时间之前获取锁,超时后仍旧无法获取则返回</td>\n</tr>\n</tbody>\n</table></div></div><div class=\"φbq\"><div class=\"φbs\"><table><thead>\n<tr>\n<th style=\"text-align:center\">Method</th>\n<th style=\"text-align:center\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">lock()</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">获取锁。如果锁不可用,则当前线程将被禁用以进行线程调度，并处于休眠状态，等待直到获取锁。</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">lockInterruptibly()</td>\n<td style=\"text-align:center\">可以中断的去获取锁</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">newCondition()</td>\n<td style=\"text-align:center\">返回当前锁的Condition(等待条件),在Condition之前，当前线程必须持有锁,调用Condition.wait 当前线程将释放锁</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">tryLock()</td>\n<td style=\"text-align:center\">直接获取锁,可以true,不可以false</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">tryLock(time,unit)</td>\n<td style=\"text-align:center\">超时获取锁,有三种情况:1.当前线程在超时时间内获得了锁;2.当前线程被中断;3.超时时间结束，返回false</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">unlock()</td>\n<td style=\"text-align:center\">释放锁</td>\n</tr>\n</tbody>\n</table></div></div><h3 id=\"reentrantlock\">ReentrantLock<a title=\"#reentrantlock\" href=\"#reentrantlock\"></a></h3>\n<blockquote>\n<p>ReentrantLock 和 synchronized声明一样可以用来实现线程之间的同步互斥，但在功能上比 synchronized声明 更强大而且更灵活</p>\n</blockquote>\n<div class=\"φbq\"><div class=\"φbs\"><table><thead>\n<tr>\n<th>构造Method</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ReentrantLock()</td>\n<td>创建一个 ReentrantLock的实例</td>\n</tr>\n<tr>\n<td>ReentrantLock(boolean fair)</td>\n<td>创建一个特定锁类型（公平锁/非公平锁）的ReentrantLock的实例</td>\n</tr>\n</tbody>\n</table></div></div><ul>\n<li>公平锁: 先来先得, 线程调度有序</li>\n<li>非公平锁: 一种获取锁的抢占机制,谁快谁得,线程调度无序</li>\n</ul>\n<div class=\"φbq\"><div class=\"φbs\"><table><thead>\n<tr>\n<th>调用Method</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>getHoldCount()</td>\n<td>调用lock()方法的次数</td>\n</tr>\n<tr>\n<td>getOwner()</td>\n<td>返回当前拥有此锁的线程，如果不拥有，则返回 null</td>\n</tr>\n<tr>\n<td>getQueuedThreads()</td>\n<td>返回正在等待获取此锁的线程的集合</td>\n</tr>\n<tr>\n<td>getWaitingThreads()</td>\n<td>返回与此锁相关联的Condition下等待的线程的集合</td>\n</tr>\n<tr>\n<td>hasQueuedThread()</td>\n<td>查询给定线程是否等待获取锁</td>\n</tr>\n<tr>\n<td>hasQueuedThreads()</td>\n<td>查询否有线程正在等待获取锁</td>\n</tr>\n<tr>\n<td>hasWaiters()</td>\n<td>查询任何线程是否等待与此锁相关联的给定条件</td>\n</tr>\n<tr>\n<td>isHeldByCurrentThread()</td>\n<td>查询此锁是否由当前线程持有</td>\n</tr>\n</tbody>\n</table></div></div><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReentrantLockTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        MyService service = <span class=\"keyword\">new</span> MyService();</span><br><span class=\"line\">        MyThread a1 = <span class=\"keyword\">new</span> MyThread(service);</span><br><span class=\"line\">        MyThread a2 = <span class=\"keyword\">new</span> MyThread(service);</span><br><span class=\"line\">        MyThread a3 = <span class=\"keyword\">new</span> MyThread(service);</span><br><span class=\"line\">        a1.start();</span><br><span class=\"line\">        a2.start();</span><br><span class=\"line\">        a3.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyService</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> Lock lock = <span class=\"keyword\">new</span> ReentrantLock();</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testMethod</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            lock.lock();</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">              System.out.println(<span class=\"string\">&quot;ThreadName=&quot;</span> + Thread.currentThread().getName() + (<span class=\"string\">&quot; &quot;</span> + (i + <span class=\"number\">1</span>)));</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">              lock.unlock();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 结果:当一个线程运行完毕后才把锁释放，其他线程才能执行</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> MyService service;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyThread</span><span class=\"params\">(MyService service)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">super</span>();</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.service = service;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            service.testMethod();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"condition\">Condition<a title=\"#condition\" href=\"#condition\"></a></h3>\n<blockquote>\n<p>线程对象可以注册指定的Condition, 从而可以有选择性的进行线程通知,使得线程调度上更加灵活</p>\n</blockquote>\n<div class=\"φbq\"><div class=\"φbs\"><table><thead>\n<tr>\n<th style=\"text-align:center\">Method</th>\n<th style=\"text-align:center\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">await()</td>\n<td style=\"text-align:center\">使当前线程等待，直到它收到信号或被中断</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">signal()</td>\n<td style=\"text-align:center\">发出信号,唤醒一个等待线程</td>\n</tr>\n</tbody>\n</table></div></div><p>思路理清:</p>\n<ol>\n<li>首先<code>a.start()</code> 输出<code>&quot;await&quot;</code>,然后进入<code>condition.await()</code></li>\n<li>3s后<code>service.signal()</code> 输出<code>&quot;signal&quot;</code></li>\n<li>进入<code>condition.signal()</code> , 3s后输出<code>&quot;最好的signal()的语句&quot;</code></li>\n<li>再之后输出<code>&quot;signal之后的语句&quot;</code></li>\n</ol>\n<p>等待/通知的实现:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UseSingleConditionWaitNotify</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        MyService service = <span class=\"keyword\">new</span> MyService();</span><br><span class=\"line\">        ThreadA a = <span class=\"keyword\">new</span> ThreadA(service);</span><br><span class=\"line\">        a.start();</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">3000</span>);</span><br><span class=\"line\">        service.signal();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyService</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> Lock lock = <span class=\"keyword\">new</span> ReentrantLock();</span><br><span class=\"line\">        <span class=\"keyword\">public</span> Condition condition = lock.newCondition();</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">await</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            lock.lock();</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot; await&quot;</span>);</span><br><span class=\"line\">                condition.await();</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;signal之后的语句&quot;</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                lock.unlock();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">signal</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">            lock.lock();</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;\t\t\t\t</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;signal&quot;</span>);</span><br><span class=\"line\">                condition.signal();</span><br><span class=\"line\">                Thread.sleep(<span class=\"number\">3000</span>);</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;最好的signal()的语句&quot;</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                lock.unlock();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThreadA</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> MyService service;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ThreadA</span><span class=\"params\">(MyService service)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">super</span>();</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.service = service;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            service.await();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"readwritelock-接口的实现类：reentrantreadwritelock\">ReadWriteLock 接口的实现类：ReentrantReadWriteLock<a title=\"#readwritelock-接口的实现类：reentrantreadwritelock\" href=\"#readwritelock-接口的实现类：reentrantreadwritelock\"></a></h3>\n<blockquote>\n<p>ReentrantLock（排他锁）具有完全互斥排他的效果，即同一时刻只允许一个线程访问,效率低下,ReadWriteLock 接口的实现类 ReentrantReadWriteLock 读写锁就是为了解决这个问题。读写锁维护了两个锁，一个是读操作相关的锁成为共享锁，一个是写操作相关的锁为排他锁。通过分离读锁和写锁，其并发性比一般排他锁有了很大提升</p>\n</blockquote>\n<ul>\n<li>读读共享</li>\n<li>写写互斥</li>\n<li>读写互斥</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> ReentrantReadWriteLock lock = <span class=\"keyword\">new</span> ReentrantReadWriteLock();</span><br><span class=\"line\"><span class=\"comment\">// 读读共享情况,输出可以发现两个线程几乎可以同时运行</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">read</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            lock.readLock().lock();</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;获得读锁&quot;</span> + Thread.currentThread().getName()</span><br><span class=\"line\">                    + <span class=\"string\">&quot; &quot;</span> + System.currentTimeMillis());</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">10000</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            lock.readLock().unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// TODO Auto-generated catch block</span></span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>",
            "tags": [
                "并发"
            ]
        },
        {
            "id": "https://onion99.github.io/2021/11/08/FEETAEwJ336KYqim/",
            "url": "https://onion99.github.io/2021/11/08/FEETAEwJ336KYqim/",
            "title": "Java并发(2) - synchronize",
            "date_published": "2021-11-07T18:55:09.000Z",
            "content_html": "<blockquote>\n<p>在 Java 中，关键字 synchronized 可以保证在同一个时刻，只有一个线程可以执行某个方法或者某个代码块,也可以保证一个线程的变化(主要是共享数据的变化)被其他线程所看到</p>\n</blockquote>\n<p>锁就是为达到这种互斥访问目的诞生的,从宏观上锁分为乐观锁和悲观锁</p>\n<ul>\n<li>乐观锁：认为读多写少，遇到并发写情况较少\n<ul>\n<li>Java 中 java.util.concurrent.atomic 包下面的原子变量类就是使用了乐观锁的一种实现方式 CAS 实现的</li>\n</ul>\n</li>\n<li>悲观锁：即认为写多，遇到并发写情况较多\n<ul>\n<li>Java 中 synchronized 和 ReentrantLock 等独占锁就是悲观锁思想的实现。</li>\n</ul>\n</li>\n</ul>\n<span id=\"more\"></span>\n<blockquote>\n<p>锁其实就是各个房子的门的关门开门的实现, 不用线程访问不同的锁(门)互不干扰</p>\n</blockquote>\n<h3 id=\"用法\">用法<a title=\"#用法\" href=\"#用法\"></a></h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//this,当前实例对象锁</span></span><br><span class=\"line\"><span class=\"keyword\">synchronized</span>(<span class=\"keyword\">this</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>;j&lt;<span class=\"number\">1000000</span>;j++)&#123;</span><br><span class=\"line\">        i++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//class对象锁</span></span><br><span class=\"line\"><span class=\"keyword\">synchronized</span>(AccountingSync.class)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>;j&lt;<span class=\"number\">1000000</span>;j++)&#123;</span><br><span class=\"line\">        i++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"作用于实例方法\">作用于实例方法<a title=\"#作用于实例方法\" href=\"#作用于实例方法\"></a></h4>\n<blockquote>\n<p>所谓的实例对象锁就是用 synchronized 修饰实例对象中的实例方法，注意这不包括静态方法</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AccountingSync</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//共享资源(临界资源)</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * synchronized 修饰实例方法</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">increase</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        i++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>;j&lt;<span class=\"number\">1000000</span>;j++)&#123;</span><br><span class=\"line\">            increase();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">\t    test1()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test1</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//这个时候两个线程,对象锁是一致的,所以结果无误</span></span><br><span class=\"line\">        AccountingSync instance=<span class=\"keyword\">new</span> AccountingSync();</span><br><span class=\"line\">        Thread t1=<span class=\"keyword\">new</span> Thread(instance);</span><br><span class=\"line\">        Thread t2=<span class=\"keyword\">new</span> Thread(instance);</span><br><span class=\"line\">        t1.start();</span><br><span class=\"line\">        t2.start();</span><br><span class=\"line\">        t1.join();</span><br><span class=\"line\">        t2.join();</span><br><span class=\"line\">        System.out.println(i);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 输出结果:</span></span><br><span class=\"line\"><span class=\"comment\">     * 2000000</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test2</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//这个时候两个线程,对象锁是不一致的,所以结果有误</span></span><br><span class=\"line\">        <span class=\"comment\">//将 synchronized 作用于静态的 increase 方法，这样的话，对象锁就当前类对象</span></span><br><span class=\"line\">        <span class=\"comment\">//由于无论创建多少个实例对象，但对于的类对象拥有只有一个，所有在这样的情况下对象锁就是唯一的</span></span><br><span class=\"line\">        <span class=\"comment\">//new新实例</span></span><br><span class=\"line\">        Thread t1=<span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> AccountingSyncBad());</span><br><span class=\"line\">        <span class=\"comment\">//new新实例</span></span><br><span class=\"line\">        Thread t2=<span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> AccountingSyncBad());</span><br><span class=\"line\">        t1.start();</span><br><span class=\"line\">        t2.start();</span><br><span class=\"line\">        t1.join();</span><br><span class=\"line\">        t2.join();</span><br><span class=\"line\">        System.out.println(i);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 输出结果有问题:</span></span><br><span class=\"line\"><span class=\"comment\">     * 123537</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"作用于静态方法\">作用于静态方法<a title=\"#作用于静态方法\" href=\"#作用于静态方法\"></a></h4>\n<blockquote>\n<p>当 synchronized 作用于静态方法时，其锁就是当前类的 class 对象锁。由于静态成员不专属于任何一个实例对象，是类成员，因此通过 class 对象锁可以控制静态成员的并发操作</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AccountingSyncClass</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 作用于静态方法,锁是当前class对象,也就是AccountingSyncClass类对应的class对象</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">increase</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        i++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">// 非静态,访问时锁不一样不会发生互斥</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">increase4Obj</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        i++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>;j&lt;<span class=\"number\">1000000</span>;j++)&#123;</span><br><span class=\"line\">            increase();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//new新实例</span></span><br><span class=\"line\">        Thread t1=<span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> AccountingSyncClass());</span><br><span class=\"line\">        <span class=\"comment\">//new心事了</span></span><br><span class=\"line\">        Thread t2=<span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> AccountingSyncClass());</span><br><span class=\"line\">        <span class=\"comment\">//启动线程</span></span><br><span class=\"line\">        t1.start();t2.start();</span><br><span class=\"line\">        t1.join();t2.join();</span><br><span class=\"line\">        System.out.println(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"同步代码块\">同步代码块<a title=\"#同步代码块\" href=\"#同步代码块\"></a></h4>\n<ul>\n<li>synchronized 同步块对同一条线程来说是可重入的，不会出现自己把自己锁死的问题</li>\n<li>同步块在已进入的线程执行完之前，会阻塞后面其他线程的进入。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AccountingSync</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> AccountingSync instance = <span class=\"keyword\">new</span> AccountingSync();</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//省略其他耗时操作....</span></span><br><span class=\"line\">        <span class=\"comment\">//使用同步代码块对变量i进行同步操作,锁对象为instance</span></span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span>(instance)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>;j&lt;<span class=\"number\">1000000</span>;j++)&#123;</span><br><span class=\"line\">                    i++;</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        Thread t1 = <span class=\"keyword\">new</span> Thread(instance);</span><br><span class=\"line\">        Thread t2 = <span class=\"keyword\">new</span> Thread(instance);</span><br><span class=\"line\">        t1.start();t2.start();</span><br><span class=\"line\">        t1.join();t2.join();</span><br><span class=\"line\">        System.out.println(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"原理(理解不了的)\">原理(理解不了的)<a title=\"#原理(理解不了的)\" href=\"#原理(理解不了的)\"></a></h3>\n<blockquote>\n<p>monitor 和 Java 对象头是实现 synchronized 的基础</p>\n</blockquote>\n<h4 id=\"moniter\">moniter<a title=\"#moniter\" href=\"#moniter\"></a></h4>\n<p>JVM 基于进入和退出 Monitor 对象来实现方法同步和代码块同步。代码块同步是使用 monitorenter 和 monitorexit 指令实现的， monitorenter 指令是在编译后插入到同步代码块的开始位置，而 monitorexit 是插入到方法结束处和异常处。任何对象都有一个 monitor 与之关联，当且一个 monitor 被持有后，它将处于锁定状态。</p>\n<p>根据虚拟机规范的要求，在执行 monitorenter 指令时，首先要去尝试获取对象的锁，如果这个对象没被锁定，或者当前线程已经拥有了那个对象的锁，把锁的计数器加 1；相应地，在执行 monitorexit 指令时会将锁计数器减 1，当计数器被减到 0 时，锁就释放了。如果获取对象锁失败了，那当前线程就要阻塞等待，直到对象锁被另一个线程释放为止。</p>\n<h4 id=\"对象头\">对象头<a title=\"#对象头\" href=\"#对象头\"></a></h4>\n<p>在 JVM 中，对象在内存中的布局分为三块区域：对象头、实例数据和对齐填充。Java 头对象是实现 synchronized 的锁对象的基础,一般而言,synchronized 使用的锁对象是存储在 Java 对象头里的。</p>\n<p><img src=\"https://z3.ax1x.com/2021/11/04/IeGDeI.png\" alt=\"IeGDeI.png\" loading=\"lazy\" class=\"φbp\"></p>\n<h3 id=\"synchronized与reentrantlock\">synchronized与ReentrantLock<a title=\"#synchronized与reentrantlock\" href=\"#synchronized与reentrantlock\"></a></h3>\n<ul>\n<li>开发\n<ul>\n<li>synchronized 隐式锁, 锁的持有与释放都是隐式的</li>\n<li>ReentrantLock 显示锁, 锁的持有和释放都必须由我们手动编写</li>\n</ul>\n</li>\n<li>性能:由于JDK1.6中加入了针对锁的优化措施（见后面），使得synchronized 与 ReentrantLock 的性能基本持平。ReentrantLock 只是提供了 synchronized 更丰富的功能，而不一定有更优的性能，所以在 synchronized 能实现需求的情况下，优先考虑使用 synchronized 来进行同步。</li>\n</ul>\n<h3 id=\"synchronize-与-volatile-异同\">synchronize 与 volatile 异同<a title=\"#synchronize-与-volatile-异同\" href=\"#synchronize-与-volatile-异同\"></a></h3>\n<ul>\n<li>性能差异\n<ul>\n<li>加锁、解锁的过程是要有性能损耗的</li>\n<li>volatile 变量的读操作的性能几乎与普通变量无差别,虽说写操作由于需要插入内存屏障所以会慢一些,但开销也比volatile低</li>\n</ul>\n</li>\n<li>阻塞\n<ul>\n<li>volatile 是Java虚拟机提供的一种轻量级同步机制，基于内存屏障实现的。不是锁带来的阻塞和性能损耗的问题</li>\n<li>synchronize 实现的锁本质上是一种阻塞锁</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"refer\">Refer<a title=\"#refer\" href=\"#refer\"></a></h3>\n<p><a href=\"https://blog.csdn.net/u010289802/article/details/104228091\" target=\"_blank\">暴力突破 Java 并发 - synchronize 解析_lerendan的博客-CSDN博客</a></p>\n",
            "tags": [
                "并发"
            ]
        },
        {
            "id": "https://onion99.github.io/2021/11/07/VqykJCDZZcenZo3O/",
            "url": "https://onion99.github.io/2021/11/07/VqykJCDZZcenZo3O/",
            "title": "Java并发(1) - volatile",
            "date_published": "2021-11-07T15:50:26.000Z",
            "content_html": "<h3 id=\"java内存模型\">JAVA内存模型<a title=\"#java内存模型\" href=\"#java内存模型\"></a></h3>\n<p><img src=\"https://z3.ax1x.com/2021/11/04/IZ6xs0.png\" alt=\"IZ6xs0.png\" loading=\"lazy\" class=\"φbp\"></p>\n<p>Java 内存模型规定了所有的变量都存储在主内存中。每条线程有自己的工作内存，线程的工作内存保存了被该线程所使用到的变量（从主内存中拷贝而来）。线程对变量的所有操作（读取，赋值）都必须在工作内存中进行。不同线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成</p>\n<span id=\"more\"></span>\n<h3 id=\"volatile特性\">volatile特性<a title=\"#volatile特性\" href=\"#volatile特性\"></a></h3>\n<h4 id=\"可见性\">可见性<a title=\"#可见性\" href=\"#可见性\"></a></h4>\n<blockquote>\n<p>一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的</p>\n</blockquote>\n<p>如果对声明了 volatile 变量进行写操作时，JVM 会向处理器发送一条 Lock 前缀的指令，将这个变量所在缓存行的数据写会到系统内存。 这一步确保了如果有其他线程对声明了 volatile 变量进行修改，则立即更新主内存中数据。但这时候其他处理器的缓存还是旧的，所以在多处理器环境下，为了保证各个处理器缓存一致，每个处理会通过嗅探在总线上传播的数据来检查自己的缓存是否过期，当处理器发现自己缓存行对应的内存地址被修改了，就会将当前处理器的缓存行设置成无效状态，当处理器要对这个数据进行修改操作时，会强制重新从系统内存把数据读到处理器缓存里。 这一步确保了其他线程获得的声明了 volatile 变量都是从主内存中获取最新的</p>\n<h4 id=\"禁止重排序\">禁止重排序<a title=\"#禁止重排序\" href=\"#禁止重排序\"></a></h4>\n<blockquote>\n<p>重排序是指处理器为了提高程序运行效率,可能会输入代码进行优化,可能会使执行顺序有所改变,但最终的结果会是一样的</p>\n</blockquote>\n<p>禁止指令重排序的意义:</p>\n<ul>\n<li>当程序执行到 volatile 变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行。</li>\n<li>在进行指令优化时，不能将在对 volatile 变量的读操作或者写操作的语句放在其后面执行，也不能把 volatile 变量后面的语句放到其前面执行</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//x,y 为普通变量,volflag 被 volatile 修饰</span></span><br><span class=\"line\">x = <span class=\"number\">10</span>;          <span class=\"comment\">//语句1</span></span><br><span class=\"line\">y = <span class=\"number\">3</span>;           <span class=\"comment\">//语句2</span></span><br><span class=\"line\">volflag = <span class=\"keyword\">true</span>;  <span class=\"comment\">//语句3</span></span><br><span class=\"line\">x= <span class=\"number\">5</span>;           <span class=\"comment\">//语句4</span></span><br><span class=\"line\">y = <span class=\"number\">9</span>;           <span class=\"comment\">//语句5</span></span><br></pre></td></tr></table></figure>\n<p>代码思路:</p>\n<ul>\n<li>volflag被volatile修饰，所以语句3不会被重排到语句1、语句2前面，也不会被重排到语句4、语句5 的后面</li>\n<li>语句1、2 和语句4、5 的顺序是不能保证的</li>\n<li>volatile可以保证在执行到语句3的时候语句1、2是执行完毕的，语句4、5是没有执行的，并且语句1、2的执行结果对语句4、5是可见的</li>\n</ul>\n<h4 id=\"为什么不能保证一致性\">为什么不能保证一致性<a title=\"#为什么不能保证一致性\" href=\"#为什么不能保证一致性\"></a></h4>\n<blockquote>\n<p>一致性要满足三个条件：原子性，有序性，可见性</p>\n</blockquote>\n<ul>\n<li>原子性：即一个操作或者多个操作要么全部执行且执行的过程不会被任何因素打断，要么就都不执行。</li>\n<li>可见性：指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</li>\n<li>有序性：即程序执行的顺序按照代码的先后顺序执行</li>\n</ul>\n<p>volatile 变量是比锁弱一级的同步机制。当一个线程获取锁之后，别的线程就不能对其进行读写，但是声明一个 volatile 变量只会让该线程对该变量的任何修改对其他线程可见,所以不能保证原子性</p>\n<h3 id=\"应用\">应用<a title=\"#应用\" href=\"#应用\"></a></h3>\n<p>单例模式中的 double check:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span></span>&#123;    </span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">static</span> Singleton instance = <span class=\"keyword\">null</span>;    </span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span> </span>&#123;&#125; </span><br><span class=\"line\">      </span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;        </span><br><span class=\"line\">      <span class=\"keyword\">if</span>(instance == <span class=\"keyword\">null</span>) &#123;            </span><br><span class=\"line\">           <span class=\"keyword\">synchronized</span> (Singleton.class) &#123;                </span><br><span class=\"line\">             <span class=\"keyword\">if</span>(instance == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                    instance = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;        </span><br><span class=\"line\">       <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"实现机制\">实现机制<a title=\"#实现机制\" href=\"#实现机制\"></a></h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 可以看到加入volatile关键字时，汇编后会多出一个lock前缀指令</span></span><br><span class=\"line\">Java代码: instance = <span class=\"keyword\">new</span> Singleton();<span class=\"comment\">//instance是volatile变量</span></span><br><span class=\"line\">汇编代码:  <span class=\"number\">0x01a3de1d</span>: movb $<span class=\"number\">0x0</span>,<span class=\"number\">0x1104800</span>(%esi);<span class=\"number\">0x01a3de24</span>: lock addl $<span class=\"number\">0x0</span>,(%esp);</span><br></pre></td></tr></table></figure>\n<p>Lock前缀指令实际上相当于一个内存屏障（也称内存围栏）,其作用如下:</p>\n<ul>\n<li>它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成</li>\n<li>强制将对缓存的修改操作立即写入主内存</li>\n<li>如果是写操作，它会导致其他CPU中对应的缓存行无效</li>\n</ul>\n<h3 id=\"实现原理\">实现原理<a title=\"#实现原理\" href=\"#实现原理\"></a></h3>\n<ul>\n<li>可见性\n<ul>\n<li>volatile 修饰的共享变量的写操作会触发“嗅探”，让处理器本地缓存中的 volatile 变量失效</li>\n<li>声明了 volatile 的变量进行写操作时，JVM 会向处理器发送一条 Lock 前缀的指令，将这个变量所在缓存行的数据写回到系统内存。这一步确保了如果有其他线程对声明了 volatile 变量进行修改，则立即更新主内存中数据</li>\n</ul>\n</li>\n<li>有序性\n<ul>\n<li>内存屏障的作用</li>\n</ul>\n</li>\n</ul>\n",
            "tags": [
                "并发"
            ]
        },
        {
            "id": "https://onion99.github.io/2021/11/04/cNDSpE5p4avS2tOi/",
            "url": "https://onion99.github.io/2021/11/04/cNDSpE5p4avS2tOi/",
            "title": "自定义View(11) - 滚动速度和滚动计算",
            "date_published": "2021-11-03T22:09:36.000Z",
            "content_html": "<h3 id=\"velocitytracker\">VelocityTracker<a title=\"#velocitytracker\" href=\"#velocitytracker\"></a></h3>\n<blockquote>\n<p>跟踪手指在滑动过程中的速度，包括水平和竖直方向的速度</p>\n</blockquote>\n<span id=\"more\"></span>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">VelocityTrackerTestView</span>(<span class=\"title\">context</span>: <span class=\"title\">Context</span>?, <span class=\"title\">attrs</span>: <span class=\"title\">AttributeSet</span>?) : <span class=\"title\">View</span>(<span class=\"title\">context</span>, <span class=\"title\">attrs</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//1、创建实例</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> mVelocityTracker = VelocityTracker.obtain()</span><br><span class=\"line\">    <span class=\"meta\">@SuppressLint(&quot;ClickableViewAccessibility&quot;)</span></span><br><span class=\"line\">    <span class=\"function\">override fun <span class=\"title\">onTouchEvent</span><span class=\"params\">(event: MotionEvent)</span>: Boolean </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//2、重置</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (event.actionMasked == MotionEvent.ACTION_DOWN) &#123;</span><br><span class=\"line\">            mVelocityTracker.clear()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//3、开始追踪</span></span><br><span class=\"line\">        mVelocityTracker.addMovement(event)</span><br><span class=\"line\"> </span><br><span class=\"line\">        when (event.actionMasked) &#123;</span><br><span class=\"line\">            MotionEvent.ACTION_DOWN -&gt; &#123;</span><br><span class=\"line\">                <span class=\"comment\">//...</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            MotionEvent.ACTION_MOVE -&gt; &#123;</span><br><span class=\"line\">                <span class=\"comment\">//o...</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            MotionEvent.ACTION_UP -&gt; &#123;</span><br><span class=\"line\">                <span class=\"comment\">//速度 = （ 终点位置(px) - 起点位置(px) ）/ 时间段(ms)</span></span><br><span class=\"line\">                <span class=\"comment\">//4、设置时间段</span></span><br><span class=\"line\">                mVelocityTracker.computeCurrentVelocity(<span class=\"number\">1000</span>)</span><br><span class=\"line\">                <span class=\"comment\">//5、获取x方向、y方向的速度</span></span><br><span class=\"line\">                <span class=\"comment\">//其中getXVelocity、getYVelocity方法的参数是pointerId，用于多指触控。不考虑多指时，可以不用传参数</span></span><br><span class=\"line\">                <span class=\"keyword\">var</span> xVelocity = mVelocityTracker.getXVelocity(<span class=\"number\">0</span>)</span><br><span class=\"line\">                <span class=\"keyword\">var</span> yVelocity = mVelocityTracker.getYVelocity(<span class=\"number\">0</span>)</span><br><span class=\"line\">                <span class=\"comment\">//...</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"function\">override fun <span class=\"title\">onDetachedFromWindow</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//6、当不需要使用时，重置并回收内存</span></span><br><span class=\"line\">        mVelocityTracker.clear()</span><br><span class=\"line\">        mVelocityTracker.recycle()</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onDetachedFromWindow()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>VelocityTracker 一般用来判断当前是否达到一定的滑动速度来触发 Fling 的效果，这个滑动速度我们可以自己设置，也可以通过系统提供的来获取</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">var</span> mViewConfiguration : ViewConfiguration = ViewConfiguration.get(context)</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">var</span> mMaxFlingVelocity = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"comment\">//触发fling的速度</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">var</span> mMinFlingVelocity = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">init &#123;</span><br><span class=\"line\">    mMaxFlingVelocity = mViewConfiguration.scaledMaximumFlingVelocity</span><br><span class=\"line\">    mMinFlingVelocity = mViewConfiguration.scaledMinimumFlingVelocity</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"scroller\">Scroller<a title=\"#scroller\" href=\"#scroller\"></a></h3>\n<p>在 View 类里面，有两个和滚动相关的类 scrollTo() 和 scrollBy。这两个方法可以实现 View 内容的移动，比如说一个 TextView，如果使用 scrollTo()，那么移动的是里面的文字而不是位置，scrollBy() 也是一样的。那么为什么是移动，不是滚动呢？这是因为这两个方法都是瞬间完成，而不是带有滚动过程的滚动，所以说如果要实现效果比较好的滚动还是需要 Scroller</p>\n<p>常用API:</p>\n<div class=\"φbq\"><div class=\"φbs\"><table><thead>\n<tr>\n<th style=\"text-align:center\">API</th>\n<th style=\"text-align:center\">简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">computeScrollOffset()</td>\n<td style=\"text-align:center\">判断当前的滑动动作是否完成的</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">getCurrX()、getCurrY()</td>\n<td style=\"text-align:center\">获取当前滑动的坐标值</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">getFinalX()、getFinalY()</td>\n<td style=\"text-align:center\">获取最终滑动停止时的坐标</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">isFinished()</td>\n<td style=\"text-align:center\">用来判断当前滚动是否结束</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">startScroll(int startX, int startY, int dx, int dy)</td>\n<td style=\"text-align:center\">用来开始滚动，这个是很重要的一个触发computeScroll()的方法，调用这个方法之后，我们就可以在computeScroll里面获取滚动的信息，然后完成我们的需要。这个还有一个带有滚动持续时间的重载函数，可以根据需求自由使用。特别要注意这四个参数，startX和startY是开始的坐标位置，正数左上，负数右下，dx、dy同理，当在computeScroll()获取getCurrX()的时候，变化范围就与这里地设置有关。</td>\n</tr>\n</tbody>\n</table></div></div><h3 id=\"overscroller\">OverScroller<a title=\"#overscroller\" href=\"#overscroller\"></a></h3>\n<blockquote>\n<p>对超出滑动边界的情况的处理</p>\n</blockquote>\n",
            "tags": [
                "图形绘制"
            ]
        },
        {
            "id": "https://onion99.github.io/2021/11/04/dY7a31QepeVitGkX/",
            "url": "https://onion99.github.io/2021/11/04/dY7a31QepeVitGkX/",
            "title": "自定义View(10) - GestureDetector",
            "date_published": "2021-11-03T22:08:39.000Z",
            "content_html": "<h3 id=\"gesturedetector\">GestureDetector<a title=\"#gesturedetector\" href=\"#gesturedetector\"></a></h3>\n<div class=\"φbq\"><div class=\"φbs\"><table><thead>\n<tr>\n<th>监听器</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>OnContextClickListener</td>\n<td>这个很容易让人联想到ContextMenu，然而它和ContextMenu并没有什么关系，它是在Android6.0(API 23)才添加的一个选项，是用于检测外部设备上的按钮是否按下的，例如蓝牙触控笔上的按钮，一般情况下，忽略即可。</td>\n</tr>\n<tr>\n<td>OnDoubleTapListener</td>\n<td>双击事件，有三个回调类型：双击(DoubleTap)、单击确认(SingleTapConfirmed) 和 双击事件回调(DoubleTapEvent)</td>\n</tr>\n<tr>\n<td>OnGestureListener</td>\n<td>手势检测，主要有以下类型事件：按下(Down)、 一扔(Fling)、长按(LongPress)、滚动(Scroll)、触摸反馈(ShowPress) 和 单击抬起(SingleTapUp)</td>\n</tr>\n<tr>\n<td>SimpleOnGestureListener</td>\n<td>这个是上述三个接口的空实现，一般情况下使用这个比较多，也比较方便</td>\n</tr>\n</tbody>\n</table></div></div><span id=\"more\"></span>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1.创建一个监听回调</span></span><br><span class=\"line\">SimpleOnGestureListener listener = <span class=\"keyword\">new</span> SimpleOnGestureListener() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onDoubleTap</span><span class=\"params\">(MotionEvent e)</span> </span>&#123;</span><br><span class=\"line\">        Toast.makeText(MainActivity.<span class=\"keyword\">this</span>, <span class=\"string\">&quot;双击666&quot;</span>, Toast.LENGTH_SHORT).show();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.onDoubleTap(e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// 2.创建一个检测器</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> GestureDetector detector = <span class=\"keyword\">new</span> GestureDetector(<span class=\"keyword\">this</span>, listener);</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// 3.给监听器设置数据源</span></span><br><span class=\"line\">view.setOnTouchListener(<span class=\"keyword\">new</span> View.OnTouchListener() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onTouch</span><span class=\"params\">(View v, MotionEvent event)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> detector.onTouchEvent(event);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"scalegesturedetector\">ScaleGestureDetector<a title=\"#scalegesturedetector\" href=\"#scalegesturedetector\"></a></h3>\n<blockquote>\n<p>Android 缩放手势检测 ScaleGestureDetector，在大多数的情况下缩放手势都不是单独存在的，需要配合其它的手势来使用</p>\n</blockquote>\n<h4 id=\"sample\">sample<a title=\"#sample\" href=\"#sample\"></a></h4>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ScaleGestureDemoView</span> <span class=\"keyword\">extends</span> <span class=\"title\">View</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String TAG = <span class=\"string\">&quot;ScaleGestureDemoView&quot;</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">private</span> ScaleGestureDetector mScaleGestureDetector;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ScaleGestureDemoView</span><span class=\"params\">(Context context)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(context);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ScaleGestureDemoView</span><span class=\"params\">(Context context, <span class=\"meta\">@Nullable</span> AttributeSet attrs)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(context, attrs);</span><br><span class=\"line\">        initScaleGestureDetector();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">initScaleGestureDetector</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        mScaleGestureDetector = <span class=\"keyword\">new</span> ScaleGestureDetector(getContext(), </span><br><span class=\"line\">                <span class=\"keyword\">new</span> ScaleGestureDetector.SimpleOnScaleGestureListener() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onScaleBegin</span><span class=\"params\">(ScaleGestureDetector detector)</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onScale</span><span class=\"params\">(ScaleGestureDetector detector)</span> </span>&#123;</span><br><span class=\"line\">                Log.i(TAG, <span class=\"string\">&quot;focusX = &quot;</span> + detector.getFocusX());       <span class=\"comment\">// 缩放中心，x坐标</span></span><br><span class=\"line\">                Log.i(TAG, <span class=\"string\">&quot;focusY = &quot;</span> + detector.getFocusY());       <span class=\"comment\">// 缩放中心y坐标</span></span><br><span class=\"line\">                Log.i(TAG, <span class=\"string\">&quot;scale = &quot;</span> + detector.getScaleFactor());   <span class=\"comment\">// 缩放因子</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onScaleEnd</span><span class=\"params\">(ScaleGestureDetector detector)</span> </span>&#123;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onTouchEvent</span><span class=\"params\">(MotionEvent event)</span> </span>&#123;</span><br><span class=\"line\">        mScaleGestureDetector.onTouchEvent(event);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n",
            "tags": [
                "图形绘制"
            ]
        },
        {
            "id": "https://onion99.github.io/2021/11/04/z3aQsRLVolBbFVsl/",
            "url": "https://onion99.github.io/2021/11/04/z3aQsRLVolBbFVsl/",
            "title": "自定义View(9) - 事件分发",
            "date_published": "2021-11-03T22:07:31.000Z",
            "content_html": "<blockquote>\n<p>事件分发的过程其实也就是事件传递过程。事件传递的顺序由Acticity传递到根View，这个根View 通常是一个ViewGroup(ViewGroup本身也是View的子类)，然后再传递给ViewGroup下的子View, 若事件在自上而下的传递过程中一直没有被消费，则事件会反向向上传递，此时父ViewGroup可以对事件进行消费，若仍然没有被消费的话，最后会回到Activity的onTouchEvent</p>\n</blockquote>\n<p>所以很多时候如果有冲突的话,最先消费的是最底部的子View<br>\n<img src=\"https://z3.ax1x.com/2021/11/03/IE3gqf.png\" alt=\"IE3gqf.png\" loading=\"lazy\"></p>\n<span id=\"more\"></span>\n<h3 id=\"事件分发method\">事件分发Method<a title=\"#事件分发method\" href=\"#事件分发method\"></a></h3>\n<div class=\"φbq\"><div class=\"φbs\"><table><thead>\n<tr>\n<th style=\"text-align:center\">方法</th>\n<th style=\"text-align:center\">作用</th>\n<th style=\"text-align:center\">调用时刻</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">dispatchTouchEvent()</td>\n<td style=\"text-align:center\">用来进行事件传递</td>\n<td style=\"text-align:center\">如果事件能够传递给当前 View，那么此方法一定会被调用</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">onInterceptTouchEvent()</td>\n<td style=\"text-align:center\">用来是否拦截事件</td>\n<td style=\"text-align:center\">如果当前 View 拦截了某个事件，那么在同一个事件序列当中，此方法不会被再次调用</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">onTouchEvent()</td>\n<td style=\"text-align:center\">处理事件</td>\n<td style=\"text-align:center\">在 dispatchTouchEvent()方法中调用</td>\n</tr>\n</tbody>\n</table></div></div><h3 id=\"事件分发顺序\">事件分发顺序<a title=\"#事件分发顺序\" href=\"#事件分发顺序\"></a></h3>\n<p>Activity&amp;Window</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">dispatchTouchEvent</span><span class=\"params\">(MotionEvent ev)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;</span><br><span class=\"line\">        onUserInteraction();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 当事件没有被任何子View 消费时,即这里为false时,最终执行自己的nTouchEvent</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (getWindow().superDispatchTouchEvent(ev)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> onTouchEvent(ev);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>DecorView(FrameLayout 的子类)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PhoneWindow</span> <span class=\"keyword\">extends</span> <span class=\"title\">Window</span> <span class=\"keyword\">implements</span> <span class=\"title\">MenuBuilder</span>.<span class=\"title\">Callback</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">superDispatchTouchEvent</span><span class=\"params\">(MotionEvent event)</span> </span>&#123;</span><br><span class=\"line\">\t    <span class=\"keyword\">return</span> mDecor.superDispatchTouchEvent(event);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DecorView</span> <span class=\"keyword\">extends</span> <span class=\"title\">FrameLayout</span> <span class=\"keyword\">implements</span> <span class=\"title\">RootViewSurfaceTaker</span></span>&#123;</span><br><span class=\"line\">\t    <span class=\"comment\">//FrameLayout 并没有重写dispatchTouchEvent方法，所以事件开始交由 ViewGroup 的 dispatchTouchEvent 开始分发了</span></span><br><span class=\"line\">\t    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">superDispatchTouchEvent</span><span class=\"params\">(MotionEvent event)</span> </span>&#123;</span><br><span class=\"line\">\t        <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.dispatchTouchEvent(event);</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>ViewGroup</p>\n<ul>\n<li>判断事件是够需要被 ViewGroup 拦截</li>\n<li>遍历所有子View，逐个分发事件</li>\n<li>将事件交给ViewGroup自己或者目标子View处理</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">dispatchTouchEvent</span><span class=\"params\">(MotionEvent ev)</span> </span>&#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> handled = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (onFilterTouchEventForSecurity(ev)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> action = ev.getAction();</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"comment\">// 先检验事件是否需要被ViewGroup拦截</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> intercepted;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 校验是否给mGroupFlags设置了FLAG_DISALLOW_INTERCEPT标志位</span></span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!disallowIntercept) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 走onInterceptTouchEvent判断是否拦截事件</span></span><br><span class=\"line\">                intercepted = onInterceptTouchEvent(ev);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                intercepted = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            intercepted = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!canceled &amp;&amp; !intercepted) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 注意ACTION_DOWN等事件才会走遍历所有子View的流程</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class=\"line\">                    || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN)</span><br><span class=\"line\">                    || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">                <span class=\"comment\">// 开始遍历所有子View开始逐个分发事件</span></span><br><span class=\"line\">                <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> childrenCount = mChildrenCount;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (childrenCount != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = childrenCount - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 判断触摸点是否在这个View的内部</span></span><br><span class=\"line\">                        <span class=\"keyword\">final</span> View child = children[i];</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (!canViewReceivePointerEvents(child)</span><br><span class=\"line\">                                || !isTransformedTouchPointInView(x, y, child, <span class=\"keyword\">null</span>)) &#123;</span><br><span class=\"line\">                            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    </span><br><span class=\"line\">                        <span class=\"comment\">// 事件被子View消费，退出循环，不再继续分发给其他子View</span></span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (dispatchTransformedTouchEvent(ev, <span class=\"keyword\">false</span>, child, idBitsToAssign)) &#123;</span><br><span class=\"line\">                        </span><br><span class=\"line\">                            <span class=\"comment\">// addTouchTarget内部将mFirstTouchTarget设置为child，即不为null</span></span><br><span class=\"line\">                            newTouchTarget = addTouchTarget(child, idBitsToAssign);</span><br><span class=\"line\">                            alreadyDispatchedToNewTouchTarget = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 事件未被任何子View消费，自己处理</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mFirstTouchTarget == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// No touch targets so treat this as an ordinary view.</span></span><br><span class=\"line\">            handled = dispatchTransformedTouchEvent(ev, canceled, <span class=\"keyword\">null</span>,</span><br><span class=\"line\">                    TouchTarget.ALL_POINTER_IDS);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 将MotionEvent.ACTION_DOWN后续事件分发给mFirstTouchTarget指向的View</span></span><br><span class=\"line\">            TouchTarget predecessor = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            TouchTarget target = mFirstTouchTarget;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (target != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">final</span> TouchTarget next = target.next;</span><br><span class=\"line\">                <span class=\"comment\">// 如果已经在上面的遍历过程中传递过事件，跳过本次传递</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123;</span><br><span class=\"line\">                    handled = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> cancelChild = resetCancelNextUpFlag(target.child)</span><br><span class=\"line\">                            || intercepted;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (dispatchTransformedTouchEvent(ev, cancelChild,</span><br><span class=\"line\">                            target.child, target.pointerIdBits)) &#123;</span><br><span class=\"line\">                        handled = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                </span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                predecessor = target;</span><br><span class=\"line\">                target = next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// Update list of touch targets for pointer up or cancel, if needed.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (canceled</span><br><span class=\"line\">                || actionMasked == MotionEvent.ACTION_UP</span><br><span class=\"line\">                || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;</span><br><span class=\"line\">            resetTouchState();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_UP) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> actionIndex = ev.getActionIndex();</span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> idBitsToRemove = <span class=\"number\">1</span> &lt;&lt; ev.getPointerId(actionIndex);</span><br><span class=\"line\">            removePointersFromTouchTargets(idBitsToRemove);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> handled;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">resetTouchState</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    clearTouchTargets();</span><br><span class=\"line\">    resetCancelNextUpFlag(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    mGroupFlags &amp;= ~FLAG_DISALLOW_INTERCEPT;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">clearTouchTargets</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    TouchTarget target = mFirstTouchTarget;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (target != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">            TouchTarget next = target.next;</span><br><span class=\"line\">            target.recycle();</span><br><span class=\"line\">            target = next;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">while</span> (target != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        mFirstTouchTarget = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> TouchTarget <span class=\"title\">addTouchTarget</span><span class=\"params\">(View child, <span class=\"keyword\">int</span> pointerIdBits)</span> </span>&#123;</span><br><span class=\"line\">    TouchTarget target = TouchTarget.obtain(child, pointerIdBits);</span><br><span class=\"line\">    target.next = mFirstTouchTarget;</span><br><span class=\"line\">    mFirstTouchTarget = target;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> target;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">dispatchTransformedTouchEvent</span><span class=\"params\">(MotionEvent event, <span class=\"keyword\">boolean</span> cancel,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                              View child, <span class=\"keyword\">int</span> desiredPointerIdBits)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> handled;</span><br><span class=\"line\">    <span class=\"comment\">// 注意传参child为null时，调用的是自己的dispatchTouchEvent</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (child == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        handled = <span class=\"keyword\">super</span>.dispatchTouchEvent(event);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        handled = child.dispatchTouchEvent(transformedEvent);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> handled;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onInterceptTouchEvent</span><span class=\"params\">(MotionEvent ev)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 默认不拦截事件</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>View:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">dispatchTouchEvent</span><span class=\"params\">(MotionEvent event)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (onFilterTouchEventForSecurity(event)) &#123;</span><br><span class=\"line\">        \t<span class=\"comment\">// 判断事件是否先交给ouTouch方法处理</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mOnTouchListener != <span class=\"keyword\">null</span> &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp;</span><br><span class=\"line\">                    mOnTouchListener.onTouch(<span class=\"keyword\">this</span>, event)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// onTouch未消费事件，传给onTouchEvent</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (onTouchEvent(event)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"综上\">综上<a title=\"#综上\" href=\"#综上\"></a></h3>\n<ul>\n<li>View 事件分发的本质是递归。</li>\n<li>递归的本质是，任务的下发和结果的上报。</li>\n<li>View 事件分发设计成递归，是为了配合 View 的排版规则，形成符合用户直觉的触控体验。</li>\n<li>View 事件分发的对象是一个 MotionEvent。</li>\n<li>一次用户触控操作包含多个 MotionEvent（例如从 ACTION_DOWN 到 ACTION_UP ），也即会走多次事件分发流程。</li>\n<li>一次 View 事件分发流程包含 “递” 流程和 “归” 流程，“递” 流程可以因 ViewGroup 的拦截而提前步入 “归” 流程。</li>\n<li>child 可以通过 getParent.requestDisallowInterceptTouchEvent 阻止父容器的拦截。因而需要差异化地配置阈值，来确保 child 执行 getParent.requestDisallowInterceptTouchEvent 优先于父容器 onInterceptTouchEvent 返回 true（不然都先被拦截了，child 哪有机会阻止？）</li>\n<li>在“归”流程中，唯有当前层级的 super.dispatchTouchEvent 返回了 true，才认定被消费，被消费前，下级都有干活，只是结果不 OK。被消费后，上级都不需要干活，直接向上传达消费者的功。</li>\n</ul>\n<h3 id=\"事件冲突解决\">事件冲突解决<a title=\"#事件冲突解决\" href=\"#事件冲突解决\"></a></h3>\n<ul>\n<li>从父View着手, 重写onInterceptTouchEvent方法，在父View需要拦截的时候拦截，不要的时候返回false</li>\n<li>从子View着手, 重写子 View的dispatchTouchEvent方法，在Action_down 动作中通过方法 requestDisallowInterceptTouchEvent（true） 先请求 父 View不要拦截事件，这样保证子 View 能够接受到 Action_move 事件，再在 Action_move 动作中根据自己的逻辑是否要拦截事件，不需要拦截事件的话再交给 父 View 处理</li>\n</ul>\n<h3 id=\"refer\">Refer<a title=\"#refer\" href=\"#refer\"></a></h3>\n<p><a href=\"https://juejin.cn/post/6844903894103883789\" target=\"_blank\">学习 View 事件分发，就像外地人上了黑车！ - 掘金 (juejin.cn)</a><br>\n<a href=\"https://juejin.cn/post/6965649194744807461\" target=\"_blank\">View 事件分发机制，看这一篇就够了 - 掘金 (juejin.cn)</a><br>\n<a href=\"https://blog.csdn.net/u010289802/article/details/86169939\" target=\"_blank\">Android 手把手进阶自定义View（十）- 事件分发机制解析_lerendan的博客-CSDN博客</a></p>\n",
            "tags": [
                "图形绘制"
            ]
        },
        {
            "id": "https://onion99.github.io/2021/11/04/p4CRfuQemJ4TOlAs/",
            "url": "https://onion99.github.io/2021/11/04/p4CRfuQemJ4TOlAs/",
            "title": "自定义View(8) - draw 绘制过程",
            "date_published": "2021-11-03T22:03:38.000Z",
            "content_html": "<blockquote>\n<p>Android 里面的绘制都是按顺序的，先绘制的内容会被后绘制的盖住</p>\n</blockquote>\n<p><img src=\"https://z3.ax1x.com/2021/11/03/IES7KP.png\" alt=\"IES7KP.png\" loading=\"lazy\" class=\"φbp\"></p>\n<span id=\"more\"></span>\n<h3 id=\"draw-过程解析\">draw 过程解析<a title=\"#draw-过程解析\" href=\"#draw-过程解析\"></a></h3>\n<p>一个完整的绘制过程会依次绘制以下几个内容：<br>\n<img src=\"https://z3.ax1x.com/2021/11/03/IEp3Ie.png\" alt=\"IEp3Ie.png\" loading=\"lazy\"></p>\n<ul>\n<li><code>drawBackground()</code>绘制背景\n<ul>\n<li>这个方法是 private 的，不能重写，你如果要设置背景，只能用自带的 API 去设置</li>\n</ul>\n</li>\n<li><code>onDraw()</code>绘制主体\n<ul>\n<li>这个方法在 View 和 ViewGroup 里都是空实现，因此自定义时需要复写</li>\n</ul>\n</li>\n<li><code>dispatchDraw()</code>绘制子 View\n<ul>\n<li>在于单一 View 中无子 View，故在 View 中此方法默认为空实</li>\n<li>在 ViewGroup中系统已经复写好此方法对其子视图进行绘制因此我们不需要复写</li>\n</ul>\n</li>\n<li><code>onDrawForeground()</code>滑动边缘渐变和滑动条以及前景</li>\n</ul>\n<p>ViewGroup中的<code>dispatchDraw()</code>:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">dispatchDraw</span><span class=\"params\">(Canvas canvas)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> usingRenderNodeProperties = canvas.isRecordingFor(mRenderNode);</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> childrenCount = mChildrenCount;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> View[] children = mChildren;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> flags = mGroupFlags;</span><br><span class=\"line\">    <span class=\"comment\">// 动画处理</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((flags &amp; FLAG_RUN_ANIMATION) != <span class=\"number\">0</span> &amp;&amp; canAnimate()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> buildCache = !isHardwareAccelerated();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; childrenCount; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> View child = children[i];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">final</span> LayoutParams params = child.getLayoutParams();</span><br><span class=\"line\">                attachLayoutAnimationParameters(child, params, i, childrenCount);</span><br><span class=\"line\">                bindLayoutAnimation(child);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// xxx</span></span><br><span class=\"line\">        controller.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 间距处理</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> clipSaveCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> clipToPadding = (flags &amp; CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (clipToPadding) &#123;</span><br><span class=\"line\">        clipSaveCount = canvas.save(Canvas.CLIP_SAVE_FLAG);</span><br><span class=\"line\">        canvas.clipRect(mScrollX + mPaddingLeft, mScrollY + mPaddingTop,</span><br><span class=\"line\">                mScrollX + mRight - mLeft - mPaddingRight,</span><br><span class=\"line\">                mScrollY + mBottom - mTop - mPaddingBottom);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 遍历子View</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; childrenCount; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((transientChild.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE ||transientChild.getAnimation() != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 2. 绘制子View视图    </span></span><br><span class=\"line\">                more |= drawChild(canvas, transientChild, drawingTime);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"draw顺序\">draw顺序<a title=\"#draw顺序\" href=\"#draw顺序\"></a></h3>\n<h4 id=\"ondraw()\">onDraw()<a title=\"#ondraw()\" href=\"#ondraw()\"></a></h4>\n<blockquote>\n<p>自定义绘制最基本的形态：继承 View 类，在 onDraw() 中完全自定义它的绘制</p>\n</blockquote>\n<p>定义 View 时，绘制代码写在 super.onDraw() 的上面还是下面都无所谓,但基于已有控件的自定义绘制，就不能不考虑 <code>super.onDraw()</code> 了，你需要根据自己的需求，判断出你绘制的内容需要盖住控件原有的内容还是需要被控件原有的内容盖住，从而确定你的绘制代码是应该写在 super.onDraw() 的上面还是下面。</p>\n<div class=\"φbq\"><div class=\"φbs\"><table><thead>\n<tr>\n<th style=\"text-align:center\">上面</th>\n<th style=\"text-align:center\">下面</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><img src=\"https://z3.ax1x.com/2021/11/03/IEFrgH.png\" alt=\"IEFrgH.png\" loading=\"lazy\"></td>\n<td style=\"text-align:center\"><img src=\"https://z3.ax1x.com/2021/11/03/IEFHrn.png\" alt=\"IEFHrn.png\" loading=\"lazy\"></td>\n</tr>\n</tbody>\n</table></div></div><h4 id=\"dispatchdraw()\">dispatchDraw()<a title=\"#dispatchdraw()\" href=\"#dispatchdraw()\"></a></h4>\n<blockquote>\n<p>如果想在一个ViewGroup中按上面的做法在下面添加绘制内容则是不行的,因为在绘制过程中每一个 ViewGroup 会先调用自己的 onDraw() 来绘制完自己的主体之后再去绘制它的子 View,会覆盖其主体</p>\n</blockquote>\n<p><img src=\"https://z3.ax1x.com/2021/11/03/IEEpH1.png\" alt=\"IEEpH1.png\" loading=\"lazy\" class=\"φbp\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SpottedLinearLayout</span> <span class=\"keyword\">extends</span> <span class=\"title\">LinearLayout</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">// 把 onDraw() 换成了 dispatchDraw()</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">dispatchDraw</span><span class=\"params\">(Canvas canvas)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">super</span>.dispatchDraw(canvas);</span><br><span class=\"line\">       ... <span class=\"comment\">// 绘制斑点</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>虽然 View 和 ViewGroup 都有 dispatchDraw() 方法，不过由于 View 是没有子 View 的，所以一般来说 dispatchDraw() 这个方法只对 ViewGroup（以及它的子类）有意义。</p>\n<h4 id=\"ondrawforeground()\">onDrawForeground()<a title=\"#ondrawforeground()\" href=\"#ondrawforeground()\"></a></h4>\n<blockquote>\n<p>前景前后处理</p>\n</blockquote>\n<p>在 super.onDrawForeground() 的上面</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AppImageView</span> <span class=\"keyword\">extends</span> <span class=\"title\">ImageView</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onDrawForeground</span><span class=\"params\">(Canvas canvas)</span> </span>&#123;</span><br><span class=\"line\">       ... <span class=\"comment\">// 绘制「New」标签</span></span><br><span class=\"line\">       <span class=\"keyword\">super</span>.onDrawForeground(canvas);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://z3.ax1x.com/2021/11/03/IEVgSS.png\" alt=\"IEVgSS.png\" loading=\"lazy\" class=\"φbp\"></p>\n<p>在 super.onDrawForeground() 的下面:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AppImageView</span> <span class=\"keyword\">extends</span> <span class=\"title\">ImageView</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onDrawForeground</span><span class=\"params\">(Canvas canvas)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">super</span>.onDrawForeground(canvas);</span><br><span class=\"line\">       ... <span class=\"comment\">// 绘制「New」标签</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://z3.ax1x.com/2021/11/03/IEZV0A.png\" alt=\"IEZV0A.png\" loading=\"lazy\" class=\"φbp\"></p>\n<h4 id=\"draw()\">draw()<a title=\"#draw()\" href=\"#draw()\"></a></h4>\n<h3 id=\"总结\">总结<a title=\"#总结\" href=\"#总结\"></a></h3>\n<p><img src=\"https://z3.ax1x.com/2021/11/03/IEZ1XQ.png\" alt=\"IEZ1XQ.png\" loading=\"lazy\" class=\"φbp\"></p>\n",
            "tags": [
                "图形绘制"
            ]
        },
        {
            "id": "https://onion99.github.io/2021/11/04/ZyOr4iLxJj7nAQxR/",
            "url": "https://onion99.github.io/2021/11/04/ZyOr4iLxJj7nAQxR/",
            "title": "自定义View(7) - layout 布局过程",
            "date_published": "2021-11-03T22:02:46.000Z",
            "content_html": "<p><img src=\"https://s2.ax1x.com/2019/12/06/QJQEcR.jpg\" alt=\"viewasds\" loading=\"lazy\" class=\"φbp\"></p>\n<span id=\"more\"></span>\n<h3 id=\"layout-类型\">layout 类型<a title=\"#layout-类型\" href=\"#layout-类型\"></a></h3>\n<p><img src=\"https://z3.ax1x.com/2021/11/03/IA7tv4.png\" alt=\"IA7tv4.png\" loading=\"lazy\" class=\"φbp\"></p>\n<h3 id=\"view-的-layout-过程\">View 的 layout 过程<a title=\"#view-的-layout-过程\" href=\"#view-的-layout-过程\"></a></h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 指定视图及其所有子视图的大小和位置 这是布局机制的第二阶段</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">layout</span><span class=\"params\">(<span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> t, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> b)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 判断是否measure,没有的话再measure一遍</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec);</span><br><span class=\"line\">        mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 当前视图的四个顶点</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> oldL = mLeft;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> oldT = mTop;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> oldB = mBottom;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> oldR = mRight;</span><br><span class=\"line\">    <span class=\"comment\">// 判断视图大小或者位置是否发生改变</span></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> changed = isLayoutModeOptical(mParent) ?</span><br><span class=\"line\">            setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);</span><br><span class=\"line\">    <span class=\"comment\">// 发生改变        </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123;</span><br><span class=\"line\">        onLayout(changed, l, t, r, b);</span><br><span class=\"line\">        <span class=\"comment\">// 对于单一View的laytou过程：由于单一View是没有子View的，故onLayout（）是一个空实现-&gt;&gt;分析3</span></span><br><span class=\"line\">        <span class=\"comment\">// 对于ViewGroup的laytou过程：由于确定位置与具体布局有关，所以onLayout（）在ViewGroup为1个抽象方法，需重写实现</span></span><br><span class=\"line\"></span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://z3.ax1x.com/2021/11/03/IAqjZd.png\" alt=\"IAqjZd.png\" loading=\"lazy\" class=\"φbp\"></p>\n<h3 id=\"viewgroup-的-layout-过程\">ViewGroup 的 layout 过程<a title=\"#viewgroup-的-layout-过程\" href=\"#viewgroup-的-layout-过程\"></a></h3>\n<blockquote>\n<p>ViewGroup 的 layout 过程确定位置与具体的布局有关，所以在 ViewGroup 中是一个抽象方法，需要重写实现</p>\n</blockquote>\n<p>复写<code> onLayout()</code>步骤:</p>\n<ol>\n<li>遍历所有子 View</li>\n<li>根据自身需求计算当前子 View 的四个位置值（需自身实现）</li>\n<li>根据上述 4 个位置的计算值，设置子 View 的 4 个顶点：调用子 View 的 layout 方法，即确定了子 View 在父容器里的位置</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ViewGroup的onLayout实现的大致思路</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onLayout</span><span class=\"params\">(<span class=\"keyword\">boolean</span> changed, <span class=\"keyword\">int</span> left, <span class=\"keyword\">int</span> top, <span class=\"keyword\">int</span> right, <span class=\"keyword\">int</span> bottom)</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// 参数说明</span></span><br><span class=\"line\">   <span class=\"comment\">// changed 当前View的大小和位置改变了 </span></span><br><span class=\"line\">   <span class=\"comment\">// left 左部位置  top 顶部位置  right 右部位置  bottom 底部位置</span></span><br><span class=\"line\">   <span class=\"comment\">// 1. 遍历子View：循环所有子View</span></span><br><span class=\"line\">   <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;getChildCount(); i++) &#123;</span><br><span class=\"line\">         View child = getChildAt(i);   </span><br><span class=\"line\">         <span class=\"comment\">// 2. 计算当前子View的四个位置值</span></span><br><span class=\"line\">         <span class=\"comment\">// 2.1 位置的计算逻辑需自己实现，也是自定义View的关键</span></span><br><span class=\"line\">         calculate();</span><br><span class=\"line\">         <span class=\"comment\">// 2.2 对计算后的位置值进行赋值</span></span><br><span class=\"line\">         <span class=\"keyword\">int</span> mLeft  = Left</span><br><span class=\"line\">         <span class=\"keyword\">int</span> mTop  = Top</span><br><span class=\"line\">         <span class=\"keyword\">int</span> mRight = Right</span><br><span class=\"line\">         <span class=\"keyword\">int</span> mBottom = Bottom</span><br><span class=\"line\"> </span><br><span class=\"line\">       <span class=\"comment\">// 3. 根据上述4个位置的计算值设置子View的4个顶点：调用子view的layout() &amp; 传递计算过的参数</span></span><br><span class=\"line\">       <span class=\"comment\">// 即确定了子View在父容器的位置</span></span><br><span class=\"line\">       child.layout(mLeft, mTop, mRight, mBottom);</span><br><span class=\"line\">       <span class=\"comment\">// 该过程类似于单一View的layout过程中的layout()和onLayout()</span></span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://z3.ax1x.com/2021/11/03/IAL1L4.png\" alt=\"IAL1L4.png\" loading=\"lazy\" class=\"φbp\"></p>\n<h4 id=\"viewgroup-子类（linearlayout）的-layout-过程分析\">ViewGroup 子类（LinearLayout）的 layout 过程分析<a title=\"#viewgroup-子类（linearlayout）的-layout-过程分析\" href=\"#viewgroup-子类（linearlayout）的-layout-过程分析\"></a></h4>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onLayout</span><span class=\"params\">(<span class=\"keyword\">boolean</span> changed, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> t, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> b)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 根据自身方向属性，而选择不同的处理方式</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mOrientation == VERTICAL) &#123;</span><br><span class=\"line\">        layoutVertical(l, t, r, b);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        layoutHorizontal(l, t, r, b);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>根据 LinearLayout 的方向（vertical、horizontal）进入不同的布局过程，这里我们只选垂直方向的布局过程，即layoutVertical()</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">layoutVertical</span><span class=\"params\">(<span class=\"keyword\">int</span> left, <span class=\"keyword\">int</span> top, <span class=\"keyword\">int</span> right, <span class=\"keyword\">int</span> bottom)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 子View的数量</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> count = getVirtualChildCount();</span><br><span class=\"line\">    <span class=\"comment\">// 1. 遍历子View</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; count; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> View child = getVirtualChildAt(i);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (child == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            childTop += measureNullChild(i);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (child.getVisibility() != GONE) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 2. 计算子View的测量宽 / 高值</span></span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> childWidth = child.getMeasuredWidth();</span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> childHeight = child.getMeasuredHeight();</span><br><span class=\"line\"> </span><br><span class=\"line\">            <span class=\"comment\">// 3. 确定自身子View的位置</span></span><br><span class=\"line\">            <span class=\"comment\">// 即：递归调用子View的setChildFrame()，实际上是调用了子View的layout() -&gt;&gt;分析2</span></span><br><span class=\"line\">            setChildFrame(child, childLeft, childTop + getLocationOffset(child), childWidth, childHeight);</span><br><span class=\"line\"> </span><br><span class=\"line\">            <span class=\"comment\">// childTop逐渐增大，即后面的子元素会被放置在靠下的位置</span></span><br><span class=\"line\">            <span class=\"comment\">// 这符合垂直方向的LinearLayout的特性</span></span><br><span class=\"line\">            childTop += childHeight + lp.bottomMargin + getNextLocationOffset(child);</span><br><span class=\"line\"> </span><br><span class=\"line\">            i += getChildrenSkipCount(child, i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">setChildFrame</span><span class=\"params\">( View child, <span class=\"keyword\">int</span> left, <span class=\"keyword\">int</span> top, <span class=\"keyword\">int</span> width, <span class=\"keyword\">int</span> height)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// setChildFrame（）仅仅只是调用了子View的layout（）而已</span></span><br><span class=\"line\">    child.layout(left, top, left ++ width, top + height);</span><br><span class=\"line\">    <span class=\"comment\">// 在子View的layout（）又通过调用setFrame（）确定View的四个顶点</span></span><br><span class=\"line\">    <span class=\"comment\">// 即确定了子View的位置</span></span><br><span class=\"line\">    <span class=\"comment\">// 如此不断循环确定所有子View的位置，最终确定ViewGroup的位置</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"getmeasurewidth-和-getwidth-区别\">getMeasureWidth 和 getWidth 区别<a title=\"#getmeasurewidth-和-getwidth-区别\" href=\"#getmeasurewidth-和-getwidth-区别\"></a></h3>\n<blockquote>\n<p>某些情况下，View 需要多次 measure 才能确定自己的测量宽高，在前几次的测量过程中，其得出的测量宽高有可能和最终宽高不一致.，但最终来说，测量宽高还是和最终宽高相同。</p>\n</blockquote>\n<p><img src=\"https://z3.ax1x.com/2021/11/03/IAjrmF.png\" alt=\"IAjrmF.png\" loading=\"lazy\" class=\"φbp\"></p>\n",
            "tags": [
                "图形绘制"
            ]
        },
        {
            "id": "https://onion99.github.io/2021/11/04/Qj9f1VMJJowv5Lfb/",
            "url": "https://onion99.github.io/2021/11/04/Qj9f1VMJJowv5Lfb/",
            "title": "自定义View(6) - measure 测量过程",
            "date_published": "2021-11-03T22:00:58.000Z",
            "content_html": "<p><img src=\"https://s2.ax1x.com/2019/12/06/QJQEcR.jpg\" alt=\"QJQEcR.jpg\" loading=\"lazy\" class=\"φbp\"></p>\n<span id=\"more\"></span>\n<h3 id=\"measurespec\">MeasureSpec<a title=\"#measurespec\" href=\"#measurespec\"></a></h3>\n<blockquote>\n<p>MeasureSpec 代表测量规格，是一个 32 位的 int 值，高 2 位代表 SpecMode（测量模式），低 30 位代表 SpecSize（测量大小）</p>\n</blockquote>\n<p><img src=\"https://z3.ax1x.com/2021/11/02/IF7OM9.png\" alt=\"IF7OM9.png\" loading=\"lazy\" class=\"φbp\"></p>\n<p>MeasureSpec 通过将 SpecMode 和 SpecSize 打包成一个 int 值来避免过多的内存分配，并提供了打包和解包的方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onMeasure</span><span class=\"params\">(<span class=\"keyword\">int</span> widthMeasureSpec, <span class=\"keyword\">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> widthMode = MeasureSpec.getMode(widthMeasureSpec);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> widthSize = MeasureSpec.getSize(widthMeasureSpec);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> heightMode = MeasureSpec.getMode(heightMeasureSpec);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> heightSize = MeasureSpec.getSize(heightMeasureSpec);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"specmode\">SpecMode<a title=\"#specmode\" href=\"#specmode\"></a></h4>\n<p><img src=\"https://z3.ax1x.com/2021/11/02/IFbTc4.png\" alt=\"IFbTc4.png\" loading=\"lazy\" class=\"φbp\"></p>\n<h3 id=\"measurespec值计算\">MeasureSpec值计算<a title=\"#measurespec值计算\" href=\"#measurespec值计算\"></a></h3>\n<blockquote>\n<p>View 的 MeasureSpec 值是由 View 的布局参数和父容器 的 MeasureSpec 值计算</p>\n</blockquote>\n<p><img src=\"https://z3.ax1x.com/2021/11/03/IAVp1e.png\" alt=\"IAVp1e.png\" loading=\"lazy\" class=\"φbp\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 源码分析：getChildMeasureSpec（）</span></span><br><span class=\"line\"><span class=\"comment\"> * 作用：根据父视图的MeasureSpec &amp; 布局参数LayoutParams，计算单个子View的MeasureSpec</span></span><br><span class=\"line\"><span class=\"comment\"> * 注：子view的大小由父view的MeasureSpec值 和 子view的LayoutParams属性 共同决定</span></span><br><span class=\"line\"><span class=\"comment\"> * 参数说明</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> spec           父view的详细测量值 (MeasureSpec)</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> padding        view当前尺寸的的内边距和外边距(padding, margin)</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> childDimension 子视图的布局参数（宽 / 高）</span></span><br><span class=\"line\"><span class=\"comment\"> **/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">getChildMeasureSpec</span><span class=\"params\">(<span class=\"keyword\">int</span> spec, <span class=\"keyword\">int</span> padding, <span class=\"keyword\">int</span> childDimension)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//父view的测量模式</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> specMode = MeasureSpec.getMode(spec);</span><br><span class=\"line\">    <span class=\"comment\">//父view的大小</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> specSize = MeasureSpec.getSize(spec);</span><br><span class=\"line\">    <span class=\"comment\">//通过父view计算出的子view大小 = 父大小-边距（父要求的大小，但子view不一定用这个值）   </span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> size = Math.max(<span class=\"number\">0</span>, specSize - padding);</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">//子view想要的实际大小和模式（需要计算）  </span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> resultSize = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> resultMode = <span class=\"number\">0</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">//通过父view的MeasureSpec和子view的LayoutParams确定子view的大小  </span></span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (specMode) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//当父view的模式为EXACITY时，父view强加给子view确切的值</span></span><br><span class=\"line\">        <span class=\"comment\">//一般是父view设置为match_parent或者固定值的ViewGroup </span></span><br><span class=\"line\">        <span class=\"keyword\">case</span> MeasureSpec.EXACTLY:</span><br><span class=\"line\">            <span class=\"comment\">// 当子view的LayoutParams&gt;0，即有确切的值  </span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (childDimension &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//子view大小为子自身所赋的值，模式大小为EXACTLY  </span></span><br><span class=\"line\">                resultSize = childDimension;</span><br><span class=\"line\">                resultMode = MeasureSpec.EXACTLY;</span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"comment\">//当子view的LayoutParams为MATCH_PARENT时(-1)  </span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//子view大小为父view大小，模式为EXACTLY  </span></span><br><span class=\"line\">                resultSize = size;</span><br><span class=\"line\">                resultMode = MeasureSpec.EXACTLY;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// 当子view的LayoutParams为WRAP_CONTENT时(-2)      </span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//子view决定自己的大小，但最大不能超过父view，模式为AT_MOST  </span></span><br><span class=\"line\">                resultSize = size;</span><br><span class=\"line\">                resultMode = MeasureSpec.AT_MOST;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"comment\">// 当父view的模式为AT_MOST时，父view强加给子view一个最大的值。（一般是父view设置为wrap_content）  </span></span><br><span class=\"line\">        <span class=\"keyword\">case</span> MeasureSpec.AT_MOST:</span><br><span class=\"line\">            <span class=\"comment\">// 道理同上  </span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (childDimension &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                resultSize = childDimension;</span><br><span class=\"line\">                resultMode = MeasureSpec.EXACTLY;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class=\"line\">                resultSize = size;</span><br><span class=\"line\">                resultMode = MeasureSpec.AT_MOST;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class=\"line\">                resultSize = size;</span><br><span class=\"line\">                resultMode = MeasureSpec.AT_MOST;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"comment\">// 当父view的模式为UNSPECIFIED时，父容器不对view有任何限制，要多大给多大</span></span><br><span class=\"line\">        <span class=\"comment\">// 多见于ListView、GridView  </span></span><br><span class=\"line\">        <span class=\"keyword\">case</span> MeasureSpec.UNSPECIFIED:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (childDimension &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 子view大小为子自身所赋的值  </span></span><br><span class=\"line\">                resultSize = childDimension;</span><br><span class=\"line\">                resultMode = MeasureSpec.EXACTLY;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 因为父view为UNSPECIFIED，所以MATCH_PARENT的话子类大小为0  </span></span><br><span class=\"line\">                resultSize = <span class=\"number\">0</span>;</span><br><span class=\"line\">                resultMode = MeasureSpec.UNSPECIFIED;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 因为父view为UNSPECIFIED，所以WRAP_CONTENT的话子类大小为0  </span></span><br><span class=\"line\">                resultSize = <span class=\"number\">0</span>;</span><br><span class=\"line\">                resultMode = MeasureSpec.UNSPECIFIED;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> MeasureSpec.makeMeasureSpec(resultSize, resultMode);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://z3.ax1x.com/2021/11/03/IAemLj.png\" alt=\"IAemLj.png\" loading=\"lazy\" class=\"φbp\"></p>\n<h3 id=\"measure-过程\">Measure 过程<a title=\"#measure-过程\" href=\"#measure-过程\"></a></h3>\n<p><img src=\"https://z3.ax1x.com/2021/11/03/IAuMTA.png\" alt=\"IAuMTA.png\" loading=\"lazy\" class=\"φbp\"></p>\n<p>布局过程自定义的方式</p>\n<ol>\n<li>重写  <code>onMeasure()</code>  来修改已有的  <code>View</code>  的尺寸；</li>\n<li>重写  <code>onMeasure()</code>  来全新定制自定义  <code>View</code>  的尺寸；</li>\n<li>重写  <code>onMeasure()</code>  和  <code>onLayout()</code>  来全新定制自定义  <code>ViewGroup</code>  的内部布局。</li>\n</ol>\n<h4 id=\"view的measure\">View的measure<a title=\"#view的measure\" href=\"#view的measure\"></a></h4>\n<p>View 的 measure 过程由其<code>measure()</code> 方法完成：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 源码分析：measure（）</span></span><br><span class=\"line\"><span class=\"comment\">* 定义：Measure过程的入口；属于View.java类 &amp; final类型，即子类不能重写此方法</span></span><br><span class=\"line\"><span class=\"comment\">* 作用：基本测量逻辑的判断</span></span><br><span class=\"line\"><span class=\"comment\">**/</span> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">measure</span><span class=\"params\">(<span class=\"keyword\">int</span> widthMeasureSpec, <span class=\"keyword\">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">// 判断是否需要重新测量           </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (forceLayout || needsLayout) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"comment\">// 判断是否有缓存</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> cacheIndex = forceLayout ? -<span class=\"number\">1</span> : mMeasureCache.indexOfKey(key);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cacheIndex &lt; <span class=\"number\">0</span> || sIgnoreMeasureCache) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 开始测量</span></span><br><span class=\"line\">            onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class=\"line\">            mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">long</span> value = mMeasureCache.valueAt(cacheIndex);</span><br><span class=\"line\">            <span class=\"comment\">// Casting a long to int drops the high 32 bits, no mask needed</span></span><br><span class=\"line\">            setMeasuredDimensionRaw((<span class=\"keyword\">int</span>) (value &gt;&gt; <span class=\"number\">32</span>), (<span class=\"keyword\">int</span>) value);</span><br><span class=\"line\">            mPrivateFlags3 |= PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<p><code>setMeasuredDimension()</code>方法会设置 View 的宽/高的测量值，因此我们只需要看<code>getDefaultSize()</code> 方法即可</p>\n<p><img src=\"https://z3.ax1x.com/2021/11/03/IAGYZT.png\" alt=\"IAGYZT.png\" loading=\"lazy\" class=\"φbp\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * onMeasure（）要的做是事情</span></span><br><span class=\"line\"><span class=\"comment\"> * 1. 根据View宽/高的测量规格计算View的宽/高值：getDefaultSize()</span></span><br><span class=\"line\"><span class=\"comment\"> * 2. 存储测量后的View宽 / 高：setMeasuredDimension()</span></span><br><span class=\"line\"><span class=\"comment\"> **/</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onMeasure</span><span class=\"params\">(<span class=\"keyword\">int</span> widthMeasureSpec, <span class=\"keyword\">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class=\"line\">     setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),</span><br><span class=\"line\">             getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@param</span> size        提供的默认大小</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@param</span> measureSpec 宽/高的测量规格</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">getDefaultSize</span><span class=\"params\">(<span class=\"keyword\">int</span> size, <span class=\"keyword\">int</span> measureSpec)</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"comment\">// 设置默认大小</span></span><br><span class=\"line\">     <span class=\"keyword\">int</span> result = size;</span><br><span class=\"line\">     <span class=\"comment\">// 获取宽/高测量规格的模式 &amp; 测量大小</span></span><br><span class=\"line\">     <span class=\"keyword\">int</span> specMode = MeasureSpec.getMode(measureSpec);</span><br><span class=\"line\">     <span class=\"keyword\">int</span> specSize = MeasureSpec.getSize(measureSpec);</span><br><span class=\"line\">     <span class=\"keyword\">switch</span> (specMode) &#123;</span><br><span class=\"line\">       <span class=\"comment\">// 模式为UNSPECIFIED时，使用提供的默认大小 = 参数Size</span></span><br><span class=\"line\">       <span class=\"keyword\">case</span> MeasureSpec.UNSPECIFIED:</span><br><span class=\"line\">         result = size;</span><br><span class=\"line\">         <span class=\"keyword\">break</span>;</span><br><span class=\"line\">       <span class=\"comment\">// 模式为AT_MOST,EXACTLY时，使用View测量后的宽/高值 = measureSpec中的Size  </span></span><br><span class=\"line\">       <span class=\"keyword\">case</span> MeasureSpec.AT_MOST:</span><br><span class=\"line\">       <span class=\"keyword\">case</span> MeasureSpec.EXACTLY:</span><br><span class=\"line\">         result = specSize;</span><br><span class=\"line\">         <span class=\"keyword\">break</span>;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"comment\">// 返回View的宽/高值</span></span><br><span class=\"line\">     <span class=\"keyword\">return</span> result;</span><br><span class=\"line\"> &#125;  </span><br></pre></td></tr></table></figure>\n<p>当模式是 UNSPECIFIED 时，使用的是提供的默认大小:</p>\n<ul>\n<li>若 View 无设置背景，那么 View 的宽度 = mMinWidth。mMinWidth为 android:minWidth属性所指定的值，默认为 0</li>\n<li>若 View设置了背景，View 的宽度为 mMinWidth 和 mBackground.getMinimumWidth()中的最大值。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> <span class=\"title\">getSuggestedMinimumWidth</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (mBackground == <span class=\"keyword\">null</span>) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<div class=\"φbq\"><div class=\"φbs\"><table><thead>\n<tr>\n<th style=\"text-align:center\">过程</th>\n<th style=\"text-align:center\">行为作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><img src=\"https://z3.ax1x.com/2021/11/03/IAJ9mV.png\" alt=\"IAJ9mV.png\" loading=\"lazy\"></td>\n<td style=\"text-align:center\"><img src=\"https://z3.ax1x.com/2021/11/03/IAJ1te.png\" alt=\"IAJ1te.png\" loading=\"lazy\"></td>\n</tr>\n</tbody>\n</table></div></div><h4 id=\"viewgroup的measure\">ViewGroup的measure<a title=\"#viewgroup的measure\" href=\"#viewgroup的measure\"></a></h4>\n<blockquote>\n<p>ViewGroup是个抽象类,不同ViewGroup的onMeasure的实现都个不相同,除了完成自己的 measure 过程以外，还会遍历去调用所有子元素的 measure 方法，各个子元素再递归去执行这个过程</p>\n</blockquote>\n<ol>\n<li>遍历所有子 View &amp; 测量：measureChildren()</li>\n<li>合并所有子 View 的尺寸大小，最终得到 ViewGroup 的测量值（需自身实现）</li>\n<li>存储测量后 View 宽/高的值：调用 setMeasuredDimension()</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onMeasure</span><span class=\"params\">(<span class=\"keyword\">int</span> widthMeasureSpec, <span class=\"keyword\">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">// 定义存放测量后的View宽/高的变量</span></span><br><span class=\"line\">      <span class=\"keyword\">int</span> widthMeasure ;</span><br><span class=\"line\">      <span class=\"keyword\">int</span> heightMeasure ;</span><br><span class=\"line\">      <span class=\"comment\">// 1. 遍历所有子 View &amp; 测量(measureChildren())</span></span><br><span class=\"line\">      measureChildren(widthMeasureSpec, heightMeasureSpec)；</span><br><span class=\"line\">      <span class=\"comment\">// 2. 合并所有子View的尺寸大小，最终得到ViewGroup父视图的测量值</span></span><br><span class=\"line\">      <span class=\"comment\">// 需自身实现</span></span><br><span class=\"line\">      measureMerge();</span><br><span class=\"line\">      <span class=\"comment\">// 3. 存储测量后View宽/高的值：调用setMeasuredDimension()</span></span><br><span class=\"line\">      <span class=\"comment\">// 类似单一View的过程，此处不作过多描述</span></span><br><span class=\"line\">      setMeasuredDimension(widthMeasure,  heightMeasure);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>measureChildren()</code>遍历子 View 并且调用 measureChild() 进行下一步测量</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">measureChildren</span><span class=\"params\">(<span class=\"keyword\">int</span> widthMeasureSpec, <span class=\"keyword\">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 要求该视图的所有子视图度量自己，同时考虑该视图的MeasureSpec要求及其填充。我们跳过了处于GONE状态的子节点</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> size = mChildrenCount;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> View[] children = mChildren;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; size; ++i) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> View child = children[i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) &#123;</span><br><span class=\"line\">            measureChild(child, widthMeasureSpec, heightMeasureSpec);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<div class=\"φbq\"><div class=\"φbs\"><table><thead>\n<tr>\n<th style=\"text-align:center\">过程</th>\n<th style=\"text-align:center\">行为作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><img src=\"https://z3.ax1x.com/2021/11/03/IAokqI.png\" alt=\"IAokqI.png\" loading=\"lazy\"></td>\n<td style=\"text-align:center\"><img src=\"https://z3.ax1x.com/2021/11/03/IAo1Ln.png\" alt=\"IAo1Ln.png\" loading=\"lazy\"></td>\n</tr>\n</tbody>\n</table></div></div><h5 id=\"linearlayout-measure分析\">LinearLayout measure分析<a title=\"#linearlayout-measure分析\" href=\"#linearlayout-measure分析\"></a></h5>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onMeasure</span><span class=\"params\">(<span class=\"keyword\">int</span> widthMeasureSpec, <span class=\"keyword\">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 根据不同的布局属性进行不同的计算</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mOrientation == VERTICAL) &#123;</span><br><span class=\"line\">        measureVertical(widthMeasureSpec, heightMeasureSpec);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        measureHorizontal(widthMeasureSpec, heightMeasureSpec);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">measureVertical</span><span class=\"params\">(<span class=\"keyword\">int</span> widthMeasureSpec, <span class=\"keyword\">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取垂直方向上的子View个数</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> count = getVirtualChildCount();</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">// 遍历子View获取其高度，并记录下子View中最高的高度数值</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; count; ++i) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> View child = getVirtualChildAt(i);</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"comment\">// 子View不可见，直接跳过该View的measure过程，getChildrenSkipCount()返回值恒为0</span></span><br><span class=\"line\">        <span class=\"comment\">// 注：若view的可见属性设置为VIEW.INVISIBLE，还是会计算该view大小</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (child.getVisibility() == View.GONE) &#123;</span><br><span class=\"line\">           i += getChildrenSkipCount(child, i);</span><br><span class=\"line\">           <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"comment\">// 记录子View是否有weight属性设置，用于后面判断是否需要二次measure</span></span><br><span class=\"line\">        totalWeight += lp.weight;</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (heightMode == MeasureSpec.EXACTLY &amp;&amp; lp.height == <span class=\"number\">0</span> &amp;&amp; lp.weight &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果LinearLayout的specMode为EXACTLY且子View设置了weight属性，在这里会跳过子View的measure过程</span></span><br><span class=\"line\">            <span class=\"comment\">// 同时标记skippedMeasure属性为true，后面会根据该属性决定是否进行第二次measure</span></span><br><span class=\"line\">            <span class=\"comment\">// 若LinearLayout的子View设置了weight，会进行两次measure计算，比较耗时</span></span><br><span class=\"line\">            <span class=\"comment\">// 这就是为什么LinearLayout的子View需要使用weight属性时候，最好替换成RelativeLayout布局</span></span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> totalLength = mTotalLength;</span><br><span class=\"line\">            mTotalLength = Math.max(totalLength, totalLength + lp.topMargin + lp.bottomMargin);</span><br><span class=\"line\">            skippedMeasure = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> oldHeight = Integer.MIN_VALUE;</span><br><span class=\"line\">            <span class=\"comment\">// 步骤1：遍历所有子View &amp; 测量：measureChildren（）</span></span><br><span class=\"line\">            <span class=\"comment\">// 注：该方法内部，最终会调用measureChildren（），从而 遍历所有子View &amp; 测量</span></span><br><span class=\"line\">            measureChildBeforeLayout(child, i, widthMeasureSpec, <span class=\"number\">0</span>, heightMeasureSpec, totalWeight == <span class=\"number\">0</span> ? mTotalLength : <span class=\"number\">0</span>);</span><br><span class=\"line\">                   ...</span><br><span class=\"line\">            <span class=\"comment\">//步骤2：合并所有子View的尺寸大小,最终得到ViewGroup父视图的测量值（自身实现）</span></span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> childHeight = child.getMeasuredHeight();</span><br><span class=\"line\"> </span><br><span class=\"line\">            <span class=\"comment\">// 1. mTotalLength用于存储LinearLayout在竖直方向的高度</span></span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> totalLength = mTotalLength;</span><br><span class=\"line\"> </span><br><span class=\"line\">            <span class=\"comment\">// 2. 每测量一个子View的高度， mTotalLength就会增加</span></span><br><span class=\"line\">            mTotalLength = Math.max(totalLength, totalLength + childHeight + lp.topMargin +</span><br><span class=\"line\">                           lp.bottomMargin + getNextLocationOffset(child));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">// 3. 记录LinearLayout占用的总高度</span></span><br><span class=\"line\">    <span class=\"comment\">// 即除了子View的高度，还有本身的padding属性值</span></span><br><span class=\"line\">    mTotalLength += mPaddingTop + mPaddingBottom;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> heightSize = mTotalLength;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> heightSizeAndState = resolveSizeAndState(heightSize, heightMeasureSpec, <span class=\"number\">0</span>);</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">//步骤3：存储测量后View宽/高的值：调用setMeasuredDimension()</span></span><br><span class=\"line\">    setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState), heightSizeAndState);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"获取view的宽高\">获取View的宽高<a title=\"#获取view的宽高\" href=\"#获取view的宽高\"></a></h3>\n<blockquote>\n<p>Activity 启动时，在 onCreate()、onStart()、onResume() 中均无法正确的得到某个 View 的宽高信息，这是因为 View 的 measure 过程和 Activity 的生命周期方法不是同步执行的</p>\n</blockquote>\n<ul>\n<li>onWindowFocusChanged()\n<ul>\n<li>需要注意的是，onWindowFocusChanged() 会被调用多次，当 Activity 的窗口得到焦点和失去焦点时均会被调用一次。</li>\n</ul>\n</li>\n<li>View.post(runnable)</li>\n<li>ViewTreeObserver</li>\n<li>手动调用 View 的 measure 方法</li>\n</ul>\n<h3 id=\"refer\">Refer<a title=\"#refer\" href=\"#refer\"></a></h3>\n<p><a href=\"https://blog.csdn.net/u010289802/article/details/80183142\" target=\"_blank\">Android 知识体系学习目录_lerendan的博客-CSDN博客</a></p>\n",
            "tags": [
                "图形绘制"
            ]
        },
        {
            "id": "https://onion99.github.io/2021/11/04/SA664RldODNgeCrz/",
            "url": "https://onion99.github.io/2021/11/04/SA664RldODNgeCrz/",
            "title": "自定义View(5) - 动画",
            "date_published": "2021-11-03T21:59:44.000Z",
            "content_html": "<blockquote>\n<p>三者性能是一样的，因为 ViewPropertyAnimator 和 ObjectAnimator 的内部实现其实都是 ValueAnimator，ObjectAnimator 更是本来就是 ValueAnimator 的子类，差别只是使用的便捷性以及功能的灵活性。</p>\n</blockquote>\n<p><img src=\"https://z3.ax1x.com/2021/11/02/IFf4h9.gif\" alt=\"IFf4h9.gif\" loading=\"lazy\" class=\"φbp\"></p>\n<span id=\"more\"></span>\n<h3 id=\"viewpropertyanimator\">ViewPropertyAnimator<a title=\"#viewpropertyanimator\" href=\"#viewpropertyanimator\"></a></h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">view.animate()</span><br><span class=\"line\">        .scaleX(<span class=\"number\">1</span>)</span><br><span class=\"line\">        .scaleY(<span class=\"number\">1</span>)</span><br><span class=\"line\">        .alpha(<span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n<h3 id=\"objectanimator\">ObjectAnimator<a title=\"#objectanimator\" href=\"#objectanimator\"></a></h3>\n<blockquote>\n<p>多个动画配合执行</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PropertyValuesHolder holder1 = PropertyValuesHolder.ofFloat(<span class=\"string\">&quot;scaleX&quot;</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">PropertyValuesHolder holder2 = PropertyValuesHolder.ofFloat(<span class=\"string\">&quot;scaleY&quot;</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">PropertyValuesHolder holder3 = PropertyValuesHolder.ofFloat(<span class=\"string\">&quot;alpha&quot;</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">ObjectAnimator animator = ObjectAnimator.ofPropertyValuesHolder(view, holder1, holder2, holder3)</span><br><span class=\"line\">animator.start();</span><br></pre></td></tr></table></figure>\n<h3 id=\"valueanimator\">ValueAnimator<a title=\"#valueanimator\" href=\"#valueanimator\"></a></h3>\n<blockquote>\n<p>ValueAnimator 本身不作用于任何一个属性，也不提供任何一种动画。它就是一个数值发生器，可以产生想要的各种数值</p>\n</blockquote>\n<p>ValueAnimator 并不常用，因为它的功能太基础了。ValueAnimator 是 ObjectAnimator 的父类，实际上，ValueAnimator 就是一个不能指定目标对象版本的 ObjectAnimato</p>\n",
            "tags": [
                "图形绘制"
            ]
        },
        {
            "id": "https://onion99.github.io/2021/11/04/ZOnr24kULe7cQgsc/",
            "url": "https://onion99.github.io/2021/11/04/ZOnr24kULe7cQgsc/",
            "title": "自定义View(4) - Canvas相关",
            "date_published": "2021-11-03T21:58:53.000Z",
            "content_html": "<h3 id=\"范围裁切\">范围裁切<a title=\"#范围裁切\" href=\"#范围裁切\"></a></h3>\n<h4 id=\"cliprect\">clipRect<a title=\"#cliprect\" href=\"#cliprect\"></a></h4>\n<p><img src=\"https://z3.ax1x.com/2021/11/02/IFKTER.png\" alt=\"IFKTER.png\" loading=\"lazy\" class=\"φbp\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">canvas.clipRect(left, top, right, bottom);</span><br><span class=\"line\">canvas.drawBitmap(bitmap, x, y, paint);</span><br><span class=\"line\"><span class=\"comment\">// 加上 Canvas.save() 和 Canvas.restore() 来及时恢复绘制范围</span></span><br><span class=\"line\">canvas.save();</span><br><span class=\"line\">canvas.clipRect(left, top, right, bottom);</span><br><span class=\"line\">canvas.drawBitmap(bitmap, x, y, paint);</span><br><span class=\"line\">canvas.restore();</span><br></pre></td></tr></table></figure>\n<span id=\"more\"></span>\n<h4 id=\"clippath\">clipPath<a title=\"#clippath\" href=\"#clippath\"></a></h4>\n<p><img src=\"https://z3.ax1x.com/2021/11/02/IFM9UI.md.png\" alt=\"IFM9UI.md.png\" loading=\"lazy\" class=\"φbp\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">canvas.save();</span><br><span class=\"line\">canvas.clipPath(path1);</span><br><span class=\"line\">canvas.drawBitmap(bitmap, point1.x, point1.y, paint);</span><br><span class=\"line\">canvas.restore();</span><br><span class=\"line\"></span><br><span class=\"line\">canvas.save();</span><br><span class=\"line\">canvas.clipPath(path2);</span><br><span class=\"line\">canvas.drawBitmap(bitmap, point2.x, point2.y, paint);</span><br><span class=\"line\">canvas.restore();</span><br></pre></td></tr></table></figure>\n<h3 id=\"几何变换\">几何变换<a title=\"#几何变换\" href=\"#几何变换\"></a></h3>\n<h4 id=\"二维变换\">二维变换<a title=\"#二维变换\" href=\"#二维变换\"></a></h4>\n<blockquote>\n<p>处理常见的二维变换</p>\n</blockquote>\n<ul>\n<li><code>Canvas.translate()</code> 平移</li>\n<li><code>Canvas.rotate()</code> 旋转</li>\n<li><code>Canvas.scale()</code> 缩放</li>\n<li><code>Canvas.skew()</code> 错切</li>\n</ul>\n<h4 id=\"matrix变换\">Matrix变换<a title=\"#matrix变换\" href=\"#matrix变换\"></a></h4>\n<blockquote>\n<p>用来处理不常见的二维变换</p>\n</blockquote>\n<p><img src=\"https://z3.ax1x.com/2021/11/02/IFn6qs.png\" alt=\"IFn6qs.png\" loading=\"lazy\" class=\"φbp\"></p>\n<ul>\n<li><code>Canvas.setMatrix(matrix)</code>\n<ul>\n<li>用 <code>Matrix</code> 直接替换 <code>Canvas</code> 当前的变换矩阵，即抛弃 <code>Canvas</code> 当前的变换</li>\n</ul>\n</li>\n<li><code>Canvas.concat(matrix)</code>\n<ul>\n<li>用 <code>Canvas</code> 当前的变换矩阵和 <code>Matrix</code> 相乘，即基于 <code>Canvas</code> 当前的变换，叠加上 <code>Matrix</code> 中的变换</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Matrix matrix = <span class=\"keyword\">new</span> Matrix();</span><br><span class=\"line\"><span class=\"keyword\">float</span> pointsSrc = &#123;left, top, right, top, left, bottom, right, bottom&#125;;</span><br><span class=\"line\"><span class=\"keyword\">float</span> pointsDst = &#123;left - <span class=\"number\">10</span>, top + <span class=\"number\">50</span>, right + <span class=\"number\">120</span>, top - <span class=\"number\">90</span>, left + <span class=\"number\">20</span>, bottom + <span class=\"number\">30</span>, right + <span class=\"number\">20</span>, bottom + <span class=\"number\">60</span>&#125;;</span><br><span class=\"line\">...</span><br><span class=\"line\">matrix.reset();</span><br><span class=\"line\">matrix.setPolyToPoly(pointsSrc, <span class=\"number\">0</span>, pointsDst, <span class=\"number\">0</span>, <span class=\"number\">4</span>);</span><br><span class=\"line\">canvas.save();</span><br><span class=\"line\">canvas.concat(matrix);</span><br><span class=\"line\">canvas.drawBitmap(bitmap, x, y, paint);</span><br><span class=\"line\">canvas.restore();</span><br></pre></td></tr></table></figure>\n<h4 id=\"camera\">Camera<a title=\"#camera\" href=\"#camera\"></a></h4>\n<blockquote>\n<p>处理三维旋转</p>\n</blockquote>\n<h5 id=\"camera.rotate*\">Camera.rotate*<a title=\"#camera.rotate*\" href=\"#camera.rotate*\"></a></h5>\n<p><img src=\"https://z3.ax1x.com/2021/11/02/IFZoMd.md.png\" alt=\"IFZoMd.md.png\" loading=\"lazy\" class=\"φbp\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Camera camera =  <span class=\"keyword\">new</span>  Camera();</span><br><span class=\"line\">Point point1 = <span class=\"keyword\">new</span> Point(<span class=\"number\">200</span>, <span class=\"number\">100</span>);</span><br><span class=\"line\">Point point2 = <span class=\"keyword\">new</span> Point(<span class=\"number\">600</span>, <span class=\"number\">200</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onDraw</span><span class=\"params\">(Canvas canvas)</span> </span>&#123;</span><br><span class=\"line\">   canvas.save();</span><br><span class=\"line\">   camera.save(); <span class=\"comment\">// 保存 Camera 的状态</span></span><br><span class=\"line\">   camera.rotateX(<span class=\"number\">30</span>); <span class=\"comment\">// 旋转 Camera 的三维空间</span></span><br><span class=\"line\">   camera.applyToCanvas(canvas); <span class=\"comment\">// 把旋转投影到 Canvas</span></span><br><span class=\"line\">   camera.restore(); <span class=\"comment\">// 恢复 Camera 的状态</span></span><br><span class=\"line\">   canvas.drawBitmap(bitmap, point1.x, point1.y, paint);</span><br><span class=\"line\">   canvas.restore();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>居中处理:<br>\n<img src=\"https://z3.ax1x.com/2021/11/02/IFesfS.png\" alt=\"IFesfS.png\" loading=\"lazy\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> bitmapWidth = bitmap.getWidth();</span><br><span class=\"line\"><span class=\"keyword\">int</span> bitmapHeight = bitmap.getHeight();</span><br><span class=\"line\"><span class=\"keyword\">int</span> center1X = point1.x + bitmapWidth / <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> center1Y = point1.y + bitmapHeight / <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> center2X = point2.x + bitmapWidth / <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> center2Y = point2.y + bitmapHeight / <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">camera.save();</span><br><span class=\"line\">matrix.reset();</span><br><span class=\"line\">camera.rotateX(<span class=\"number\">30</span>);</span><br><span class=\"line\">camera.getMatrix(matrix);</span><br><span class=\"line\">camera.restore();</span><br><span class=\"line\">matrix.preTranslate(-center1X, -center1Y);</span><br><span class=\"line\">matrix.postTranslate(center1X, center1Y);</span><br><span class=\"line\">canvas.save();</span><br><span class=\"line\">canvas.concat(matrix);</span><br><span class=\"line\">canvas.drawBitmap(bitmap, point1.x, point1.y, paint);</span><br><span class=\"line\">canvas.restore();</span><br></pre></td></tr></table></figure>\n<h5 id=\"camera.translate\">Camera.translate<a title=\"#camera.translate\" href=\"#camera.translate\"></a></h5>\n<h5 id=\"camera.setlocation\">Camera.setLocation<a title=\"#camera.setlocation\" href=\"#camera.setlocation\"></a></h5>\n<blockquote>\n<p>设置虚拟相机的位置</p>\n</blockquote>\n",
            "tags": [
                "图形绘制"
            ]
        },
        {
            "id": "https://onion99.github.io/2021/11/04/VjI1fQxy8MSFqUqm/",
            "url": "https://onion99.github.io/2021/11/04/VjI1fQxy8MSFqUqm/",
            "title": "自定义View(3) - Text相关",
            "date_published": "2021-11-03T21:57:48.000Z",
            "content_html": "<h3 id=\"文字绘制(canvas)\">文字绘制(Canvas)<a title=\"#文字绘制(canvas)\" href=\"#文字绘制(canvas)\"></a></h3>\n<h4 id=\"绘制方式\">绘制方式<a title=\"#绘制方式\" href=\"#绘制方式\"></a></h4>\n<h5 id=\"drawtext\">drawText<a title=\"#drawtext\" href=\"#drawtext\"></a></h5>\n<p><img src=\"https://z3.ax1x.com/2021/11/02/IiheJA.png\" alt=\"IiheJA.png\" loading=\"lazy\" class=\"φbp\"></p>\n<span id=\"more\"></span>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String text = <span class=\"string\">&quot;Hello HenCoder&quot;</span>;</span><br><span class=\"line\">...</span><br><span class=\"line\">canvas.drawText(text, <span class=\"number\">200</span>, <span class=\"number\">100</span>, paint);</span><br></pre></td></tr></table></figure>\n<h5 id=\"drawtextrun\">drawTextRun<a title=\"#drawtextrun\" href=\"#drawtextrun\"></a></h5>\n<h5 id=\"drawtextonpath\">drawTextOnPath<a title=\"#drawtextonpath\" href=\"#drawtextonpath\"></a></h5>\n<blockquote>\n<p>沿着一条 Path 来绘制文字</p>\n</blockquote>\n<p><img src=\"https://z3.ax1x.com/2021/11/02/IihNzq.png\" alt=\"IihNzq.png\" loading=\"lazy\"><br>\n<code>drawTextOnPath()</code> 使用的 <code>Path</code> ，拐弯处全用圆角，别用尖角</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">canvas.drawPath(path, paint); <span class=\"comment\">// 把 Path 也绘制出来，理解起来更方便</span></span><br><span class=\"line\">canvas.drawTextOnPath(<span class=\"string\">&quot;Hello HeCoder&quot;</span>, path, <span class=\"number\">0</span>, <span class=\"number\">0</span>, paint);</span><br></pre></td></tr></table></figure>\n<h5 id=\"staticlayout\">StaticLayout<a title=\"#staticlayout\" href=\"#staticlayout\"></a></h5>\n<blockquote>\n<p>进行多行文字的绘制</p>\n</blockquote>\n<ul>\n<li>View 的边缘自动折行</li>\n<li>在换行符 <code>\\n</code> 处换行</li>\n</ul>\n<p><img src=\"https://z3.ax1x.com/2021/11/02/Iih7Yd.md.png\" alt=\"Iih7Yd.md.png\" loading=\"lazy\" class=\"φbp\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String text1 = <span class=\"string\">&quot;Lorem Ipsum is simply dummy text of the printing and typesetting industry.&quot;</span>;</span><br><span class=\"line\">StaticLayout staticLayout1 = <span class=\"keyword\">new</span> StaticLayout(text1, paint, <span class=\"number\">600</span>,</span><br><span class=\"line\">        Layout.Alignment.ALIGN_NORMAL, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">String text2 = <span class=\"string\">&quot;a\\nbc\\ndefghi\\njklm\\nnopqrst\\nuvwx\\nyz&quot;</span>;</span><br><span class=\"line\">StaticLayout staticLayout2 = <span class=\"keyword\">new</span> StaticLayout(text2, paint, <span class=\"number\">600</span>,</span><br><span class=\"line\">        Layout.Alignment.ALIGN_NORMAL, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">canvas.save();</span><br><span class=\"line\">canvas.translate(<span class=\"number\">50</span>, <span class=\"number\">100</span>);</span><br><span class=\"line\">staticLayout1.draw(canvas);</span><br><span class=\"line\">canvas.translate(<span class=\"number\">0</span>, <span class=\"number\">200</span>);</span><br><span class=\"line\">staticLayout2.draw(canvas);</span><br><span class=\"line\">canvas.restore();</span><br></pre></td></tr></table></figure>\n<h3 id=\"文字绘制辅助(paint)\">文字绘制辅助(Paint)<a title=\"#文字绘制辅助(paint)\" href=\"#文字绘制辅助(paint)\"></a></h3>\n<h4 id=\"样式设置\">样式设置<a title=\"#样式设置\" href=\"#样式设置\"></a></h4>\n<ul>\n<li><code>setTextSize(float textSize)</code></li>\n<li><code>setTypeface(Typeface typeface)</code></li>\n<li><code>setFakeBoldText(boolean fakeBoldText)</code>是否使用伪粗体</li>\n<li><code>setStrikeThruText(boolean strikeThruText)</code>是否加删除线</li>\n<li><code>setUnderlineText(boolean underlineText)</code></li>\n<li><code>setTextSkewX(float skewX)</code> 文字横切角度</li>\n<li><code>setTextScaleX(float scaleX)</code></li>\n<li><code>setLetterSpacing(float letterSpacing)</code> 字符间距</li>\n<li><code>setFontFeatureSettings(String settings)</code></li>\n<li><code>setTextAlign(Paint.Align align)</code></li>\n<li><code>setTextLocale(Locale locale)</code>语言区域</li>\n<li><code>setHinting(int mode)</code>字体微调</li>\n<li><code>setSubpixelText(boolean subpixelText)</code>是否开启像素级的抗锯齿</li>\n</ul>\n<h4 id=\"测量\">测量<a title=\"#测量\" href=\"#测量\"></a></h4>\n<ul>\n<li><code>getFontSpacing()</code> 获取推荐的行距\n<ul>\n<li><img src=\"https://z3.ax1x.com/2021/11/02/IiboRg.png\" alt=\"IiboRg.png\" loading=\"lazy\" class=\"φbp\"></li>\n</ul>\n</li>\n<li><code>getFontMetrics()</code>\n<ul>\n<li><img src=\"https://z3.ax1x.com/2021/11/02/IibtM9.png\" alt=\"IibtM9.png\" loading=\"lazy\" class=\"φbp\"></li>\n</ul>\n</li>\n<li><code>getTextBounds()</code> 获取文字范围</li>\n<li><code>measureText()</code>测量文字的宽度并返回</li>\n<li><code>getTextWidths()</code>获取字符串中每个字符的宽度</li>\n<li><code>breakText()</code> 和 <code>measureText()</code> 的区别是， breakText() 是在给出宽度上限的前提下测量文字的宽度。如果文字的宽度超出了上限，那么在临近超限的位置截断文字</li>\n<li>光标相关\n<ul>\n<li><code>getRunAdvance()</code>计算出某个字符处光标的 <code>x</code> 坐标\n<ul>\n<li><img src=\"https://z3.ax1x.com/2021/11/02/Iibnrn.png\" alt=\"Iibnrn.png\" loading=\"lazy\" class=\"φbp\"></li>\n<li><img src=\"https://z3.ax1x.com/2021/11/02/IibMV0.md.png\" alt=\"IibMV0.md.png\" loading=\"lazy\" class=\"φbp\"></li>\n</ul>\n</li>\n<li><code>getOffsetForAdvance</code> 计算第几个字符最接近这个坐标</li>\n</ul>\n</li>\n<li><code>hasGlyph()</code>检查指定的字符串中是否是一个单独的字形\n<ul>\n<li><img src=\"https://z3.ax1x.com/2021/11/02/IiH9tU.png\" alt=\"IiH9tU.png\" loading=\"lazy\" class=\"φbp\"></li>\n</ul>\n</li>\n</ul>\n",
            "tags": [
                "图形绘制"
            ]
        },
        {
            "id": "https://onion99.github.io/2021/11/02/weRgrdLnBqIUWkcH/",
            "url": "https://onion99.github.io/2021/11/02/weRgrdLnBqIUWkcH/",
            "title": "自定义View(2) - Paint相关",
            "date_published": "2021-11-01T22:19:10.000Z",
            "content_html": "<h3 id=\"color\">Color<a title=\"#color\" href=\"#color\"></a></h3>\n<h4 id=\"基本颜色\">基本颜色<a title=\"#基本颜色\" href=\"#基本颜色\"></a></h4>\n<p>setColor(int color):</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">paint.setColor(Color.parseColor(<span class=\"string\">&quot;#009688&quot;</span>));</span><br><span class=\"line\">canvas.drawRect(<span class=\"number\">30</span>, <span class=\"number\">30</span>, <span class=\"number\">230</span>, <span class=\"number\">180</span>, paint);</span><br></pre></td></tr></table></figure>\n<span id=\"more\"></span>\n<p>setARGB(int a, int r, int g, int b)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">paint.setARGB(<span class=\"number\">100</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">canvas.drawLine(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">200</span>, <span class=\"number\">200</span>, paint);</span><br></pre></td></tr></table></figure>\n<h4 id=\"shader\">Shader<a title=\"#shader\" href=\"#shader\"></a></h4>\n<h5 id=\"lineargradient(线性渐变)\">LinearGradient(线性渐变)<a title=\"#lineargradient(线性渐变)\" href=\"#lineargradient(线性渐变)\"></a></h5>\n<p><img src=\"https://z3.ax1x.com/2021/11/01/ICK7e1.png\" alt=\"ICK7e1.png\" loading=\"lazy\" class=\"φbp\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Shader shader = <span class=\"keyword\">new</span> LinearGradient(<span class=\"number\">100</span>, <span class=\"number\">100</span>, <span class=\"number\">500</span>, <span class=\"number\">500</span>, Color.parseColor(<span class=\"string\">&quot;#E91E63&quot;</span>),</span><br><span class=\"line\">        Color.parseColor(<span class=\"string\">&quot;#2196F3&quot;</span>), Shader.TileMode.CLAMP);</span><br><span class=\"line\">paint.setShader(shader);</span><br><span class=\"line\">...</span><br><span class=\"line\">canvas.drawCircle(<span class=\"number\">300</span>, <span class=\"number\">300</span>, <span class=\"number\">200</span>, paint);</span><br></pre></td></tr></table></figure>\n<div class=\"φbq\"><div class=\"φbs\"><table><thead>\n<tr>\n<th style=\"text-align:center\">CLAMP</th>\n<th style=\"text-align:center\">MIRROR</th>\n<th style=\"text-align:center\">REPEAT</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><img src=\"https://z3.ax1x.com/2021/11/01/ICuIVP.png\" alt=\"ICuIVP.png\" loading=\"lazy\"></td>\n<td style=\"text-align:center\"><img src=\"https://z3.ax1x.com/2021/11/01/ICKWJU.png\" alt=\"ICKWJU.png\" loading=\"lazy\"></td>\n<td style=\"text-align:center\"><img src=\"https://z3.ax1x.com/2021/11/01/ICK5QJ.png\" alt=\"ICK5QJ.png\" loading=\"lazy\"></td>\n</tr>\n</tbody>\n</table></div></div><h5 id=\"radialgradient(辐射渐变)\">RadialGradient(辐射渐变)<a title=\"#radialgradient(辐射渐变)\" href=\"#radialgradient(辐射渐变)\"></a></h5>\n<p><img src=\"https://z3.ax1x.com/2021/11/01/IClQRU.png\" alt=\"IClQRU.png\" loading=\"lazy\" class=\"φbp\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Shader shader = <span class=\"keyword\">new</span> RadialGradient(<span class=\"number\">300</span>, <span class=\"number\">300</span>, <span class=\"number\">200</span>, Color.parseColor(<span class=\"string\">&quot;#E91E63&quot;</span>),</span><br><span class=\"line\">        Color.parseColor(<span class=\"string\">&quot;#2196F3&quot;</span>), Shader.TileMode.CLAMP);</span><br><span class=\"line\">paint.setShader(shader);</span><br><span class=\"line\">...</span><br><span class=\"line\">canvas.drawCircle(<span class=\"number\">300</span>, <span class=\"number\">300</span>, <span class=\"number\">200</span>, paint);  </span><br></pre></td></tr></table></figure>\n<div class=\"φbq\"><div class=\"φbs\"><table><thead>\n<tr>\n<th style=\"text-align:center\">CLAMP</th>\n<th style=\"text-align:center\">MIRROR</th>\n<th style=\"text-align:center\">REPEAT</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><img src=\"https://z3.ax1x.com/2021/11/01/IClfW8.png\" alt=\"IClfW8.png\" loading=\"lazy\"></td>\n<td style=\"text-align:center\"><img src=\"https://z3.ax1x.com/2021/11/01/IC1SOJ.png\" alt=\"IC1SOJ.png\" loading=\"lazy\"></td>\n<td style=\"text-align:center\"><img src=\"https://z3.ax1x.com/2021/11/01/IC1SOJ.png\" alt=\"IC1SOJ.png\" loading=\"lazy\"></td>\n</tr>\n</tbody>\n</table></div></div><h5 id=\"sweepgradient(扫描渐变)\">SweepGradient(扫描渐变)<a title=\"#sweepgradient(扫描渐变)\" href=\"#sweepgradient(扫描渐变)\"></a></h5>\n<p><img src=\"https://z3.ax1x.com/2021/11/01/IC3N8K.png\" alt=\"IC3N8K.png\" loading=\"lazy\">]</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Shader shader = <span class=\"keyword\">new</span> SweepGradient(<span class=\"number\">300</span>, <span class=\"number\">300</span>, Color.parseColor(<span class=\"string\">&quot;#E91E63&quot;</span>),</span><br><span class=\"line\">        Color.parseColor(<span class=\"string\">&quot;#2196F3&quot;</span>));</span><br><span class=\"line\">paint.setShader(shader);</span><br><span class=\"line\">...</span><br><span class=\"line\">canvas.drawCircle(<span class=\"number\">300</span>, <span class=\"number\">300</span>, <span class=\"number\">200</span>, paint);</span><br></pre></td></tr></table></figure>\n<h5 id=\"bitmapshader\">BitmapShader<a title=\"#bitmapshader\" href=\"#bitmapshader\"></a></h5>\n<p><img src=\"https://z3.ax1x.com/2021/11/01/IC8dJ0.png\" alt=\"IC8dJ0.png\" loading=\"lazy\" class=\"φbp\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Bitmap bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.batman);</span><br><span class=\"line\">Shader shader = <span class=\"keyword\">new</span> BitmapShader(bitmap, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP);</span><br><span class=\"line\">paint.setShader(shader);</span><br><span class=\"line\">...</span><br><span class=\"line\">canvas.drawCircle(<span class=\"number\">300</span>, <span class=\"number\">300</span>, <span class=\"number\">200</span>, paint);</span><br></pre></td></tr></table></figure>\n<div class=\"φbq\"><div class=\"φbs\"><table><thead>\n<tr>\n<th style=\"text-align:center\">CLAMP</th>\n<th style=\"text-align:center\">MIRROR</th>\n<th style=\"text-align:center\">REPEAT</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><img src=\"https://z3.ax1x.com/2021/11/01/ICGhAs.png\" alt=\"ICGhAs.png\" loading=\"lazy\"></td>\n<td style=\"text-align:center\"><img src=\"https://z3.ax1x.com/2021/11/01/ICG7cT.png\" alt=\"ICG7cT.png\" loading=\"lazy\"></td>\n<td style=\"text-align:center\"><img src=\"https://z3.ax1x.com/2021/11/01/ICGLB4.png\" alt=\"ICGLB4.png\" loading=\"lazy\"></td>\n</tr>\n</tbody>\n</table></div></div><h5 id=\"composeshader-混合着色器\">ComposeShader 混合着色器<a title=\"#composeshader-混合着色器\" href=\"#composeshader-混合着色器\"></a></h5>\n<blockquote>\n<p>所谓混合，就是把两个 Shader 一起使用。</p>\n</blockquote>\n<p><img src=\"https://z3.ax1x.com/2021/11/01/ICUmdg.png\" alt=\"ICUmdg.png\" loading=\"lazy\" class=\"φbp\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 第一个 Shader：头像的 Bitmap</span></span><br><span class=\"line\">Bitmap bitmap1 = BitmapFactory.decodeResource(getResources(), R.drawable.batman);</span><br><span class=\"line\">Shader shader1 = <span class=\"keyword\">new</span> BitmapShader(bitmap1, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP);</span><br><span class=\"line\"><span class=\"comment\">// 第二个 Shader：从上到下的线性渐变（由透明到黑色）</span></span><br><span class=\"line\">Bitmap bitmap2 = BitmapFactory.decodeResource(getResources(), R.drawable.batman_logo);</span><br><span class=\"line\">Shader shader2 = <span class=\"keyword\">new</span> BitmapShader(bitmap2, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP);</span><br><span class=\"line\"><span class=\"comment\">// ComposeShader：结合两个 Shader</span></span><br><span class=\"line\">Shader shader = <span class=\"keyword\">new</span> ComposeShader(shader1, shader2, PorterDuff.Mode.SRC_OVER);</span><br><span class=\"line\">paint.setShader(shader);</span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">canvas.drawCircle(<span class=\"number\">300</span>, <span class=\"number\">300</span>, <span class=\"number\">300</span>, paint);</span><br></pre></td></tr></table></figure>\n<h4 id=\"porterduff\">PorterDuff<a title=\"#porterduff\" href=\"#porterduff\"></a></h4>\n<h3 id=\"patheffect\">PathEffect<a title=\"#patheffect\" href=\"#patheffect\"></a></h3>\n<h4 id=\"style\">Style<a title=\"#style\" href=\"#style\"></a></h4>\n<p><code>Paint.setStrokeWidth</code>:线条宽度<br>\n<img src=\"https://z3.ax1x.com/2021/11/01/ICvqQe.png\" alt=\"ICvqQe.png\" loading=\"lazy\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">paint.setStyle(Paint.Style.STROKE);</span><br><span class=\"line\">paint.setStrokeWidth(<span class=\"number\">1</span>);</span><br><span class=\"line\">canvas.drawCircle(<span class=\"number\">150</span>, <span class=\"number\">125</span>, <span class=\"number\">100</span>, paint);</span><br><span class=\"line\">paint.setStrokeWidth(<span class=\"number\">5</span>);</span><br><span class=\"line\">canvas.drawCircle(<span class=\"number\">400</span>, <span class=\"number\">125</span>, <span class=\"number\">100</span>, paint);</span><br><span class=\"line\">paint.setStrokeWidth(<span class=\"number\">40</span>);</span><br><span class=\"line\">canvas.drawCircle(<span class=\"number\">650</span>, <span class=\"number\">125</span>, <span class=\"number\">100</span>, paint);</span><br></pre></td></tr></table></figure>\n<p><code>Paint.setStrokeCap</code>:线条形状</p>\n<p><img src=\"https://z3.ax1x.com/2021/11/01/ICxkLj.png\" alt=\"ICxkLj.png\" loading=\"lazy\" class=\"φbp\"></p>\n<p><code>Paint.setStrokeJoin</code>:拐角形状</p>\n<p><img src=\"https://z3.ax1x.com/2021/11/01/ICxQlF.png\" alt=\"ICxQlF.png\" loading=\"lazy\" class=\"φbp\"></p>\n<p><code>Paint.setStrokeMiter</code>:拐角边缘</p>\n<p><img src=\"https://z3.ax1x.com/2021/11/01/ICzenH.png\" alt=\"image\" loading=\"lazy\" class=\"φbp\"></p>\n<h4 id=\"filter\">Filter<a title=\"#filter\" href=\"#filter\"></a></h4>\n<p><code>PathEffect.setDither()</code>:图像抖动<br>\n<img src=\"https://z3.ax1x.com/2021/11/01/ICL31H.png\" alt=\"ICL31H.png\" loading=\"lazy\"></p>\n<p><code>PathEffect.setFilterBitmap()</code>:双线性过滤<br>\n<img src=\"https://z3.ax1x.com/2021/11/01/ICvZ8O.png\" alt=\"ICvZ8O.png\" loading=\"lazy\"></p>\n<h4 id=\"effect\">Effect<a title=\"#effect\" href=\"#effect\"></a></h4>\n<div class=\"φbq\"><div class=\"φbs\"><table><thead>\n<tr>\n<th style=\"text-align:center\">Name</th>\n<th style=\"text-align:center\">Effect</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">CornerPathEffect</td>\n<td style=\"text-align:center\"><img src=\"https://z3.ax1x.com/2021/11/01/ICgRkq.png\" alt=\"ICgRkq.png\" loading=\"lazy\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">DiscretePathEffect</td>\n<td style=\"text-align:center\"><img src=\"https://z3.ax1x.com/2021/11/01/ICgGOH.png\" alt=\"ICgGOH.png\" loading=\"lazy\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">DashPathEffect</td>\n<td style=\"text-align:center\"><img src=\"https://z3.ax1x.com/2021/11/01/ICcXQg.png\" alt=\"ICcXQg.png\" loading=\"lazy\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">PathDashPathEffect</td>\n<td style=\"text-align:center\"><img src=\"https://z3.ax1x.com/2021/11/01/IC6T8U.png\" alt=\"IC6T8U.png\" loading=\"lazy\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">SumPathEffect</td>\n<td style=\"text-align:center\"><img src=\"https://z3.ax1x.com/2021/11/01/ICyBpF.png\" alt=\"ICyBpF.png\" loading=\"lazy\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">ComposePathEffect</td>\n<td style=\"text-align:center\"><img src=\"https://z3.ax1x.com/2021/11/01/ICy8yj.png\" alt=\"ICy8yj.png\" loading=\"lazy\"></td>\n</tr>\n</tbody>\n</table></div></div><h4 id=\"shadowlayer\">ShadowLayer<a title=\"#shadowlayer\" href=\"#shadowlayer\"></a></h4>\n<blockquote>\n<p>绘制层下方的阴影效果</p>\n</blockquote>\n<p><img src=\"https://z3.ax1x.com/2021/11/01/ICstPO.png\" alt=\"ICstPO.png\" loading=\"lazy\" class=\"φbp\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">paint.setShadowLayer(<span class=\"number\">10</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, Color.RED);</span><br><span class=\"line\">canvas.drawText(text, <span class=\"number\">80</span>, <span class=\"number\">300</span>, paint);</span><br></pre></td></tr></table></figure>\n<h4 id=\"maskfilter\">MaskFilter<a title=\"#maskfilter\" href=\"#maskfilter\"></a></h4>\n<blockquote>\n<p>绘制层上方的附加效果</p>\n</blockquote>\n<p>BlurMaskFilter(模糊效果):</p>\n<p><img src=\"https://z3.ax1x.com/2021/11/01/ICrhE6.md.png\" alt=\"ICrhE6.md.png\" loading=\"lazy\" class=\"φbp\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">paint.setMaskFilter(<span class=\"keyword\">new</span> BlurMaskFilter(<span class=\"number\">50</span>, BlurMaskFilter.Blur.NORMAL));</span><br><span class=\"line\">canvas.drawBitmap(bitmap, <span class=\"number\">100</span>, <span class=\"number\">100</span>, paint);</span><br></pre></td></tr></table></figure>\n<p>EmbossMaskFilter(浮雕效果):<br>\n<img src=\"https://z3.ax1x.com/2021/11/01/ICr0EV.png\" alt=\"ICr0EV.png\" loading=\"lazy\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 数组:光源方向,光强度,炫光系数,应用光线范围 </span></span><br><span class=\"line\">paint.setMaskFilter(<span class=\"keyword\">new</span> EmbossMaskFilter(<span class=\"keyword\">new</span> <span class=\"keyword\">float</span>[]&#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>&#125;, <span class=\"number\">0.2f</span>, <span class=\"number\">8</span>, <span class=\"number\">10</span>));</span><br><span class=\"line\">canvas.drawBitmap(bitmap, <span class=\"number\">100</span>, <span class=\"number\">100</span>, paint);</span><br></pre></td></tr></table></figure>\n<h4 id=\"getpath\">getPath<a title=\"#getpath\" href=\"#getpath\"></a></h4>\n<p><code>PathEffect.getFillPath()</code>获取图形Path</p>\n<p><img src=\"https://z3.ax1x.com/2021/11/01/ICDOtU.md.png\" alt=\"ICDOtU.md.png\" loading=\"lazy\" class=\"φbp\"></p>\n<p><code>PathEffect.getTextPath()</code>获取图形Path</p>\n<p><img src=\"https://z3.ax1x.com/2021/11/01/ICDAQs.png\" alt=\"ICDAQs.png\" loading=\"lazy\" class=\"φbp\"></p>\n<h3 id=\"refer\">Refer<a title=\"#refer\" href=\"#refer\"></a></h3>\n<p><a href=\"https://rengwuxian.com/ui-1-2/\" target=\"_blank\">HenCoder Android 开发进阶: 自定义 View 1-2 Paint 详解 (rengwuxian.com)</a></p>\n",
            "tags": [
                "图形绘制"
            ]
        },
        {
            "id": "https://onion99.github.io/2021/11/02/K0uh0dFU4QBtZ8Wm/",
            "url": "https://onion99.github.io/2021/11/02/K0uh0dFU4QBtZ8Wm/",
            "title": "自定义View(1) - 基本绘制",
            "date_published": "2021-11-01T22:17:37.000Z",
            "content_html": "<blockquote>\n<p>简单的绘制基本由<code>Canvas.drawxxx()</code>和Paint的配置组成</p>\n</blockquote>\n<p><img src=\"https://z3.ax1x.com/2021/11/01/IC9uZj.png\" alt=\"IC9uZj.png\" loading=\"lazy\" class=\"φbp\"></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PaintView</span> <span class=\"meta\">@JvmOverloads</span> <span class=\"keyword\">constructor</span></span>(context: Context, attrs: AttributeSet? = <span class=\"literal\">null</span>, defStyleAttr: <span class=\"built_in\">Int</span> = <span class=\"number\">0</span>) : View(context, attrs, defStyleAttr) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> mPaint <span class=\"keyword\">by</span> lazy &#123; Paint() &#125;</span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onDraw</span><span class=\"params\">(canvas: <span class=\"type\">Canvas</span>)</span></span> &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onDraw(canvas)</span><br><span class=\"line\">    paint.setColor(Color.RED)<span class=\"comment\">// 设置为红色</span></span><br><span class=\"line\">    canvas.drawCircle(<span class=\"number\">300</span>, <span class=\"number\">300</span>, <span class=\"number\">200</span>, paint)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<span id=\"more\"></span>\n<h3 id=\"canvas\">Canvas<a title=\"#canvas\" href=\"#canvas\"></a></h3>\n<ul>\n<li><code>Canvas.drawArc()</code> 绘制弧形或扇形<br>\n+ <code>left</code>, <code>top</code>, <code>right</code>, <code>bottom</code> 描述的是这个弧形所在的椭圆<br>\n+ <code>startAngle</code> 是弧形的起始角度<br>\n+ <code>sweepAngle</code> 是弧形划过的角度<br>\n+ <code>useCenter</code> 表示是否连接到圆心，如果不连接到圆心，就是弧形，如果连接到圆心，就是扇形</li>\n<li><code>Canvas.drawPath()</code> 组合图形</li>\n</ul>\n<h3 id=\"paint\">Paint<a title=\"#paint\" href=\"#paint\"></a></h3>\n<ul>\n<li><code>Paint.setStyle(Style style)</code>  设置绘制模式</li>\n<li><code>Paint.setColor(int color)</code>  设置颜色</li>\n<li><code>Paint.setStrokeWidth(float width)</code>  设置线条宽度</li>\n<li><code>Paint.setTextSize(float textSize)</code>  设置文字大小</li>\n<li><code>Paint.setAntiAlias(boolean aa)</code>  设置抗锯齿开关</li>\n</ul>\n<h3 id=\"path\">Path<a title=\"#path\" href=\"#path\"></a></h3>\n<blockquote>\n<p>如果只画一个圆，没必要用 Path，直接用 drawCircle() 就行了。drawPath() 一般是在绘制组合图形时才会用到的</p>\n</blockquote>\n<h4 id=\"path.addxxx\">Path.addXxx<a title=\"#path.addxxx\" href=\"#path.addxxx\"></a></h4>\n<blockquote>\n<p>添加子图形</p>\n</blockquote>\n<p><code>path.addCircle(300, 300, 200, Path.Direction.CW)</code></p>\n<h4 id=\"path.xxxto\">Path.xxxTo<a title=\"#path.xxxto\" href=\"#path.xxxto\"></a></h4>\n<blockquote>\n<p>用于画线（直线或曲线）</p>\n</blockquote>\n<p><code>lineTo(float x, float y) / rLineTo(float x, float y) </code>画直线:<br>\n<img src=\"https://z3.ax1x.com/2021/11/01/ICkWGR.png\" alt=\"ICkWGR.png\" loading=\"lazy\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">paint.setStyle(Style.STROKE);</span><br><span class=\"line\">path.lineTo(<span class=\"number\">100</span>, <span class=\"number\">100</span>); <span class=\"comment\">// 由当前位置 (0, 0) 向 (100, 100) 画一条直线</span></span><br><span class=\"line\">path.rLineTo(<span class=\"number\">100</span>, <span class=\"number\">0</span>); <span class=\"comment\">// 由当前位置 (100, 100) 向正右方 100 像素的位置画一条直线</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"https://z3.ax1x.com/2021/11/01/ICASL8.png\" alt=\"ICASL8.png\" loading=\"lazy\">]</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">paint.setStyle(Style.STROKE);</span><br><span class=\"line\">path.lineTo(<span class=\"number\">100</span>, <span class=\"number\">100</span>); <span class=\"comment\">// 画斜线</span></span><br><span class=\"line\">path.moveTo(<span class=\"number\">200</span>, <span class=\"number\">100</span>); <span class=\"comment\">// 我移~~</span></span><br><span class=\"line\">path.lineTo(<span class=\"number\">200</span>, <span class=\"number\">0</span>); <span class=\"comment\">// 画竖线</span></span><br></pre></td></tr></table></figure>\n<p><code>arcTo()</code> 和 <code>addArc()</code>画弧线:</p>\n<div class=\"φbq\"><div class=\"φbs\"><table><thead>\n<tr>\n<th style=\"text-align:center\">true</th>\n<th style=\"text-align:center\">false</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><img src=\"https://z3.ax1x.com/2021/11/01/ICEuct.png\" alt=\"ICEuct.png\" loading=\"lazy\"></td>\n<td style=\"text-align:center\"><img src=\"https://z3.ax1x.com/2021/11/01/ICEinK.png\" alt=\"ICEinK.png\" loading=\"lazy\"></td>\n</tr>\n</tbody>\n</table></div></div><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">paint.setStyle(Style.STROKE);</span><br><span class=\"line\">path.lineTo(<span class=\"number\">100</span>, <span class=\"number\">100</span>);</span><br><span class=\"line\"><span class=\"comment\">// true 直接连线连到弧形起点（有痕迹）</span></span><br><span class=\"line\"><span class=\"comment\">// false 强制移动到弧形起点（无痕迹）</span></span><br><span class=\"line\">path.arcTo(<span class=\"number\">100</span>, <span class=\"number\">100</span>, <span class=\"number\">300</span>, <span class=\"number\">300</span>, -<span class=\"number\">90</span>, <span class=\"number\">90</span>, <span class=\"keyword\">true</span>/<span class=\"keyword\">false</span>); </span><br><span class=\"line\"><span class=\"comment\">// 等同上面</span></span><br><span class=\"line\">paint.setStyle(Style.STROKE);</span><br><span class=\"line\">path.lineTo(<span class=\"number\">100</span>, <span class=\"number\">100</span>);</span><br><span class=\"line\">path.addArc(<span class=\"number\">100</span>, <span class=\"number\">100</span>, <span class=\"number\">300</span>, <span class=\"number\">300</span>, -<span class=\"number\">90</span>, <span class=\"number\">90</span>); <span class=\"comment\">// addArc() 只是一个直接使用了 forceMoveTo = true 的简化版 arcTo()</span></span><br></pre></td></tr></table></figure>\n<p><code>close() </code>封闭当前子图形:</p>\n<div class=\"φbq\"><div class=\"φbs\"><table><thead>\n<tr>\n<th style=\"text-align:center\">no close</th>\n<th style=\"text-align:center\">close</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><img src=\"https://z3.ax1x.com/2021/11/01/ICVaPH.png\" alt=\"ICVaPH.png\" loading=\"lazy\"></td>\n<td style=\"text-align:center\"><img src=\"https://z3.ax1x.com/2021/11/01/ICVgIg.png\" alt=\"ICVgIg.png\" loading=\"lazy\"></td>\n</tr>\n</tbody>\n</table></div></div><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">paint.setStyle(Style.STROKE);</span><br><span class=\"line\">path.moveTo(<span class=\"number\">100</span>, <span class=\"number\">100</span>);</span><br><span class=\"line\">path.lineTo(<span class=\"number\">200</span>, <span class=\"number\">100</span>);</span><br><span class=\"line\">path.lineTo(<span class=\"number\">150</span>, <span class=\"number\">150</span>);</span><br><span class=\"line\">path.close(); </span><br></pre></td></tr></table></figure>\n<h4 id=\"path.setfilltype\">Path.setFillType<a title=\"#path.setfilltype\" href=\"#path.setfilltype\"></a></h4>\n<blockquote>\n<p>设置填充方式</p>\n</blockquote>\n<p><img src=\"https://z3.ax1x.com/2021/11/01/ICFucV.png\" alt=\"ICFucV.png\" loading=\"lazy\" class=\"φbp\"></p>\n<div class=\"φbq\"><div class=\"φbs\"><table><thead>\n<tr>\n<th style=\"text-align:center\">EVEN_ODD:even-odd rule （奇偶原则）</th>\n<th style=\"text-align:center\">WINDING: non-zero winding rule （非零环绕数原则）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><img src=\"https://z3.ax1x.com/2021/11/01/ICFKXT.png\" alt=\"ICFKXT.png\" loading=\"lazy\"></td>\n<td style=\"text-align:center\"><img src=\"https://z3.ax1x.com/2021/11/01/ICFJhR.png\" alt=\"ICFJhR.png\" loading=\"lazy\"></td>\n</tr>\n</tbody>\n</table></div></div>",
            "tags": [
                "图形绘制"
            ]
        },
        {
            "id": "https://onion99.github.io/2021/11/01/nOSSxZ51uxl6hUq8/",
            "url": "https://onion99.github.io/2021/11/01/nOSSxZ51uxl6hUq8/",
            "title": "Java 理论",
            "date_published": "2021-10-31T21:33:20.000Z",
            "content_html": "<h2 id=\"jvm\">JVM<a title=\"#jvm\" href=\"#jvm\"></a></h2>\n<blockquote>\n<p>即Java虚拟机,是java程序与OS之间的处理中介,屏蔽了与OS平台相关的具体信息.从而实现跨平台</p>\n</blockquote>\n<p>JRE: java运行环境<br>\nJDK:java开发工具包</p>\n<p><img src=\"https://z3.ax1x.com/2021/10/29/5XeI1O.png\" alt=\"5XeI1O.png\" loading=\"lazy\" class=\"φbp\"></p>\n<p>组成:</p>\n<ul>\n<li>类装载子系统（ClassLoader）</li>\n<li>运行时数据区</li>\n<li>执行引擎</li>\n<li>内存回收</li>\n</ul>\n<span id=\"more\"></span>\n<h3 id=\"面向对象和面向过程\">面向对象和面向过程<a title=\"#面向对象和面向过程\" href=\"#面向对象和面向过程\"></a></h3>\n<p>面向过程</p>\n<ul>\n<li>将一个问题分解为具体过程的行为实现</li>\n<li>性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源</li>\n<li>没有面向对象易维护、易复用、易扩展</li>\n</ul>\n<p>面向对象</p>\n<ul>\n<li>将一个问题分解为通过不同对象的属性和功能来实现</li>\n</ul>\n<h2 id=\"refer\">Refer<a title=\"#refer\" href=\"#refer\"></a></h2>\n<p><a href=\"https://blog.csdn.net/qq_38163244/article/details/109551205\" target=\"_blank\">Jvm系列-Jvm概述（一）</a><br>\n<a href=\"https://mp.weixin.qq.com/s?__biz=MzU3NDY4NzQwNQ==&amp;mid=2247483820&amp;idx=1&amp;sn=8418f0f6a618bb0f0ca0980af09a816f&amp;chksm=fd2fd06eca5859786ab124dd204a7ec9b1ad3ed230b9b531086cc6729a277a05d3e8307b7e0d&amp;mpshare=1&amp;scene=1&amp;srcid=10298k3e78U6EvGwOFzdlSka&amp;sharer_sharetime=1635474328007&amp;sharer_shareid=7cb3b4a44a48b28c2337c68afe383da6&amp;exportkey=A7V%2B0C1tGaUKgyZIx1CLZhU%3D&amp;pass_ticket=jfeKdbe8hPuxHSyoUa4LK3n22co%2B%2BeHANszsiwjQ22G6HpzZYr5LX%2BaxLyzvvutj&amp;wx_header=0#rd\" target=\"_blank\">一张图看懂JVM（升级版） (qq.com)</a><br>\n<a href=\"https://www.cnblogs.com/mrhgw/p/10341660.html\" target=\"_blank\">JVM原理摘要 - 有容乃大 - 博客园 (cnblogs.com)</a></p>\n",
            "tags": [
                "理论学习"
            ]
        },
        {
            "id": "https://onion99.github.io/2021/11/01/MgnT9VQ3PhWZOJAq/",
            "url": "https://onion99.github.io/2021/11/01/MgnT9VQ3PhWZOJAq/",
            "title": "课程-编码与加密",
            "date_published": "2021-10-31T21:32:00.000Z",
            "content_html": "<h2 id=\"加密\">加密<a title=\"#加密\" href=\"#加密\"></a></h2>\n<blockquote>\n<p>加密(整容)是通过Intranet、Extranet和Internet进行安全的信息交换的基础</p>\n</blockquote>\n<p>常用加密</p>\n<ul>\n<li>对称加密算法</li>\n<li>非对称加密算法</li>\n<li>哈希算法</li>\n</ul>\n<span id=\"more\"></span>\n<h3 id=\"对称加密\">对称加密<a title=\"#对称加密\" href=\"#对称加密\"></a></h3>\n<blockquote>\n<p>使⽤用密钥和加密算法对数据进行转换，得到的无意义数据即为密⽂; 使用密钥和解密算法对密⽂进行逆向转换，得到原数据</p>\n</blockquote>\n<p><img src=\"https://z3.ax1x.com/2021/10/28/5bxS8f.png\" alt=\"5bxS8f.png\" loading=\"lazy\" class=\"φbp\"></p>\n<p>算法：DES、AES</p>\n<h3 id=\"非对称加密\">非对称加密<a title=\"#非对称加密\" href=\"#非对称加密\"></a></h3>\n<blockquote>\n<p>使⽤公钥对数据进行加密得到密文;使⽤用私钥对数据进⾏解密得到原数据</p>\n</blockquote>\n<p><img src=\"https://z3.ax1x.com/2021/10/28/5bxDZd.png\" alt=\"5bxDZd.png\" loading=\"lazy\" class=\"φbp\"></p>\n<p>算法：RSA、DSA</p>\n<p>完整的非对称加密过程:<br>\n<img src=\"https://z3.ax1x.com/2021/10/28/5qdbl9.png\" alt=\"5qdbl9.png\" loading=\"lazy\"><br>\n对数据进行签名时，实际上，是对数据的hash值（摘要）进行签名（加密），解密时，是对原数据进行hash，得到摘要，再将加密过的摘要进行解密，将得到的两者对比，如果一致就验证通过</p>\n<h4 id=\"公钥与私钥\">公钥与私钥<a title=\"#公钥与私钥\" href=\"#公钥与私钥\"></a></h4>\n<blockquote>\n<p>加密密钥就是公钥，解密密钥就是私钥</p>\n</blockquote>\n<p>将原数据通过我的私钥，也就是签名，进行加密，得到签名数据，别人拿我的公钥对我的签名数据进行解密（也就是验证的过程），得到的就是我要发送的原数据。签名数据只有我能造出来，因为只有我拥有我的私钥，这就证明了这个数据是我写出来的。也就是所谓的签名的作用。</p>\n<p><img src=\"https://z3.ax1x.com/2021/10/28/5bzD6U.png\" alt=\"5bzD6U.png\" loading=\"lazy\" class=\"φbp\"></p>\n<h4 id=\"签名和验证\">签名和验证<a title=\"#签名和验证\" href=\"#签名和验证\"></a></h4>\n<blockquote>\n<p>签名和验证是拿私钥加密（签名），公钥解密（验证）</p>\n</blockquote>\n<p><img src=\"https://z3.ax1x.com/2021/10/28/5qSkhq.png\" alt=\"5qSkhq.png\" loading=\"lazy\" class=\"φbp\"></p>\n<h2 id=\"编码\">编码<a title=\"#编码\" href=\"#编码\"></a></h2>\n<blockquote>\n<p>编码(化妆)是信息从一种形式或格式转换为另一种形式的过程。解码，是编码的逆过程</p>\n</blockquote>\n<h3 id=\"常用编码\">常用编码<a title=\"#常用编码\" href=\"#常用编码\"></a></h3>\n<ul>\n<li>Base64， 16进制，Base32\n<ul>\n<li>将原来的信息用另外一种编码机制替换</li>\n</ul>\n</li>\n<li>多语种的编码 UTF-8, UTF-16,UTF-32, Unicode, ISO8859-1, GBK, GB2312\n<ul>\n<li>主要是对各种语言的编码</li>\n</ul>\n</li>\n<li>BER/DER编码</li>\n<li>HTML编码，JS编码，URL编码\n<ul>\n<li>针对脚本语言或者标签语言中的字符串中的特殊字符进行处理</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"base64\">Base64<a title=\"#base64\" href=\"#base64\"></a></h4>\n<blockquote>\n<p>将二进制数据转换成由64个字符组成的字符串的编码算法</p>\n</blockquote>\n<p><img src=\"https://z3.ax1x.com/2021/10/28/5qt0Cd.png\" alt=\"5qt0Cd.png\" loading=\"lazy\" class=\"φbp\"></p>\n<p>编码示例:<br>\n<img src=\"https://z3.ax1x.com/2021/10/28/5qNYzn.png\" alt=\"5qNYzn.png\" loading=\"lazy\"></p>\n<p>作用: 让原数据具有字符串所具有的特性，可以放在URL中传输，可以保存到文本文件，可以通过普通的聊天软件进行文本传输</p>\n<p>Base64加密图片会更加安全和高效吗？<br>\n不会，Base64是公开的算法，加密和解密都是公开的，任何人都可以解密，因此并不会更安全。通过Base64加密的文件或数据，都会增大约1/3，降低网络性能，增大用户流量，因此也不存在更高效的问题</p>\n<h3 id=\"应用领域\">应用领域<a title=\"#应用领域\" href=\"#应用领域\"></a></h3>\n<h4 id=\"压缩与解压缩\">压缩与解压缩<a title=\"#压缩与解压缩\" href=\"#压缩与解压缩\"></a></h4>\n<blockquote>\n<p>压缩属于编码过程，解压缩属于解码过程</p>\n</blockquote>\n<p>压缩：把数据换一种方式来存储，以减少存储空间。<br>\n解压缩：把压缩后的数据还原成原先的形式，以便使用。<br>\n常⻅见压缩算法:DEFLATE（zip）、JPEG、MP3</p>\n<h4 id=\"媒体数据的编解码\">媒体数据的编解码<a title=\"#媒体数据的编解码\" href=\"#媒体数据的编解码\"></a></h4>\n<p>图片的编码：把图像数据写成 JPG、PNG 等⽂件的编码格式。<br>\n图⽚的解码：把 JPG、PNG 等⽂文件中的数据解析成标准的图像数据。</p>\n<h4 id=\"序列化与反序列化\">序列化与反序列化<a title=\"#序列化与反序列化\" href=\"#序列化与反序列化\"></a></h4>\n<p>序列化: 把数据对象，一般是内存中的，如JVM中的对象，转换成字节序列的过程。<br>\n反序列化: 把字节序列重新转换成内存中的对象</p>\n<h4 id=\"hash\">Hash<a title=\"#hash\" href=\"#hash\"></a></h4>\n<blockquote>\n<p>把任意数据转换成指定大小范围（通常很小）的数据</p>\n</blockquote>\n<p>经典算法：MD5、SHA1、SHA256等</p>\n<p>实际用途:</p>\n<ul>\n<li>数据完整性验证\n<ul>\n<li>从⽹络上下载文件后，通过比对文件的 Hash 值(例如 MD5、SHA1)，可以确认下载的文件是否有损坏。如果下载的文件 Hash 值和文件提供方给出的 Hash 值一致，则证明下载的文件是完好无损的</li>\n</ul>\n</li>\n<li>唯一性验证\n<ul>\n<li>HashCode是一个数据的指纹信息，也就是从这个数据身上采取了足够多的特征来证明“你是你”</li>\n</ul>\n</li>\n<li>快速查找: HashCode和HashMap\n<ul>\n<li>HashCode是数据的内存地址</li>\n<li>HashMap：Key的HashCode是Value的地址，通过Key的HashCode可以找到Value</li>\n<li>在重写equals()时，也必须重写hashCode(),因为如果不重写hashCode()，当使用equals()比较时，hashCode()是Object中的hashCode()，很可能出现用equals()判断相等而用hashCode()判断不相等的情况,甚至也有可能是相反的</li>\n</ul>\n</li>\n<li>隐私保护</li>\n</ul>\n<p>Hash 是编码吗?<br>\n不是。 Hash 是单向过程，往往是不可逆的，无法进行逆向恢复操作，因此 Hash 不属于编码。</p>\n<p>Hash 是加密吗?<br>\n不是。Hash 是单向过程，无法进行逆向回复操作，因此 Hash 不属于加密。(记住MD5 不是加密!MD5不可逆)</p>\n",
            "tags": [
                "课程学习"
            ]
        },
        {
            "id": "https://onion99.github.io/2021/11/01/Qqq7oSBqBc2Zgbrx/",
            "url": "https://onion99.github.io/2021/11/01/Qqq7oSBqBc2Zgbrx/",
            "title": "课程-登陆与授权",
            "date_published": "2021-10-31T21:31:00.000Z",
            "content_html": "<h2 id=\"登录授权、tcp/ip、https和代理\">登录授权、TCP/IP、HTTPS和代理<a title=\"#登录授权、tcp/ip、https和代理\" href=\"#登录授权、tcp/ip、https和代理\"></a></h2>\n<p>登录：身份认证，确认你是你的过程。<br>\n授权：由身份或持有的令牌确认享有某些权限（例如获取用户信息）。登录过程实质上的目的也是为了确认权限</p>\n<span id=\"more\"></span>\n<h3 id=\"http中授权方式\">HTTP中授权方式<a title=\"#http中授权方式\" href=\"#http中授权方式\"></a></h3>\n<h4 id=\"cookie\">Cookie<a title=\"#cookie\" href=\"#cookie\"></a></h4>\n<blockquote>\n<p>使用Cookie管理登录状态</p>\n</blockquote>\n<p><img src=\"https://z3.ax1x.com/2021/10/28/5qrP4f.png\" alt=\"5qrP4f.png\" loading=\"lazy\" class=\"φbp\"></p>\n<p><img src=\"https://z3.ax1x.com/2021/10/28/5qrmbn.png\" alt=\"5qrmbn.png\" loading=\"lazy\" class=\"φbp\"></p>\n<h5 id=\"cookie工作机制\">Cookie工作机制<a title=\"#cookie工作机制\" href=\"#cookie工作机制\"></a></h5>\n<ol>\n<li>服务器需要客户端保存的内容，放在Set-Cookie的headers里返回，客户端会自动保存。</li>\n<li>客户端保存的Cookies，会在之后的所有请求里都携带进Cookie header里发回给服务器。</li>\n<li>客户端保存Cookie是按照服务器域名来分类的，例如shop.com发回的Cookie保存下来以后，在之后向games.com的请求中并不会被携带。</li>\n<li>.客户端保存的Cookie在超时后会被删除，没有设置超时时间的Cookie（称作Session Cookie）在浏览器关闭后就会自动删除，另外，服务器也可以主动删除还未过期的客户端Cookies</li>\n<li>Cookie是由服务端管理的，客户端只是被动接受。</li>\n</ol>\n<h4 id=\"authorization-header\">Authorization Header<a title=\"#authorization-header\" href=\"#authorization-header\"></a></h4>\n<blockquote>\n<p>两种主流方式 Basic 和 Beare</p>\n</blockquote>\n<h5 id=\"basic\">Basic<a title=\"#basic\" href=\"#basic\"></a></h5>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span>格式：Authorization: Basic&lt;username:password(Base64)&gt;</span><br><span class=\"line\"><span class=\"number\">2.</span>Basic认证过程</span><br><span class=\"line\"><span class=\"number\">1.</span>浏览器发送请求到服务器</span><br><span class=\"line\">                GET / HTTP /<span class=\"number\">1.1</span></span><br><span class=\"line\">                Host:xxx.xxx.com</span><br><span class=\"line\"><span class=\"number\">2.</span>服务端发送验证请求<span class=\"number\">401</span></span><br><span class=\"line\">                HTTP/<span class=\"number\">1.1</span> <span class=\"number\">401</span> Unauthorised</span><br><span class=\"line\">                Server: bfe/<span class=\"number\">1.0</span><span class=\"number\">.8</span><span class=\"number\">.18</span></span><br><span class=\"line\">                WWW-Authenticate: Basic realm=<span class=\"string\">&quot;XXXXX.com&quot;</span></span><br><span class=\"line\">                Content-<span class=\"built_in\">Type</span>: text/html; charset=utf<span class=\"number\">-8</span></span><br><span class=\"line\"><span class=\"number\">3.</span>客户端收到<span class=\"number\">401</span>返回值后，将自动弹出登录窗口，等待用户输入用户名，密码</span><br><span class=\"line\"><span class=\"number\">4.</span>将用户名密码进行Base64编码后发送给服务端进行验证</span><br><span class=\"line\">                GET / HTTP/<span class=\"number\">1.1</span></span><br><span class=\"line\">                Host: xxx.xxx.xxx.com</span><br><span class=\"line\">                Authorization: Basic xxxxxxxxxxxxxxxxxxxxxxxxxxxx</span><br><span class=\"line\"><span class=\"number\">5.</span>服务端取出Authorization中头信息，并与数据库进行比对，如果合法则返回<span class=\"number\">200</span>，不合法，则返回<span class=\"number\">401</span>。</span><br></pre></td></tr></table></figure>\n<h5 id=\"bearer\">Bearer<a title=\"#bearer\" href=\"#bearer\"></a></h5>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span>格式：Authorization: Bearer &lt;bearer token&gt;</span><br><span class=\"line\"><span class=\"number\">2.</span>bearer token 的获取方式：通过OAuth2的授权流程</span><br><span class=\"line\"><span class=\"number\">3.</span>OAuth2的流程</span><br><span class=\"line\">            <span class=\"number\">1.</span>第三方网站向授权网站申请授权合作，拿到client <span class=\"keyword\">id</span>和client secret</span><br><span class=\"line\">            <span class=\"number\">2.</span>用户在使用第三方网站的时候，点击通过授权，第三方网站将跳转授权网站，并将clientid传递给授权网站。</span><br><span class=\"line\">            <span class=\"number\">4.</span>授权方网站根据clientid，将第三方网站的信息和第三方网站需要的用户权限展示给用户，询问用户是否同意授权。</span><br><span class=\"line\">            <span class=\"number\">5.</span>当用户点击同意授权，授权方网站返回第三方网站，并传入Authorization code作为用户认可的凭证。</span><br><span class=\"line\">            <span class=\"number\">6.</span>第三方网站将Authorization code上送给自己的服务器，服务器将Authorization code跟自己服务器端存储的client secret发送给授权方服务器，授权方服务器通过验证后，返回给access token，整个OAuth2流程结束。</span><br><span class=\"line\">            <span class=\"number\">7.</span>在整个OAuth流程结束后，第三方网站服务器可以试用access token 作用用户授权的token，用此来向授权方网站请求获取用户信息等操作。</span><br><span class=\"line\">        </span><br><span class=\"line\"><span class=\"number\">4.</span>问题：</span><br><span class=\"line\">            为什么OAuth认证要引入Authorization code，并且需要申请授权的第三方将Authorization code传给第三方服务器，并且通过第三方服务器将Authorization code传递给授权方服务器。然后再获取授权方服务器的access token。这样做的目的是为了通信安全，因为OAuth不强制使用HTTPS，因此需要保证通信路径中存在窃听者的时候，还能保证足够的安全。</span><br><span class=\"line\">            </span><br><span class=\"line\"><span class=\"number\">5.</span>第三方APP通过微信登录的流程：</span><br><span class=\"line\">            这是一个标准的OAuth2的流程。</span><br><span class=\"line\">            <span class=\"number\">1.</span>第三方APP向腾讯方申请合作，拿到client <span class=\"keyword\">id</span> 和client secret</span><br><span class=\"line\">            <span class=\"number\">2.</span>当用户在第三方APP上需要微信登录的时候，第三方APP将使用微信SDK打开微信授权页面，并且传入client <span class=\"keyword\">id</span>作为自己授权<span class=\"keyword\">id</span>。</span><br><span class=\"line\">            <span class=\"number\">3.</span>微信拿到第三方app的client <span class=\"keyword\">id</span>后，提交微信后台，验证成功，则返回给第三方app Authorization code。</span><br><span class=\"line\">            <span class=\"number\">4.</span>第三方app拿到Authorization code后，将Authorization code传递给自己的服务器，第三方app的服务端将Authorization code 与 client secret 传递给微信后台，微信后台验证后返回access token。</span><br><span class=\"line\">            <span class=\"number\">5.</span>第三方app后台通过access token 想微信后台请求获取用户信息，微信验证通过后，则返回用户信息。</span><br><span class=\"line\">            <span class=\"number\">6.</span>服务器接受到用户信息后，在自己的数据库中建立一个账户，并将从微信获取的用户信息填入数据库中。并创建用户<span class=\"keyword\">id</span>，并将此<span class=\"keyword\">id</span>与微信<span class=\"keyword\">id</span>做好关联。</span><br><span class=\"line\">            <span class=\"number\">7.</span>当第三方app后台创建好用户后，想客户端的请求发出响应，并回传会刚刚创建的用户信息。</span><br><span class=\"line\">            <span class=\"number\">8.</span>客户端响应，获取用户信息，登录成功。</span><br><span class=\"line\">            </span><br><span class=\"line\"><span class=\"number\">6.</span>在自家APP中使用Bearer token</span><br><span class=\"line\">            部分app会在api设计中，将登录和授权设计出类似于OAuth2的过程，他会简化掉Authorization code的概念。既直接在接口请求成功后，返回access token，然后再之后的客户端的请求中，使用这个access token 作为Bearer token进行用户操作。</span><br><span class=\"line\">            </span><br><span class=\"line\"><span class=\"number\">7.</span>Refresh token</span><br><span class=\"line\">            Access token 都会有失效时间，当他失效后，第三方app的服务端会通过refresh token 接口传入refresh token 来获取新的access token。这样的的原因是安全，因为refresh token是放置在服务端的，即使access token被窃取，他也是有失效时间的。</span><br></pre></td></tr></table></figure>\n<h3 id=\"tcp/ip\">TCP/IP<a title=\"#tcp/ip\" href=\"#tcp/ip\"></a></h3>\n<blockquote>\n<p>两台计算机之间的通讯是通过TCP/IP协议在因特网上进行的</p>\n</blockquote>\n<p>TCP：Transmission Control Protocol 传输控制协议, 用于应用程序之间的通信<br>\nIP：Internet Protocol 网际协议, 用于计算机之间的通信</p>\n<h4 id=\"分层\">分层<a title=\"#分层\" href=\"#分层\"></a></h4>\n<blockquote>\n<p>因为网络具有不稳定性,要保证通信正常</p>\n</blockquote>\n<p><img src=\"https://z3.ax1x.com/2021/10/28/5qccSf.png\" alt=\"5qccSf.png\" loading=\"lazy\" class=\"φbp\"></p>\n<h4 id=\"tcp连接\">TCP连接<a title=\"#tcp连接\" href=\"#tcp连接\"></a></h4>\n<blockquote>\n<p>通信双方建立确认「可以通信」，不会将对方的消息丢弃，即为「建立连接」</p>\n</blockquote>\n<h5 id=\"连接建立\">连接建立<a title=\"#连接建立\" href=\"#连接建立\"></a></h5>\n<p><img src=\"https://z3.ax1x.com/2021/10/28/5LRCDS.png\" alt=\"5LRCDS.png\" loading=\"lazy\" class=\"φbp\"></p>\n<h5 id=\"连接关闭\">连接关闭<a title=\"#连接关闭\" href=\"#连接关闭\"></a></h5>\n<p><img src=\"https://z3.ax1x.com/2021/10/28/5LRGCR.png\" alt=\"5LRGCR.png\" loading=\"lazy\" class=\"φbp\"></p>\n<h5 id=\"长连接\">长连接<a title=\"#长连接\" href=\"#长连接\"></a></h5>\n<blockquote>\n<p>强制不让连接的通道关闭</p>\n</blockquote>\n<ul>\n<li>TCP短连接\n<ul>\n<li>client向server发起连接请求，server接到请求，然后双方建立连接。client向server 发送消息，server回应client，然后一次读写就完成了</li>\n<li>一般的server不会回复完client后立即关闭连接的, 所以一般是client先发起close操作</li>\n</ul>\n</li>\n<li>TCP长连接\n<ul>\n<li>client向server发起连接，server接受client连接，双方建立连接。Client与server完成一次读写之后，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接</li>\n</ul>\n</li>\n</ul>\n<p>怎样实现长连接？<br>\n⼼跳。即在一定间隔时间内，使⽤TCP连接发送超短无意义消息来让网关不能将⾃己定义为「空闲连接」，从而防止网关将⾃己的连接关闭</p>\n<h3 id=\"https\">HTTPS<a title=\"#https\" href=\"#https\"></a></h3>\n<blockquote>\n<p>HTTP over SSL的简称，即工作在SSL(或TLS)上的HTTP。是加密通信的HTTP</p>\n</blockquote>\n<h4 id=\"工作原理\">工作原理<a title=\"#工作原理\" href=\"#工作原理\"></a></h4>\n<blockquote>\n<p>在客户端和服务器之间协商出一套对称密钥，每次发送消息之前将内容加密，收到之后解密，达到内容的加密传输</p>\n</blockquote>\n<p>为什么不直接用非对称加密?<br>\n非对称加密由于使用了复杂的数学原理，因此计算相当复杂，如果完全使用非对称加密来加密通信内容，会严重影响网络通信的性能</p>\n<h4 id=\"https流程\">HTTPS流程<a title=\"#https流程\" href=\"#https流程\"></a></h4>\n<ol>\n<li>客户端请求建立TLS连接</li>\n<li>服务器发回证书</li>\n<li>客户端验证服务器证书</li>\n<li>客户端信任服务器后，和服务器协商对称密钥</li>\n<li>使用对称密钥开始通信</li>\n</ol>\n<h2 id=\"about\">About<a title=\"#about\" href=\"#about\"></a></h2>\n<p><a href=\"https://www.jianshu.com/p/2a890d952461\" target=\"_blank\">登录授权、TCP/IP、HTTPS和代理</a><br>\n<a href=\"https://blog.csdn.net/kimlllll/article/details/103041225\" target=\"_blank\">编码、加密、Hash、TCP/IP、HTTPS</a><br>\n<a href=\"https://github.com/hsicen/HencoderPlus/blob/master/note/04-TCPIP%E5%92%8CHTTPS.md\" target=\"_blank\">HencoderPlus/04-TCPIP和HTTPS</a></p>\n",
            "tags": [
                "课程学习"
            ]
        },
        {
            "id": "https://onion99.github.io/2021/11/01/15jfHwStpctgCeeA/",
            "url": "https://onion99.github.io/2021/11/01/15jfHwStpctgCeeA/",
            "title": "源码学习-Glide",
            "date_published": "2021-10-31T21:29:17.000Z",
            "content_html": "<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Glide.with(fragment)</span><br><span class=\"line\">    .load(myUrl)</span><br><span class=\"line\">    .into(imageView);</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://z3.ax1x.com/2021/10/26/5oUW5R.png\" alt=\"5oUW5R.png\" loading=\"lazy\" class=\"φbp\"></p>\n<h3 id=\"with()\">with()<a title=\"#with()\" href=\"#with()\"></a></h3>\n<blockquote>\n<p>用Method初始化glide的一些必需的环境，然后调用Requestmanagerretriver的<code>get()</code>获取requestManager。如果传入的对象是全局Context，你就不需要处理生命周期;如果输入是具有生命周期的View(包含Frg或Act)则将添加一个隐藏的Fragment来感知生命周期</p>\n</blockquote>\n<span id=\"more\"></span>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> RequestManager <span class=\"title\">with</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Context context)</span> </span>&#123;  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> getRetriever(context).get(context);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"getretriever()\">getRetriever()<a title=\"#getretriever()\" href=\"#getretriever()\"></a></h4>\n<blockquote>\n<p>RequestManagerRetriever,用于创建新的RequestManager或从Activity和Fragment中检索现有的</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@NonNull</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> RequestManagerRetriever <span class=\"title\">getRetriever</span><span class=\"params\">(<span class=\"meta\">@Nullable</span> Context context)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 由于其他原因，上下文可能为空（即用户传入空值），但实际上它只会由于 Fragment 生命周期的错误而发生。</span></span><br><span class=\"line\">  Preconditions.checkNotNull(</span><br><span class=\"line\">      context,<span class=\"string\">&quot;You cannot start a load on a not yet attached View or a Fragment where getActivity() &quot;</span></span><br><span class=\"line\">          + <span class=\"string\">&quot;returns null (which usually occurs when getActivity() is called before the Fragment &quot;</span></span><br><span class=\"line\">          + <span class=\"string\">&quot;is attached or after the Fragment is destroyed).&quot;</span>);</span><br><span class=\"line\">  <span class=\"comment\">// 获取RequestManagerRetriever</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> Glide.get(context).getRequestManagerRetriever();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"get()\">get()<a title=\"#get()\" href=\"#get()\"></a></h4>\n<blockquote>\n<p>单例实现Glide的初始化</p>\n</blockquote>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//双重检查锁定在这里是安全的</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> static Glide <span class=\"keyword\">get</span>(<span class=\"meta\">@NonNull</span> Context context) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (glide == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 通过反射GeneratedAppGlideModuleImpl实例化Glide</span></span><br><span class=\"line\">    GeneratedAppGlideModule annotationGeneratedModule =</span><br><span class=\"line\">        getAnnotationGeneratedGlideModules(context.getApplicationContext()); </span><br><span class=\"line\">    synchronized (Glide.<span class=\"keyword\">class</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (glide == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        checkAndInitializeGlide(context, annotationGeneratedModule);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> glide;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"requestmanagerretriever.get()\">RequestManagerRetriever.get()<a title=\"#requestmanagerretriever.get()\" href=\"#requestmanagerretriever.get()\"></a></h4>\n<blockquote>\n<p>创建对应生命周期的RequestManager</p>\n</blockquote>\n<ul>\n<li>首先判断是在子线程,则拿一个全Context然后在工厂模式创建下RequestManager,所以推荐不要在子线程执行此操作</li>\n<li>如为FragmentActivity,则通过FragmentManager,创建一个空Fragment放进当前<code>Fragment</code>或者<code>Activity</code>,这样就可以感知宿主的生命周期,然后在工厂模式创建下RequestManager</li>\n<li>如为Activity…</li>\n<li>如为ContextWrapper…</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> RequestManager <span class=\"title\">get</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Activity activity)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (Util.isOnBackgroundThread()) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> get(activity.getApplicationContext());</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (activity <span class=\"keyword\">instanceof</span> FragmentActivity) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> get((FragmentActivity) activity);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    assertNotDestroyed(activity);</span><br><span class=\"line\">    frameWaiter.registerSelf(activity);</span><br><span class=\"line\">    android.app.FragmentManager fm = activity.getFragmentManager();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fragmentGet(activity, fm, <span class=\"comment\">/*parentHint=*/</span> <span class=\"keyword\">null</span>, isActivityVisible(activity));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// FragmentActivity Simple </span></span><br><span class=\"line\"><span class=\"meta\">@NonNull</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> RequestManager <span class=\"title\">get</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> FragmentActivity activity)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (Util.isOnBackgroundThread()) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> get(activity.getApplicationContext());</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    assertNotDestroyed(activity);</span><br><span class=\"line\">    frameWaiter.registerSelf(activity);</span><br><span class=\"line\">    FragmentManager fm = activity.getSupportFragmentManager();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> supportFragmentGet(activity, fm, <span class=\"comment\">/*parentHint=*/</span> <span class=\"keyword\">null</span>, isActivityVisible(activity));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 通过supportFragment感知创建</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> RequestManager <span class=\"title\">supportFragmentGet</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    <span class=\"meta\">@NonNull</span> Context context,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    <span class=\"meta\">@NonNull</span> FragmentManager fm,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    <span class=\"meta\">@Nullable</span> Fragment parentHint,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    <span class=\"keyword\">boolean</span> isParentVisible)</span> </span>&#123;</span><br><span class=\"line\">  SupportRequestManagerFragment current = getSupportRequestManagerFragment(fm, parentHint);</span><br><span class=\"line\">  RequestManager requestManager = current.getRequestManager();</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (requestManager == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 工厂模式创建</span></span><br><span class=\"line\">    Glide glide = Glide.get(context);</span><br><span class=\"line\">    requestManager =</span><br><span class=\"line\">        factory.build(</span><br><span class=\"line\">            glide, current.getGlideLifecycle(), current.getRequestManagerTreeNode(), context);</span><br><span class=\"line\">    <span class=\"comment\">// 这是一个小技巧，我们将启动 RequestManager，而不是相应的 Lifecycle。启动 RequestManager 是安全的，但启动 Lifecycle 可能会引发内存泄漏</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isParentVisible) &#123;</span><br><span class=\"line\">      requestManager.onStart();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    current.setRequestManager(requestManager);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> requestManager;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"load()\">load()<a title=\"#load()\" href=\"#load()\"></a></h3>\n<blockquote>\n<p>对全局变量赋值,构建ReqeustBuilder</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Drawable Simple</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> RequestBuilder&lt;Drawable&gt; <span class=\"title\">load</span><span class=\"params\">(<span class=\"meta\">@Nullable</span> Drawable drawable)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> asDrawable().load(drawable);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"into()\">into()<a title=\"#into()\" href=\"#into()\"></a></h3>\n<p>设置资源到加载的ImageView中 ，取消任何现有的加载，并释放 Glide 之前可能加载到ImageView的任何资源，以便它们可以被重用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 设置资源配置到TargetView</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ViewTarget&lt;ImageView, TranscodeType&gt; <span class=\"title\">into</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> ImageView view)</span> </span>&#123;</span><br><span class=\"line\">    Util.assertMainThread();</span><br><span class=\"line\">    ···</span><br><span class=\"line\">    <span class=\"keyword\">return</span> into(</span><br><span class=\"line\">        glideContext.buildImageViewTarget(view, transcodeClass),</span><br><span class=\"line\">        <span class=\"comment\">/*targetListener=*/</span> <span class=\"keyword\">null</span>,</span><br><span class=\"line\">        requestOptions,</span><br><span class=\"line\">        Executors.mainThreadExecutor());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"><span class=\"comment\">// 创建TargetView</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;X&gt; <span class=\"function\">ViewTarget&lt;ImageView, X&gt; <span class=\"title\">buildImageViewTarget</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">      <span class=\"meta\">@NonNull</span> ImageView imageView, <span class=\"meta\">@NonNull</span> Class&lt;X&gt; transcodeClass)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> imageViewTargetFactory.buildTarget(imageView, transcodeClass);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"><span class=\"comment\">// 负责为指定的android.view.View子类生成正确类型的Target工厂</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ImageViewTargetFactory</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@NonNull</span></span><br><span class=\"line\">  <span class=\"meta\">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> &lt;Z&gt; <span class=\"function\">ViewTarget&lt;ImageView, Z&gt; <span class=\"title\">buildTarget</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">      <span class=\"meta\">@NonNull</span> ImageView view, <span class=\"meta\">@NonNull</span> Class&lt;Z&gt; clazz)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Bitmap.class.equals(clazz)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> (ViewTarget&lt;ImageView, Z&gt;) <span class=\"keyword\">new</span> BitmapImageViewTarget(view);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (Drawable.class.isAssignableFrom(clazz)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> (ViewTarget&lt;ImageView, Z&gt;) <span class=\"keyword\">new</span> DrawableImageViewTarget(view);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(</span><br><span class=\"line\">          <span class=\"string\">&quot;Unhandled class: &quot;</span> + clazz + <span class=\"string\">&quot;, try .as*(Class).transcode(ResourceTranscoder)&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"into()-1\">into()<a title=\"#into()-1\" href=\"#into()-1\"></a></h4>\n<blockquote>\n<p>核心代码加载代码，看起来简单但实现起来复杂。<br>\n首先看看 buildRequest 如何初始化 request</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> &lt;Y extends Target&lt;TranscodeType&gt;&gt; <span class=\"function\">Y <span class=\"title\">into</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Y target, <span class=\"meta\">@Nullable</span> RequestListener&lt;TranscodeType&gt; targetListener, BaseRequestOptions&lt;?&gt; options, Executor callbackExecutor)</span> </span>&#123;</span><br><span class=\"line\">  Preconditions.checkNotNull(target);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!isModelSet) &#123; <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">&quot;You must call #load() before calling #into()&quot;</span>); &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 现在的请求</span></span><br><span class=\"line\">  Request request = buildRequest(target, targetListener, options, callbackExecutor);</span><br><span class=\"line\">  <span class=\"comment\">// 之前的请求</span></span><br><span class=\"line\">  Request previous = target.getRequest();</span><br><span class=\"line\">  <span class=\"comment\">// 如果之前的请求完成，重新开始以重新传递结果，触发 RequestListeners 和 Targets。如果请求失败，将重新请求，</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (request.isEquivalentTo(previous) &amp;&amp; !isSkipMemoryCacheWithCompletePreviousRequest(options, previous)) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果之前的请求已经在运行，我们可以让它继续运行而不中断</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!Preconditions.checkNotNull(previous).isRunning()) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 使用先前的请求而不是新的请求来优化，例如跳过设置占位符、跟踪和取消跟踪目标以及获取在单个请求中完成的视图维度</span></span><br><span class=\"line\">      previous.begin();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> target;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  requestManager.clear(target);</span><br><span class=\"line\">  target.setRequest(request);</span><br><span class=\"line\">  requestManager.track(target, request);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> target;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"requestbuilder.buildrequest()\">RequestBuilder.buildRequest()<a title=\"#requestbuilder.buildrequest()\" href=\"#requestbuilder.buildrequest()\"></a></h4>\n<blockquote>\n<p>根据存在的场景建立不同Request</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Request <span class=\"title\">buildRequest</span><span class=\"params\">(Target&lt;TranscodeType&gt; target, <span class=\"meta\">@Nullable</span> RequestListener&lt;TranscodeType&gt; targetListener, BaseRequestOptions&lt;?&gt; requestOptions, Executor callbackExecutor)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> buildRequestRecursive(<span class=\"comment\">/*requestLock=*/</span> <span class=\"keyword\">new</span> Object(), target, targetListener,<span class=\"comment\">/*parentCoordinator=*/</span> <span class=\"keyword\">null</span>, transitionOptions, requestOptions.getPriority(), requestOptions.getOverrideWidth(), requestOptions.getOverrideHeight(), requestOptions, callbackExecutor);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Request <span class=\"title\">buildRequestRecursive</span><span class=\"params\">(Object requestLock, Target&lt;TranscodeType&gt; target, <span class=\"meta\">@Nullable</span> RequestListener&lt;TranscodeType&gt; targetListener, <span class=\"meta\">@Nullable</span> RequestCoordinator parentCoordinator, TransitionOptions&lt;?, ? <span class=\"keyword\">super</span> TranscodeType&gt; transitionOptions, Priority priority, <span class=\"keyword\">int</span> overrideWidth, <span class=\"keyword\">int</span> overrideHeight, BaseRequestOptions&lt;?&gt; requestOptions, Executor callbackExecutor)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 如有必要首先构建 ErrorRequestCoordinator，以便我们可以更新 parentCoordinator。</span></span><br><span class=\"line\">  ErrorRequestCoordinator errorRequestCoordinator = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (errorBuilder != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    errorRequestCoordinator = <span class=\"keyword\">new</span> ErrorRequestCoordinator(requestLock, parentCoordinator);</span><br><span class=\"line\">    parentCoordinator = errorRequestCoordinator;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  Request mainRequest = buildThumbnailRequestRecursive(requestLock, target, targetListener, parentCoordinator, transitionOptions, priority, overrideWidth, overrideHeight, requestOptions, callbackExecutor);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (errorRequestCoordinator == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> mainRequest;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">int</span> errorOverrideWidth = errorBuilder.getOverrideWidth();</span><br><span class=\"line\">  <span class=\"keyword\">int</span> errorOverrideHeight = errorBuilder.getOverrideHeight();</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (Util.isValidDimensions(overrideWidth, overrideHeight) &amp;&amp; !errorBuilder.isValidOverride()) &#123;</span><br><span class=\"line\">    errorOverrideWidth = requestOptions.getOverrideWidth();</span><br><span class=\"line\">    errorOverrideHeight = requestOptions.getOverrideHeight();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  Request errorRequest = errorBuilder.buildRequestRecursive(requestLock, target, targetListener, errorRequestCoordinator, errorBuilder.transitionOptions, errorBuilder.getPriority(), errorOverrideWidth, errorOverrideHeight, errorBuilder, callbackExecutor);</span><br><span class=\"line\">  errorRequestCoordinator.setRequests(mainRequest, errorRequest);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> errorRequestCoordinator;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"requestbuilder.buildthumbnailrequestrecursive()\">RequestBuilder.buildThumbnailRequestRecursive()<a title=\"#requestbuilder.buildthumbnailrequestrecursive()\" href=\"#requestbuilder.buildthumbnailrequestrecursive()\"></a></h4>\n<blockquote>\n<p>根据是否需要缩略图,生成各种不同的Request</p>\n</blockquote>\n<p>这里经过一层又一层最终拿到一个<code>SingleRequest</code>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Request <span class=\"title\">buildThumbnailRequestRecursive</span><span class=\"params\">(Object requestLock, Target&lt;TranscodeType&gt; target, RequestListener&lt;TranscodeType&gt; targetListener, <span class=\"meta\">@Nullable</span> RequestCoordinator parentCoordinator, TransitionOptions&lt;?, ? <span class=\"keyword\">super</span> TranscodeType&gt; transitionOptions, Priority priority, <span class=\"keyword\">int</span> overrideWidth, <span class=\"keyword\">int</span> overrideHeight, BaseRequestOptions&lt;?&gt; requestOptions, Executor callbackExecutor)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (thumbnailBuilder != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 递归案例：包含一个潜在的递归缩略图Request Builder</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isThumbnailBuilt) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(</span><br><span class=\"line\">          <span class=\"string\">&quot;You cannot use a request as both the main request and a &quot;</span></span><br><span class=\"line\">              + <span class=\"string\">&quot;thumbnail, consider using clone() on the request(s) passed to thumbnail()&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    TransitionOptions&lt;?, ? <span class=\"keyword\">super</span> TranscodeType&gt; thumbTransitionOptions = thumbnailBuilder.transitionOptions;</span><br><span class=\"line\">    <span class=\"comment\">// 默认情况下我们的将过渡用在缩略图，但避免覆盖可能已明确应用于缩略图请求的自定义选项。</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (thumbnailBuilder.isDefaultTransitionOptionsSet) thumbTransitionOptions = transitionOptions;</span><br><span class=\"line\">    Priority thumbPriority = thumbnailBuilder.isPrioritySet() ? thumbnailBuilder.getPriority() : getThumbnailPriority(priority);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> thumbOverrideWidth = thumbnailBuilder.getOverrideWidth();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> thumbOverrideHeight = thumbnailBuilder.getOverrideHeight();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Util.isValidDimensions(overrideWidth, overrideHeight) &amp;&amp; !thumbnailBuilder.isValidOverride()) &#123;</span><br><span class=\"line\">      thumbOverrideWidth = requestOptions.getOverrideWidth();</span><br><span class=\"line\">      thumbOverrideHeight = requestOptions.getOverrideHeight();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ThumbnailRequestCoordinator coordinator = <span class=\"keyword\">new</span> ThumbnailRequestCoordinator(requestLock, parentCoordinator);</span><br><span class=\"line\">    Request fullRequest = obtainRequest(requestLock, target, targetListener, requestOptions, coordinator, transitionOptions, priority, overrideWidth, overrideHeight, callbackExecutor);</span><br><span class=\"line\">    isThumbnailBuilt = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 递归生成缩略图请求</span></span><br><span class=\"line\">    Request thumbRequest = thumbnailBuilder.buildRequestRecursive(requestLock, target,targetListener, coordinator, thumbTransitionOptions, thumbPriority, thumbOverrideWidth, thumbOverrideHeight, thumbnailBuilder, callbackExecutor);</span><br><span class=\"line\">    isThumbnailBuilt = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    coordinator.setRequests(fullRequest, thumbRequest);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> coordinator;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (thumbSizeMultiplier != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 基本情况：缩略图Multiplier生成缩略图请求，但不能递归。</span></span><br><span class=\"line\">    ThumbnailRequestCoordinator coordinator = <span class=\"keyword\">new</span> ThumbnailRequestCoordinator(requestLock, parentCoordinator);</span><br><span class=\"line\">    Request fullRequest = obtainRequest(requestLock, target, targetListener, requestOptions, coordinator, transitionOptions, priority, overrideWidth, overrideHeight, callbackExecutor);</span><br><span class=\"line\">    BaseRequestOptions&lt;?&gt; thumbnailOptions = requestOptions.clone().sizeMultiplier(thumbSizeMultiplier);</span><br><span class=\"line\">    Request thumbnailRequest = obtainRequest(requestLock, target, targetListener, thumbnailOptions, coordinator, transitionOptions, getThumbnailPriority(priority), overrideWidth, overrideHeight, callbackExecutor);</span><br><span class=\"line\">    coordinator.setRequests(fullRequest, thumbnailRequest);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> coordinator;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 基本情况：没有缩略图</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> obtainRequest(requestLock, target, targetListener, requestOptions, parentCoordinator, transitionOptions, priority, overrideWidth, overrideHeight, callbackExecutor);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Request <span class=\"title\">obtainRequest</span><span class=\"params\">(Object requestLock, Target&lt;TranscodeType&gt; target, RequestListener&lt;TranscodeType&gt; targetListener, BaseRequestOptions&lt;?&gt; requestOptions, RequestCoordinator requestCoordinator, TransitionOptions&lt;?, ? <span class=\"keyword\">super</span> TranscodeType&gt; transitionOptions, Priority priority, <span class=\"keyword\">int</span> overrideWidth, <span class=\"keyword\">int</span> overrideHeight, Executor callbackExecutor)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> SingleRequest.obtain(context, glideContext, requestLock, model, transcodeClass, requestOptions, overrideWidth, overrideHeight, priority, target, targetListener, requestListeners, requestCoordinator, glideContext.getEngine(), transitionOptions.getTransitionFactory(), callbackExecutor);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"requestmanager.track()\">RequestManager.track()<a title=\"#requestmanager.track()\" href=\"#requestmanager.track()\"></a></h4>\n<p>这里Glide将判断请求是否需要显示，如果它需要现在显示则开始执行，否则clear( )，并将请求放入队列。这种设计更精巧，省电</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">track</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Target&lt;?&gt; target, <span class=\"meta\">@NonNull</span> Request request)</span> </span>&#123;  </span><br><span class=\"line\">  targetTracker.track(target);  </span><br><span class=\"line\">  requestTracker.runRequest(request);  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/** 开始跟踪给定的请求 */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">runRequest</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Request request)</span> </span>&#123;</span><br><span class=\"line\">  requests.add(request);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!isPaused) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 启动异步加载</span></span><br><span class=\"line\">    request.begin();</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 防止从以前的请求加载任何位图，释放此请求持有的任何资源，显示当前占位符（如果提供），并将请求标记为已取消</span></span><br><span class=\"line\">    request.clear();</span><br><span class=\"line\">    pendingRequests.add(request);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"singlerequest.begin()\">SingleRequest.begin()<a title=\"#singlerequest.begin()\" href=\"#singlerequest.begin()\"></a></h4>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">begin</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">synchronized</span> (requestLock) &#123;</span><br><span class=\"line\">    assertNotCallingCallbacks();</span><br><span class=\"line\">    stateVerifier.throwIfRecycled();</span><br><span class=\"line\">    startTime = LogTime.getLogTime();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (model == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (Util.isValidDimensions(overrideWidth, overrideHeight)) &#123;</span><br><span class=\"line\">        width = overrideWidth;</span><br><span class=\"line\">        height = overrideHeight;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 如果用户设置可回调的Drawables,这里进行日志反馈</span></span><br><span class=\"line\">      <span class=\"keyword\">int</span> logLevel = getFallbackDrawable() == <span class=\"keyword\">null</span> ? Log.WARN : Log.DEBUG;</span><br><span class=\"line\">      onLoadFailed(<span class=\"keyword\">new</span> GlideException(<span class=\"string\">&quot;Received null model&quot;</span>), logLevel);</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (status == Status.RUNNING) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">&quot;Cannot restart a running request&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 如果我们在完成后重新启动(通常是通过notifyDataSetChanged之类的方式，向相同的目标或视图启动相同的请求)，我们可以简单地使用上次检索到的资源和大小，而跳过获取一个新的大小，开始一个新的加载等(这意味着希望重新启动加载的用户需要在开始新的加载之前显式地清除view或Target，因为他们觉得视图大小已经改变。)</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (status == Status.COMPLETE) &#123;</span><br><span class=\"line\">      onResourceReady(resource, DataSource.MEMORY_CACHE, <span class=\"comment\">/* isLoadedFromAlternateCacheKey= */</span> <span class=\"keyword\">false</span>);</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 对于既未完成也未运行的请求，重新启动可以被视为新请求，并可以从头开始运行</span></span><br><span class=\"line\">    cookie = GlideTrace.beginSectionAsync(TAG);</span><br><span class=\"line\">    status = Status.WAITING_FOR_SIZE;</span><br><span class=\"line\">    <span class=\"comment\">// 如果宽高已指定,则回调onSizeReady ,否则再获取宽高</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Util.isValidDimensions(overrideWidth, overrideHeight)) &#123;</span><br><span class=\"line\">      onSizeReady(overrideWidth, overrideHeight);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      target.getSize(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((status == Status.RUNNING || status == Status.WAITING_FOR_SIZE) &amp;&amp; canNotifyStatusChanged()) &#123;</span><br><span class=\"line\">      target.onLoadStarted(getPlaceholderDrawable());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>onLoadFailed : 图片或者资源为空,报错回调</li>\n<li>onResourceReady: 最终通过<code>Engine.release( )</code>,释放资源</li>\n<li>onSizeReady: View大小已明确 , 执行<code>Engine.load()</code>加载资源</li>\n<li>getSize: 获取View大小</li>\n<li>onLoadStarted: 等待或运行中,占位图处理</li>\n</ul>\n<h4 id=\"singlerequest.onsizeready(-)\">SingleRequest.onSizeReady( )<a title=\"#singlerequest.onsizeready(-)\" href=\"#singlerequest.onsizeready(-)\"></a></h4>\n<blockquote>\n<p>启动给定参数进行图片的加载, 必须在主线程上调用</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onSizeReady</span><span class=\"params\">(<span class=\"keyword\">int</span> width, <span class=\"keyword\">int</span> height)</span> </span>&#123;</span><br><span class=\"line\">  stateVerifier.throwIfRecycled();</span><br><span class=\"line\">  <span class=\"keyword\">synchronized</span> (requestLock) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (status != Status.WAITING_FOR_SIZE) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    status = Status.RUNNING;</span><br><span class=\"line\">    <span class=\"keyword\">float</span> sizeMultiplier = requestOptions.getSizeMultiplier();</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.width = maybeApplySizeMultiplier(width, sizeMultiplier);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.height = maybeApplySizeMultiplier(height, sizeMultiplier);</span><br><span class=\"line\">    loadStatus = engine.load(glideContext, model, requestOptions.getSignature(), <span class=\"keyword\">this</span>.width, <span class=\"keyword\">this</span>.height, requestOptions.getResourceClass(), transcodeClass, priority, requestOptions.getDiskCacheStrategy(), requestOptions.getTransformations(), requestOptions.isTransformationRequired(), requestOptions.isScaleOnlyOrNoTransform(), requestOptions.getOptions(), requestOptions.isMemoryCacheable(), requestOptions.getUseUnlimitedSourceGeneratorsPool(), requestOptions.getUseAnimationPool(), requestOptions.getOnlyRetrieveFromCache(), <span class=\"keyword\">this</span>, callbackExecutor);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"engine.load(-)\">Engine.load( )<a title=\"#engine.load(-)\" href=\"#engine.load(-)\"></a></h4>\n<blockquote>\n<p>到这里想都不用想了,Engine才是真正加载图片的Class,<br>\nEngine负责执行图片加载和管理活动资源和缓存资源。</p>\n</blockquote>\n<p>活动资源是指那些至少提供一个请求但未释放的资源。一旦资源的所有使用者都释放了该资源，该资源就会进入缓存。如果资源从缓存中返回给新的使用者，它将被重新添加到活动资源中。<br>\n如果从缓存中移除资源，它的资源将被回收和重用(如果可能的话)，资源将被丢弃。没有严格要求消费者释放他们的资源，所以活跃的资源被弱持有。</p>\n<p>请求流程:</p>\n<ul>\n<li>检查当前使用的资源集，返回活动资源（如果存在），并将任何新的非活动资源移动到内存缓存中</li>\n<li>检查内存缓存并提供缓存资源（如果存在）</li>\n<li>检查当前的一组正在进行的加载并将 cb 添加到进行中的加载（如果存在）</li>\n<li>开始加载</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> &lt;R&gt; <span class=\"function\">LoadStatus <span class=\"title\">load</span><span class=\"params\">(GlideContext glideContext, Object model, Key signature, <span class=\"keyword\">int</span> width, <span class=\"keyword\">int</span> height, Class&lt;?&gt; resourceClass, Class&lt;R&gt; transcodeClass, Priority priority, DiskCacheStrategy diskCacheStrategy, Map&lt;Class&lt;?&gt;, Transformation&lt;?&gt;&gt; transformations, <span class=\"keyword\">boolean</span> isTransformationRequired, <span class=\"keyword\">boolean</span> isScaleOnlyOrNoTransform, Options options, <span class=\"keyword\">boolean</span> isMemoryCacheable, <span class=\"keyword\">boolean</span> useUnlimitedSourceExecutorPool, <span class=\"keyword\">boolean</span> useAnimationPool, <span class=\"keyword\">boolean</span> onlyRetrieveFromCache, ResourceCallback cb, Executor callbackExecutor)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">long</span> startTime = VERBOSE_IS_LOGGABLE ? LogTime.getLogTime() : <span class=\"number\">0</span>;</span><br><span class=\"line\">  EngineKey key = keyFactory.buildKey(model, signature, width, height, transformations,resourceClass, transcodeClass, options);</span><br><span class=\"line\">  EngineResource&lt;?&gt; memoryResource;</span><br><span class=\"line\">  <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">    memoryResource = loadFromMemory(key, isMemoryCacheable, startTime);</span><br><span class=\"line\">    <span class=\"comment\">// 判断是否有缓存,有则直接加载</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (memoryResource == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> waitForExistingOrStartNewJob(glideContext, model, signature, width, height, resourceClass, transcodeClass, priority, diskCacheStrategy, transformations, isTransformationRequired, isScaleOnlyOrNoTransform, options, isMemoryCacheable, useUnlimitedSourceExecutorPool, useAnimationPool, onlyRetrieveFromCache, cb, callbackExecutor, key, startTime);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 避免在保持Engine锁时回调，因为这样做会更容易死锁</span></span><br><span class=\"line\">  cb.onResourceReady(memoryResource, DataSource.MEMORY_CACHE, <span class=\"comment\">/* isLoadedFromAlternateCacheKey= */</span> <span class=\"keyword\">false</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"engine.waitforexistingorstartnewjob(-)\">Engine.waitForExistingOrStartNewJob( )<a title=\"#engine.waitforexistingorstartnewjob(-)\" href=\"#engine.waitforexistingorstartnewjob(-)\"></a></h4>\n<blockquote>\n<p>等待或者执行任务</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> &lt;R&gt; <span class=\"function\">LoadStatus <span class=\"title\">waitForExistingOrStartNewJob</span><span class=\"params\">(GlideContext glideContext, Object model, Key signature, <span class=\"keyword\">int</span> width, <span class=\"keyword\">int</span> height, Class&lt;?&gt; resourceClass, Class&lt;R&gt; transcodeClass, Priority priority, DiskCacheStrategy diskCacheStrategy, Map&lt;Class&lt;?&gt;, Transformation&lt;?&gt;&gt; transformations, <span class=\"keyword\">boolean</span> isTransformationRequired, <span class=\"keyword\">boolean</span> isScaleOnlyOrNoTransform, Options options, <span class=\"keyword\">boolean</span> isMemoryCacheable, <span class=\"keyword\">boolean</span> useUnlimitedSourceExecutorPool, <span class=\"keyword\">boolean</span> useAnimationPool, <span class=\"keyword\">boolean</span> onlyRetrieveFromCache, ResourceCallback cb, Executor callbackExecutor, EngineKey key, <span class=\"keyword\">long</span> startTime)</span> </span>&#123;</span><br><span class=\"line\">  EngineJob&lt;?&gt; current = jobs.get(key, onlyRetrieveFromCache);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (current != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    current.addCallback(cb, callbackExecutor);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> LoadStatus(cb, current);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  EngineJob&lt;R&gt; engineJob = engineJobFactory.build(key, isMemoryCacheable, useUnlimitedSourceExecutorPool, useAnimationPool, onlyRetrieveFromCache);</span><br><span class=\"line\">  DecodeJob&lt;R&gt; decodeJob = decodeJobFactory.build(glideContext, model, key, signature, width, height, resourceClass, transcodeClass, priority, diskCacheStrategy, transformations, isTransformationRequired, isScaleOnlyOrNoTransform, onlyRetrieveFromCache, options, engineJob);</span><br><span class=\"line\">  jobs.put(key, engineJob);</span><br><span class=\"line\">  engineJob.addCallback(cb, callbackExecutor);</span><br><span class=\"line\">  engineJob.start(decodeJob);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (VERBOSE_IS_LOGGABLE)  logWithTimeAndKey(<span class=\"string\">&quot;Started new load&quot;</span>, startTime, key);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> LoadStatus(cb, engineJob);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"decodejob\">DecodeJob<a title=\"#decodejob\" href=\"#decodejob\"></a></h4>\n<blockquote>\n<p>负责从缓存数据或原始源中解码资源并应用转换和转码的类</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span>  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isCancelled) &#123;</span><br><span class=\"line\">      notifyFailed();</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    runWrapped();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">runWrapped</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 为了判断运行原因,这里做了三个判断</span></span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (runReason) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> INITIALIZE:</span><br><span class=\"line\">      <span class=\"comment\">// 获取当前解码数据的阶段</span></span><br><span class=\"line\">      stage = getNextStage(Stage.INITIALIZE);</span><br><span class=\"line\">      <span class=\"comment\">// 获取数据生成器</span></span><br><span class=\"line\">      currentGenerator = getNextGenerator();</span><br><span class=\"line\">      runGenerators();</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> SWITCH_TO_SOURCE_SERVICE:</span><br><span class=\"line\">      runGenerators();</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> DECODE_DATA:</span><br><span class=\"line\">      decodeFromRetrievedData();</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">&quot;Unrecognized run reason: &quot;</span> + runReason);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"rungenerators(-)\">runGenerators( )<a title=\"#rungenerators(-)\" href=\"#rungenerators(-)\"></a></h5>\n<p>currentGenerator实现DataFetcherGenerator接口，这个接口主要用来生成一系列的modelLoader和model</p>\n<p>目前Glide有三种类生成器</p>\n<ul>\n<li>ResourceCacheGenerator</li>\n<li>DataCacheGenerator</li>\n<li>SourceGenerator</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">runGenerators</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  currentThread = Thread.currentThread();</span><br><span class=\"line\">  startFetchTime = LogTime.getLogTime();</span><br><span class=\"line\">  <span class=\"keyword\">boolean</span> isStarted = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">  <span class=\"comment\">// startNext -&gt; 尝试单个新的DataFetcher，如果DataFetcher已启动则返回true，否则返回false</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (!isCancelled &amp;&amp; currentGenerator != <span class=\"keyword\">null</span> &amp;&amp; !(isStarted = currentGenerator.startNext())) &#123;</span><br><span class=\"line\">    stage = getNextStage(stage);</span><br><span class=\"line\">    currentGenerator = getNextGenerator();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (stage == Stage.SOURCE) &#123;</span><br><span class=\"line\">      reschedule();</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// We&#x27;ve run out of stages and generators, give up.</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> ((stage == Stage.FINISHED || isCancelled) &amp;&amp; !isStarted) &#123;</span><br><span class=\"line\">    notifyFailed();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> DataFetcherGenerator <span class=\"title\">getNextGenerator</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (stage) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> RESOURCE_CACHE:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ResourceCacheGenerator(decodeHelper, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">case</span> DATA_CACHE:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> DataCacheGenerator(decodeHelper, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">case</span> SOURCE:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> SourceGenerator(decodeHelper, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">case</span> FINISHED:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">&quot;Unrecognized stage: &quot;</span> + stage);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h6 id=\"sourcegenerator.startnext()\">SourceGenerator.startNext()<a title=\"#sourcegenerator.startnext()\" href=\"#sourcegenerator.startnext()\"></a></h6>\n<p>将首先判断，缓存如果它不是空的，调用 cacheData; 否则，获取 loadData，然后执行 startNextLoad ()</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">startNext</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (dataToCache != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    Object data = dataToCache;</span><br><span class=\"line\">    dataToCache = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">boolean</span> isDataInCache = cacheData(data);</span><br><span class=\"line\">      <span class=\"comment\">// 如果我们没有将数据写入缓存，cacheData方法将尝试直接解码原始数据，而不是通过磁盘缓存。因为此时cacheData已经调用了我们的回调函数，所以除了返回，没有其他事情可做了</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!isDataInCache) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 如果我们能够成功地将数据写入缓存，那么现在需要继续调用下面的sourceCacheGenerator来从缓存加载数据</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// IOException意味着我们无法将数据写入缓存，或者在磁盘缓存写入失败后无法倒带数据。无论哪种情况，我们都可以继续尝试下面的下一个取回</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (Log.isLoggable(TAG, Log.DEBUG)) &#123;</span><br><span class=\"line\">        Log.d(TAG, <span class=\"string\">&quot;Failed to properly rewind or write data to cache&quot;</span>, e);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (sourceCacheGenerator != <span class=\"keyword\">null</span> &amp;&amp; sourceCacheGenerator.startNext()) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  sourceCacheGenerator = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  loadData = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">boolean</span> started = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (!started &amp;&amp; hasNextModelLoader()) &#123;</span><br><span class=\"line\">    loadData = helper.getLoadData().get(loadDataListIndex++);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (loadData != <span class=\"keyword\">null</span></span><br><span class=\"line\">        &amp;&amp; (helper.getDiskCacheStrategy().isDataCacheable(loadData.fetcher.getDataSource())</span><br><span class=\"line\">            || helper.hasLoadPath(loadData.fetcher.getDataClass()))) &#123;</span><br><span class=\"line\">      started = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">      startNextLoad(loadData);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> started;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h6 id=\"sourcegenerator.cachedata\">SourceGenerator.cacheData<a title=\"#sourcegenerator.cachedata\" href=\"#sourcegenerator.cachedata\"></a></h6>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 如果我们能够缓存数据，应该尝试直接从缓存解码数据，如果我们不能缓存数据，应该尝试从源解码，则返回false</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">cacheData</span><span class=\"params\">(Object dataToCache)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">boolean</span> isLoadingFromSourceData = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    DataRewinder&lt;Object&gt; rewinder = helper.getRewinder(dataToCache);</span><br><span class=\"line\">    Object data = rewinder.rewindAndGet();</span><br><span class=\"line\">    Encoder&lt;Object&gt; encoder = helper.getSourceEncoder(data);</span><br><span class=\"line\">    DataCacheWriter&lt;Object&gt; writer = <span class=\"keyword\">new</span> DataCacheWriter&lt;&gt;(encoder, data, helper.getOptions());</span><br><span class=\"line\">    DataCacheKey newOriginalKey = <span class=\"keyword\">new</span> DataCacheKey(loadData.sourceKey, helper.getSignature());</span><br><span class=\"line\">    DiskCache diskCache = helper.getDiskCache();</span><br><span class=\"line\">    diskCache.put(newOriginalKey, writer);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (diskCache.get(newOriginalKey) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      originalKey = newOriginalKey;</span><br><span class=\"line\">      sourceCacheGenerator = <span class=\"keyword\">new</span> DataCacheGenerator(Collections.singletonList(loadData.sourceKey), helper, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">      <span class=\"comment\">// 我们能够将数据写入缓存</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      isLoadingFromSourceData = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">      cb.onDataFetcherReady(loadData.sourceKey, rewinder.rewindAndGet(), loadData.fetcher, loadData.fetcher.getDataSource(), loadData.sourceKey);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 写入数据到缓存失败的处理</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isLoadingFromSourceData) &#123;</span><br><span class=\"line\">      loadData.fetcher.cleanup();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h6 id=\"decodehelper.getsourceencoder()\">DecodeHelper.getSourceEncoder()<a title=\"#decodehelper.getsourceencoder()\" href=\"#decodehelper.getsourceencoder()\"></a></h6>\n<p>DecodeHelper.java</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;X&gt; <span class=\"function\">Encoder&lt;X&gt; <span class=\"title\">getSourceEncoder</span><span class=\"params\">(X data)</span> <span class=\"keyword\">throws</span> Registry.NoSourceEncoderAvailableException </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> glideContext.getRegistry().getSourceEncoder(data);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Registry.java</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> &lt;X&gt; <span class=\"function\">Encoder&lt;X&gt; <span class=\"title\">getSourceEncoder</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> X data)</span> <span class=\"keyword\">throws</span> NoSourceEncoderAvailableException </span>&#123;  </span><br><span class=\"line\">  Encoder&lt;X&gt; encoder = encoderRegistry.getEncoder((Class&lt;X&gt;) data.getClass());  </span><br><span class=\"line\">  <span class=\"keyword\">if</span>(encoder != <span class=\"keyword\">null</span>) &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> encoder;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NoSourceEncoderAvailableException(data.getClass());  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h6 id=\"register\">Register<a title=\"#register\" href=\"#register\"></a></h6>\n<blockquote>\n<p>每个数据类型对应一个编码器,Register就是用来记录这些的</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">registry</span><br><span class=\"line\">        .append(ByteBuffer.class, <span class=\"keyword\">new</span> ByteBufferEncoder())</span><br><span class=\"line\">        .append(InputStream.class, <span class=\"keyword\">new</span> StreamEncoder(arrayPool))</span><br><span class=\"line\">        .append(Registry.BUCKET_BITMAP, ByteBuffer.class, Bitmap.class, byteBufferBitmapDecoder)</span><br><span class=\"line\">        .append(Registry.BUCKET_BITMAP, InputStream.class, Bitmap.class, streamBitmapDecoder);</span><br></pre></td></tr></table></figure>\n<h5 id=\"decodefromretrieveddata()\">decodeFromRetrievedData()<a title=\"#decodefromretrieveddata()\" href=\"#decodefromretrieveddata()\"></a></h5>\n<blockquote>\n<p>处理返回的数据</p>\n</blockquote>\n<p><img src=\"https://z3.ax1x.com/2021/10/26/5oU7rD.png\" alt=\"5oU7rD.png\" loading=\"lazy\" class=\"φbp\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> &lt;Data&gt; <span class=\"function\">Resource&lt;R&gt; <span class=\"title\">decodeFromData</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    DataFetcher&lt;?&gt; fetcher, Data data, DataSource dataSource)</span> <span class=\"keyword\">throws</span> GlideException </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (data == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> startTime = LogTime.getLogTime();</span><br><span class=\"line\">    Resource&lt;R&gt; result = decodeFromFetcher(data, dataSource);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class=\"line\">      logWithTimeAndKey(<span class=\"string\">&quot;Decoded result &quot;</span> + result, startTime);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    fetcher.cleanup();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> &lt;Data&gt; <span class=\"function\">Resource&lt;R&gt; <span class=\"title\">decodeFromFetcher</span><span class=\"params\">(Data data, DataSource dataSource)</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"keyword\">throws</span> GlideException </span>&#123;</span><br><span class=\"line\">  LoadPath&lt;Data, ?, R&gt; path = decodeHelper.getLoadPath((Class&lt;Data&gt;) data.getClass());</span><br><span class=\"line\">  <span class=\"keyword\">return</span> runLoadPath(data, dataSource, path);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"enginejob\">EngineJob<a title=\"#enginejob\" href=\"#enginejob\"></a></h4>\n<blockquote>\n<p>通过添加和删除加载回调并在加载完成时通知回调来管理加载的类(管理加载过程中的一些回调)</p>\n</blockquote>\n<p>GlideExecutor是一个继承的Executorservice类，它显然是一个线程池。这里通过decodeJob来确定是否从缓存解析，如果是从缓存解析，调用diskCacheExecutor，否则，调用getActiveSourceExecutor</p>\n<ul>\n<li>willDecodeFromCache\n<ul>\n<li>如果此作业将尝试从磁盘缓存解码资源，则返回true</li>\n<li>如果始终从源解码，则返回false</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">start</span><span class=\"params\">(DecodeJob&lt;R&gt; decodeJob)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.decodeJob = decodeJob;</span><br><span class=\"line\">  GlideExecutor executor = decodeJob.willDecodeFromCache() ? diskCacheExecutor : getActiveSourceExecutor();</span><br><span class=\"line\">  <span class=\"comment\">// 执行decodeJob线程任务</span></span><br><span class=\"line\">  executor.execute(decodeJob);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n",
            "tags": [
                "源码解析"
            ]
        },
        {
            "id": "https://onion99.github.io/2021/11/01/4SVquTFcR8Wyv4GV/",
            "url": "https://onion99.github.io/2021/11/01/4SVquTFcR8Wyv4GV/",
            "title": "源码学习-OkHttp",
            "date_published": "2021-10-31T21:28:18.000Z",
            "content_html": "<blockquote>\n<p>http的连接本质上是个socket，根据http协议，通过socket包装发送请求并获得返回结果</p>\n</blockquote>\n<p>网路连接库一开始的样子如下代码所示，其实只要符合Http协议的请求，就可以和网络进行交互，类似于OkHttp的网络请求库，帮助开发者方便和屏蔽了Http协议中类似于请求头，重连、合并、代理、返回结果解析等等Http协议细节的应用层实现。</p>\n<span id=\"more\"></span>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">val path = <span class=\"string\">&quot;http://www.baidu.com/&quot;</span></span><br><span class=\"line\">        val host = <span class=\"string\">&quot;www.baidu.com&quot;</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> socket: Socket? = <span class=\"keyword\">null</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> streamWriter: OutputStreamWriter? = <span class=\"keyword\">null</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> bufferedWriter: BufferedWriter? = <span class=\"keyword\">null</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            socket = Socket(host, <span class=\"number\">80</span>)</span><br><span class=\"line\">            streamWriter = OutputStreamWriter(socket.getOutputStream())</span><br><span class=\"line\">            bufferedWriter = BufferedWriter(streamWriter)</span><br><span class=\"line\">            bufferedWriter.write(<span class=\"string\">&quot;GET $path HTTP/1.1\\r\\n&quot;</span>)</span><br><span class=\"line\">            bufferedWriter.write(<span class=\"string\">&quot;Host: www.baidu.com\\r\\n&quot;</span>)</span><br><span class=\"line\">            bufferedWriter.write(<span class=\"string\">&quot;\\r\\n&quot;</span>)</span><br><span class=\"line\">            bufferedWriter.flush()</span><br><span class=\"line\">            val myRequest = BufferedReader(InputStreamReader(socket.getInputStream(), <span class=\"string\">&quot;UTF-8&quot;</span>))</span><br><span class=\"line\">            <span class=\"keyword\">var</span> d = -<span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (myRequest.read().also(&#123; d = it &#125;) != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                print(d.toChar())</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (e: IOException) &#123;</span><br><span class=\"line\">            e.printStackTrace()</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"整体流程\">整体流程<a title=\"#整体流程\" href=\"#整体流程\"></a></h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GetExample</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 核网络管理者 - 核心类</span></span><br><span class=\"line\">  <span class=\"keyword\">final</span> OkHttpClient client = <span class=\"keyword\">new</span> OkHttpClient();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\">String <span class=\"title\">run</span><span class=\"params\">(String url)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 请求搭建</span></span><br><span class=\"line\">    Request request = <span class=\"keyword\">new</span> Request.Builder().url(url).build();</span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">      阻塞式execute -&gt; 立即调用请求，并阻塞，直到响应可以处理或出现错误</span></span><br><span class=\"line\"><span class=\"comment\">      为了避免资源泄漏，调用者应该关闭Response，而Response又会关闭底层的ResponseBody。 //确保响应(和底层响应体)是关闭的</span></span><br><span class=\"line\"><span class=\"comment\">      注意，传输层的成功(接收HTTP响应代码、报头和正文)不一定表示应用层的成功:响应可能仍然表示不满意的HTTP响应代码，如404或500。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span> (Response response = client.newCall(request).execute()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> response.body().string();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    GetExample example = <span class=\"keyword\">new</span> GetExample();</span><br><span class=\"line\">    String response = example.run(<span class=\"string\">&quot;https://raw.github.com/square/okhttp/master/README.md&quot;</span>);</span><br><span class=\"line\">    System.out.println(response);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><img src=\"https://z3.ax1x.com/2021/10/25/5hiy4O.png\" alt=\"5hiy4O.png\" loading=\"lazy\" class=\"φbp\"></p>\n<h3 id=\"连接建立\">连接建立<a title=\"#连接建立\" href=\"#连接建立\"></a></h3>\n<p>Volley等很多网络请求框架很多底层都是通过 HTTPURLConnection 来与服务端建立连接的，而 OkHttp 就比较优秀了。因为 HTTP 协议是建立在 TCP/IP 协议基础之上的，底层还是走的 Socket，所以OkHttp 直接使用 Socket 来完成 HTTP 请求。</p>\n<h3 id=\"okhttpclient\">OkHttpClient<a title=\"#okhttpclient\" href=\"#okhttpclient\"></a></h3>\n<p>官方推荐我们使用单例去创建OkHttpClient，重用所有HTTP调用的时候，性能是最佳的， 这是因为每个客户端都拥有自己的连接池和线程池。 重用连接和线程可减少延迟并节省内存。 相反，为每个请求创建一个客户端会浪费空闲池上的资源</p>\n<h3 id=\"request\">Request<a title=\"#request\" href=\"#request\"></a></h3>\n<p>采用Builder的方式进行设计，主要包含了url、method、headers、body和CacheControl组成的各种配置项</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> Dispatcher dispatcher;  <span class=\"comment\">//分发器</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> Proxy proxy;  <span class=\"comment\">//代理</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> List&lt;Protocol&gt; protocols; <span class=\"comment\">//协议</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> List&lt;ConnectionSpec&gt; connectionSpecs; <span class=\"comment\">//传输层版本和连接协议</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> List&lt;Interceptor&gt; interceptors; <span class=\"comment\">//拦截器</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> List&lt;Interceptor&gt; networkInterceptors; <span class=\"comment\">//网络拦截器</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> ProxySelector proxySelector; <span class=\"comment\">//代理选择</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> CookieJar cookieJar; <span class=\"comment\">//cookie</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> Cache cache; <span class=\"comment\">//缓存</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> InternalCache internalCache;  <span class=\"comment\">//内部缓存</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> SocketFactory socketFactory;  <span class=\"comment\">//socket 工厂</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> SSLSocketFactory sslSocketFactory; <span class=\"comment\">//安全套接层socket 工厂，用于HTTPS</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> CertificateChainCleaner certificateChainCleaner; <span class=\"comment\">// 验证确认响应证书 适用 HTTPS 请求连接的主机名。</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> HostnameVerifier hostnameVerifier;    <span class=\"comment\">//  主机名字确认</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> CertificatePinner certificatePinner;  <span class=\"comment\">//  证书链</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> Authenticator proxyAuthenticator;     <span class=\"comment\">//代理身份验证</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> Authenticator authenticator;      <span class=\"comment\">// 本地身份验证</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> ConnectionPool connectionPool;    <span class=\"comment\">//连接池,复用连接</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> Dns dns;  <span class=\"comment\">//域名</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> followSslRedirects;  <span class=\"comment\">//安全套接层重定向</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> followRedirects;  <span class=\"comment\">//本地重定向</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> retryOnConnectionFailure; <span class=\"comment\">//重试连接失败</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> connectTimeout;    <span class=\"comment\">//连接超时</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> readTimeout; <span class=\"comment\">//read 超时</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> writeTimeout; <span class=\"comment\">//write 超时 </span></span><br></pre></td></tr></table></figure>\n<h3 id=\"call\">Call<a title=\"#call\" href=\"#call\"></a></h3>\n<blockquote>\n<p>一个提供 HTTP 请求执行相关接口的接口类，具体的实现类是 RealCall</p>\n</blockquote>\n<ul>\n<li>可以取消</li>\n<li>此对象表示单个请求/响应对(流),因此不能执行两次</li>\n</ul>\n<h4 id=\"realcall\">RealCall<a title=\"#realcall\" href=\"#realcall\"></a></h4>\n<blockquote>\n<p>OkHttp的应用层和网络层之间的桥梁,包含了网络的连接、请求、响应和流处理整个流程,也是OkHttp中最关键核心的类</p>\n</blockquote>\n<h5 id=\"asynctimeout\">AsyncTimeout<a title=\"#asynctimeout\" href=\"#asynctimeout\"></a></h5>\n<p>此超时用在在后台线程执行超时时执行操作。 使用它来实现本地不支持的超时，例如写入时被阻止的套接字,子类应该覆盖timedOut以在发生超时时采取行动。 此方法将由共享看门狗线程调用，因此不应执行任何长时间运行的操作。 否则，我们可能会面临触发其他超时的风险。<br>\n使用sink和source将此超时应用于流。 返回的值将超时应用于包装流上的每个操作。<br>\n调用者应该在执行可能超时的工作之前调用enter ，然后退出。 exit的返回值表示是否触发了超时。 请注意，对timedOut的调用是异步的，可以在exit之后调用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> val timeout = object : AsyncTimeout() &#123;  </span><br><span class=\"line\">  <span class=\"function\">override fun <span class=\"title\">timedOut</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"comment\">// 取消请求  </span></span><br><span class=\"line\">  cancel()  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;.apply &#123;  </span><br><span class=\"line\">  timeout(client.callTimeoutMillis.toLong(), MILLISECONDS)  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"execute\">execute<a title=\"#execute\" href=\"#execute\"></a></h5>\n<blockquote>\n<p>同步请求,  马上执行并阻塞直到可以处理响应或出现错误</p>\n</blockquote>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">execute</span><span class=\"params\">()</span></span>: Response &#123;</span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * Atomic就是原子性的意思，源码里用了Volatile属性，即能够保证在高并发的情况下只有一个线程能够访问这个属性值</span></span><br><span class=\"line\"><span class=\"comment\">   * executed 是一个原子变量，一般情况下，我们使用 AtomicBoolean 高效并发处理 “只初始化一次” 的功能要求,用 compareAndSet(false, true)</span></span><br><span class=\"line\"><span class=\"comment\">   * 判断多线程状态下，请求是否重新执行：如果值为false，则抛出一个IllegalStateException，并返回调用lazyMessage的结果。</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  check(executed.compareAndSet(<span class=\"literal\">false</span>, <span class=\"literal\">true</span>)) &#123; <span class=\"string\">&quot;Already Executed&quot;</span> &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 超时计数开始</span></span><br><span class=\"line\">  timeout.enter()</span><br><span class=\"line\">  <span class=\"comment\">// 执行请求前处理 -&gt; 栈跟踪，事件回调等等</span></span><br><span class=\"line\">  callStart()</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 调度器开始执行</span></span><br><span class=\"line\">    client.dispatcher.executed(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">    <span class=\"comment\">// 返回拦截器处理下的响应</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> getResponseWithInterceptorChain()</span><br><span class=\"line\">  &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 调度器返回完成信号</span></span><br><span class=\"line\">    client.dispatcher.finished(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"enqueue\">enqueue<a title=\"#enqueue\" href=\"#enqueue\"></a></h5>\n<blockquote>\n<p>异步调度,  将请求放到队列中等到执行</p>\n</blockquote>\n<p>RealCall.kt</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">enqueue</span><span class=\"params\">(responseCallback: <span class=\"type\">Callback</span>)</span></span> &#123;  </span><br><span class=\"line\">  <span class=\"comment\">// 首先判断当前请求是否已执行，如果已经执行则打印日志，并抛出 IllegalStateException 异常</span></span><br><span class=\"line\">  check(executed.compareAndSet(<span class=\"literal\">false</span>, <span class=\"literal\">true</span>)) &#123; <span class=\"string\">&quot;Already Executed&quot;</span> &#125;  </span><br><span class=\"line\">  callStart()  </span><br><span class=\"line\">  <span class=\"comment\">// 创建一个AsyncCall对象,放进分发器队列中</span></span><br><span class=\"line\">  client.dispatcher.enqueue(AsyncCall(responseCallback))  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">callStart</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 返回一个对象，该对象包含在执行此方法时创建的堆栈跟踪</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.callStackTrace = Platform.<span class=\"keyword\">get</span>().getStackTraceForCloseable(<span class=\"string\">&quot;response.body().close()&quot;</span>)</span><br><span class=\"line\">    eventListener.callStart(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Dispatcher.kt</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">///////////////////////////////////////////////////////////////////////////</span></span><br><span class=\"line\"><span class=\"comment\">// https://zhuanlan.zhihu.com/p/261397170</span></span><br><span class=\"line\"><span class=\"comment\">// ArrayDeque -  Java 集合中双端队列的数组实现</span></span><br><span class=\"line\"><span class=\"comment\">// ArrayDeque 几乎没有容量限制，设计为线程不安全的，禁止 null 元素</span></span><br><span class=\"line\"><span class=\"comment\">// ArrayDeque是Deque的实现类，可以作为栈来使用，效率高于Stack；也可以作为队列来使用，效率高于LinkedList。</span></span><br><span class=\"line\"><span class=\"comment\">// ArrayDeque 大多数的额操作都在固定时间内运行，例外情况包括 remove，removeFirstOccurrence，removeLastOccurrence，contains，iterator.remove()，和批量操作，这些将以线性时间运行</span></span><br><span class=\"line\"><span class=\"comment\">///////////////////////////////////////////////////////////////////////////</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">val</span> runningSyncCalls = ArrayDeque&lt;RealCall&gt;()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">internal</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">enqueue</span><span class=\"params\">(call: <span class=\"type\">AsyncCall</span>)</span></span> &#123;</span><br><span class=\"line\">  synchronized(<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 将请求 AsyncCall 添加到待执行队列</span></span><br><span class=\"line\">    readyAsyncCalls.add(call)</span><br><span class=\"line\">    <span class=\"comment\">// 判断当前请求是否已存在可复用的 hos</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!call.call.forWebSocket) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">val</span> existingCall = findExistingCallWithHost(call.host)</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (existingCall != <span class=\"literal\">null</span>) call.reuseCallsPerHostFrom(existingCall)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 将符合条件的Call从readyAsyncCalls 提升到runningAsyncCalls并在执行它们</span></span><br><span class=\"line\">  promoteAndExecute()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>RealCall.AsyncCall</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">run</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 给当前AsyncCall异步线程设置名称</span></span><br><span class=\"line\">    threadName(<span class=\"string\">&quot;OkHttp <span class=\"subst\">$&#123;redactedUrl()&#125;</span>&quot;</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> signalledCallback = <span class=\"literal\">false</span></span><br><span class=\"line\">      timeout.enter()</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 获取请求结果</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> response = getResponseWithInterceptorChain()</span><br><span class=\"line\">        signalledCallback = <span class=\"literal\">true</span></span><br><span class=\"line\">        <span class=\"comment\">// 触发相应回调</span></span><br><span class=\"line\">        responseCallback.onResponse(<span class=\"keyword\">this</span><span class=\"symbol\">@RealCall</span>, response)</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (e: IOException) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (signalledCallback) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// Do not signal the callback twice!</span></span><br><span class=\"line\">          Platform.<span class=\"keyword\">get</span>().log(<span class=\"string\">&quot;Callback failure for <span class=\"subst\">$&#123;toLoggableString()&#125;</span>&quot;</span>, Platform.INFO, e)</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          responseCallback.onFailure(<span class=\"keyword\">this</span><span class=\"symbol\">@RealCall</span>, e)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (t: Throwable) &#123;</span><br><span class=\"line\">        cancel()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!signalledCallback) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">val</span> canceledException = IOException(<span class=\"string\">&quot;canceled due to <span class=\"variable\">$t</span>&quot;</span>)</span><br><span class=\"line\">          canceledException.addSuppressed(t)</span><br><span class=\"line\">          responseCallback.onFailure(<span class=\"keyword\">this</span><span class=\"symbol\">@RealCall</span>, canceledException)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> t</span><br><span class=\"line\">      &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 关闭请求</span></span><br><span class=\"line\">        client.dispatcher.finished(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"dispatcher(分发器)\">Dispatcher(分发器)<a title=\"#dispatcher(分发器)\" href=\"#dispatcher(分发器)\"></a></h3>\n<blockquote>\n<p>用于管理其对应 OkHttpClient 的所有请求,对Call进行统一的控制，例如结束所有请求、获取线程池等等</p>\n</blockquote>\n<ul>\n<li>readyAsyncCalls：一个新的异步请求首先会被加入该队列中</li>\n<li>runningAsyncCalls：当前正在运行中的异步请求</li>\n<li>runningSyncCalls：当前正在运行的同步请求</li>\n</ul>\n<p>异步请求跟同步请求一样,最终都会调用到<code>getResponseWithInterceptorChain()</code></p>\n<h3 id=\"interceptor(拦截器)\">Interceptor(拦截器)<a title=\"#interceptor(拦截器)\" href=\"#interceptor(拦截器)\"></a></h3>\n<blockquote>\n<p>Interceptor 接口作为一个拦截器的抽象概念，被设计为责任链上的单位节点，用于观察、拦截、处理请求等，例如添加 Header、重定向、数据处理等等。<br>\nInterceptor 之间互相独立，每个 Interceptor 只负责自己关注的任务，不与其他 Interceptor 接触。</p>\n</blockquote>\n<p>RealCall.kt</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Throws(IOException::class)</span></span><br><span class=\"line\"><span class=\"keyword\">internal</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getResponseWithInterceptorChain</span><span class=\"params\">()</span></span>: Response &#123;</span><br><span class=\"line\">  <span class=\"comment\">// <span class=\"doctag\">TODO:</span> 2021/8/13 okhttp的核心是拦截器，而拦截器所采用的设计模式是责任链设计，即每个拦截器只处理与自己相关的业务逻辑 https://zhuanlan.zhihu.com/p/340090732</span></span><br><span class=\"line\">  <span class=\"comment\">// 构建整个网络请求拦截</span></span><br><span class=\"line\">  <span class=\"keyword\">val</span> interceptors = mutableListOf&lt;Interceptor&gt;()</span><br><span class=\"line\">  <span class=\"comment\">// 添加Client的拦截器</span></span><br><span class=\"line\">  interceptors += client.interceptors</span><br><span class=\"line\">  <span class=\"comment\">// 添加失败重连的拦截器</span></span><br><span class=\"line\">  interceptors += RetryAndFollowUpInterceptor(client)</span><br><span class=\"line\">  <span class=\"comment\">// 添加请求桥梁拦截器 - 在对用户的请求头部加了一些信息，然后在获取到的响应中也做了一些处理。而这些处理对用户是透明的，减少了客户请求的工作</span></span><br><span class=\"line\">  interceptors += BridgeInterceptor(client.cookieJar)</span><br><span class=\"line\">  <span class=\"comment\">// 添加缓存拦截器 - 理来自缓存的请求并将响应写入缓存。</span></span><br><span class=\"line\">  interceptors += CacheInterceptor(client.cache)</span><br><span class=\"line\">  <span class=\"comment\">// 添加请求中拦截器 - 打开与目标服务器的连接并继续下一个拦截器。 网络可能用于返回的响应，或使用条件 GET 验证缓存的响应</span></span><br><span class=\"line\">  interceptors += ConnectInterceptor</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!forWebSocket) &#123;</span><br><span class=\"line\">    interceptors += client.networkInterceptors</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 这是链中的最后一个拦截器。 它对服务器进行网络调用,真正的网络请求从这里开始</span></span><br><span class=\"line\">  interceptors += CallServerInterceptor(forWebSocket)</span><br><span class=\"line\">  <span class=\"comment\">// 构建网络请求链 - 一个具体的拦截器链，承载着整个拦截器链：所有应用程序拦截器、OkHttp核心、所有网络拦截器，最后是网络调用者。</span></span><br><span class=\"line\">  <span class=\"keyword\">val</span> chain = RealInterceptorChain(</span><br><span class=\"line\">      call = <span class=\"keyword\">this</span>,</span><br><span class=\"line\">      interceptors = interceptors,</span><br><span class=\"line\">      index = <span class=\"number\">0</span>,</span><br><span class=\"line\">      exchange = <span class=\"literal\">null</span>,</span><br><span class=\"line\">      request = originalRequest,</span><br><span class=\"line\">      connectTimeoutMillis = client.connectTimeoutMillis,</span><br><span class=\"line\">      readTimeoutMillis = client.readTimeoutMillis,</span><br><span class=\"line\">      writeTimeoutMillis = client.writeTimeoutMillis</span><br><span class=\"line\">  )</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> calledNoMoreExchanges = <span class=\"literal\">false</span></span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> response = chain.proceed(originalRequest)</span><br><span class=\"line\">    <span class=\"comment\">// 是否取消请求</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isCanceled()) &#123;</span><br><span class=\"line\">      response.closeQuietly()</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> IOException(<span class=\"string\">&quot;Canceled&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> response</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (e: IOException) &#123;</span><br><span class=\"line\">    calledNoMoreExchanges = <span class=\"literal\">true</span></span><br><span class=\"line\">    <span class=\"keyword\">throw</span> noMoreExchanges(e) <span class=\"keyword\">as</span> Throwable</span><br><span class=\"line\">  &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!calledNoMoreExchanges) &#123;</span><br><span class=\"line\">      noMoreExchanges(<span class=\"literal\">null</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>RealInterceptorChain.kt</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Throws(IOException::class)</span></span><br><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">proceed</span><span class=\"params\">(request: <span class=\"type\">Request</span>)</span></span>: Response &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 判断拦截器是否为空</span></span><br><span class=\"line\">  check(index &lt; interceptors.size)</span><br><span class=\"line\">  <span class=\"comment\">// 请求数加1</span></span><br><span class=\"line\">  calls++</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (exchange != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    check(exchange.finder.sameHostAndPort(request.url)) &#123;</span><br><span class=\"line\">      <span class=\"string\">&quot;network interceptor <span class=\"subst\">$&#123;interceptors[index - <span class=\"number\">1</span>]&#125;</span> must retain the same host and port&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    check(calls == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">      <span class=\"string\">&quot;network interceptor <span class=\"subst\">$&#123;interceptors[index - <span class=\"number\">1</span>]&#125;</span> must call proceed() exactly once&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// Call the next interceptor in the chain. 调用链中的下一个拦截器</span></span><br><span class=\"line\">  <span class=\"keyword\">val</span> next = copy(index = index + <span class=\"number\">1</span>, request = request)</span><br><span class=\"line\">  <span class=\"comment\">// 获取当前的拦截器</span></span><br><span class=\"line\">  <span class=\"keyword\">val</span> interceptor = interceptors[index]</span><br><span class=\"line\">  <span class=\"comment\">// 开始一个个的执行每一个拦截器，每个拦截器的intercept都会调到 当前类的proceed ，直至最后一个CallServerInterceptor执行完</span></span><br><span class=\"line\">  <span class=\"meta\">@Suppress(<span class=\"meta-string\">&quot;USELESS_ELVIS&quot;</span>)</span></span><br><span class=\"line\">  <span class=\"keyword\">val</span> response = interceptor.intercept(next) ?: <span class=\"keyword\">throw</span> NullPointerException(<span class=\"string\">&quot;interceptor <span class=\"variable\">$interceptor</span> returned null&quot;</span>)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (exchange != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    check(index + <span class=\"number\">1</span> &gt;= interceptors.size || next.calls == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">      <span class=\"string\">&quot;network interceptor <span class=\"variable\">$interceptor</span> must call proceed() exactly once&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  check(response.body != <span class=\"literal\">null</span>) &#123; <span class=\"string\">&quot;interceptor <span class=\"variable\">$interceptor</span> returned a response with no body&quot;</span> &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> response</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"chain\">Chain<a title=\"#chain\" href=\"#chain\"></a></h4>\n<blockquote>\n<p>Interceptor 与 Chain 彼此互相依赖，互相调用，共同发展，形成了一个完美的调用链</p>\n</blockquote>\n<p>Chain 被用来描述责任链，通过其中的 process 方法开始依次执行链上的每个节点，并返回处理后的 Response。<br>\nChain 的唯一实现为 RealInterceptorChain（下文简称 RIC），RIC 可以称之为<strong>拦截器责任链</strong>，其中的节点由 RealCall 中添加进来的 Interceptor 们组成。由于 Interceptor 的互相独立性，RIC 中还会包含一些公共参数及共享的对象。</p>\n<p><img src=\"https://z3.ax1x.com/2021/10/25/5hbpJx.png\" alt=\"5hbpJx.png\" loading=\"lazy\" class=\"φbp\"></p>\n<h3 id=\"about\">About<a title=\"#about\" href=\"#about\"></a></h3>\n<p><a href=\"https://zhuanlan.zhihu.com/p/116777864\" target=\"_blank\">OkHttp源码深度解析</a><br>\n<a href=\"https://zhuanlan.zhihu.com/p/104813091\" target=\"_blank\">OkHttp源码解析</a><br>\n<a href=\"https://juejin.cn/post/7020027832977850381\" target=\"_blank\">OkHttp源码原理</a></p>\n",
            "tags": [
                "源码解析"
            ]
        },
        {
            "id": "https://onion99.github.io/2021/11/01/5FIszA6Ut2OHE8Sg/",
            "url": "https://onion99.github.io/2021/11/01/5FIszA6Ut2OHE8Sg/",
            "title": "安卓优化-布局优化",
            "date_published": "2021-10-31T20:50:14.000Z",
            "content_html": "<h3 id=\"布局耗时统计\">布局耗时统计<a title=\"#布局耗时统计\" href=\"#布局耗时统计\"></a></h3>\n<ul>\n<li>手动埋点</li>\n<li>AOP/ArtHook\n<ul>\n<li>切入Activity的setContentView</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"布局加载优化\">布局加载优化<a title=\"#布局加载优化\" href=\"#布局加载优化\"></a></h3>\n<ul>\n<li>代码写布局\n<ul>\n<li>Java代码写布局</li>\n<li>Anko</li>\n<li>JetpackCompose</li>\n</ul>\n</li>\n<li>X2C</li>\n<li>Litho</li>\n</ul>\n<span id=\"more\"></span>\n<h3 id=\"视图绘制优化\">视图绘制优化<a title=\"#视图绘制优化\" href=\"#视图绘制优化\"></a></h3>\n<ul>\n<li>优化布局层级以及嵌套\n<ul>\n<li>使用ConstraintLayout</li>\n</ul>\n</li>\n<li>避免过度绘制,自定义View避免多次调用 onDraw,onMeasure</li>\n<li>其他\n<ul>\n<li>ViewStub: 延迟初始化</li>\n<li>onDraw,onMeasure中避免创建大对象,耗时操作</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"include\">Include<a title=\"#include\" href=\"#include\"></a></h4>\n<blockquote>\n<p>提高布局复用性</p>\n</blockquote>\n<p>login.xml</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">include</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:layout_width</span>=<span class=\"string\">&quot;match_parent&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:layout_height</span>=<span class=\"string\">&quot;40dp&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">layout</span>=<span class=\"string\">&quot;@layout/titlebar&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n<p>include所在的layout的布局有给其设置id, 而include标签里面又给自己的根容器设置id,最好两个id都相同,否则findview时拿到空对象</p>\n<h4 id=\"merge\">Merge<a title=\"#merge\" href=\"#merge\"></a></h4>\n<blockquote>\n<p>帮助include标签排除多余的一层ViewGroup容器，减少view hierarchy的结构，提升UI渲染的性能</p>\n</blockquote>\n<p>titlebar.xml</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">merge</span> <span class=\"attr\">xmlns:android</span>=<span class=\"string\">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;</span></span><br><span class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">Button</span> </span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:layout_width</span>=<span class=\"string\">&quot;match_parent&quot;</span>  </span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:layout_height</span>=<span class=\"string\">&quot;wrap_content&quot;</span>  </span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:layout_marginLeft</span>=<span class=\"string\">&quot;20dp&quot;</span>  </span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:layout_marginRight</span>=<span class=\"string\">&quot;20dp&quot;</span>  </span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:text</span>=<span class=\"string\">&quot;标题&quot;</span> /&gt;</span>  </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">merge</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>因为merge标签并不是View,所以在通过LayoutInflate.inflate()方法渲染的时候,第二个参数必须指定一个父容器(parent),且第三个参数(attachToRoot)必须为true</li>\n<li>merge标签必须使用在根布局，并且ViewStub标签中的layout布局不能使用merge标签</li>\n</ul>\n<h4 id=\"viewstub\">ViewStub<a title=\"#viewstub\" href=\"#viewstub\"></a></h4>\n<blockquote>\n<p>延迟绘制View</p>\n</blockquote>\n<p>layout.xml</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ViewStub</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:id</span>=<span class=\"string\">&quot;@+id/viewstub&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:layout_width</span>=<span class=\"string\">&quot;match_parent&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:layout_height</span>=<span class=\"string\">&quot;wrap_content&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:layout</span>=<span class=\"string\">&quot;@layout/info&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n<p>activity.java</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ViewStub stub = ((ViewStub) findViewById(R.id.viewstub));</span><br><span class=\"line\"><span class=\"keyword\">if</span>(stub!=<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">    View stubView = stub.inflate();</span><br><span class=\"line\">    EditText editText = (EditText) stubView.findViewById(R.id.edit_password);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>ViewStub标签不支持merge标签</li>\n<li>ViewStub的inflate只能被调用一次,第二次调用会抛出异常</li>\n<li>虽然ViewStub是不占用任何空间的，但是每个布局都必须要指定layout_width和layout_height属性，否则运行就会报错</li>\n</ul>\n",
            "tags": [
                "性能优化"
            ]
        },
        {
            "id": "https://onion99.github.io/2021/11/01/6JN9JxpnRSjVeWry/",
            "url": "https://onion99.github.io/2021/11/01/6JN9JxpnRSjVeWry/",
            "title": "安卓优化-线程优化",
            "date_published": "2021-10-31T20:48:51.000Z",
            "content_html": "<h3 id=\"线程调度\">线程调度<a title=\"#线程调度\" href=\"#线程调度\"></a></h3>\n<blockquote>\n<p>任意时刻，只有一个线程占用CPU，处于运行状态</p>\n</blockquote>\n<p>多线程并发：轮流获取cpu使用权<br>\nJVM负责线程调度：按照特定调度模型分配CPU使用权</p>\n<h4 id=\"调度模型\">调度模型<a title=\"#调度模型\" href=\"#调度模型\"></a></h4>\n<ul>\n<li>分时调度模型: 轮流获取,均匀分配cpu时间</li>\n<li>抢占式调度模型:  按照优先级来</li>\n</ul>\n<span id=\"more\"></span>\n<h3 id=\"android异步方式\">Android异步方式<a title=\"#android异步方式\" href=\"#android异步方式\"></a></h3>\n<ul>\n<li>Thread\n<ul>\n<li>最简单、常见的方式</li>\n<li>不易复用，频繁创建销毁开销大</li>\n</ul>\n</li>\n<li>HandlerThread\n<ul>\n<li>自带消息循环的线程</li>\n<li>串行执行,长时间运行，不断从队列中获取任务</li>\n</ul>\n</li>\n<li>IntentService\n<ul>\n<li>继承自Service在内部创建HandlerThread</li>\n<li>异步、不占用主线程</li>\n<li>优先级高，不易被系统kil</li>\n</ul>\n</li>\n<li>AsyncTask\n<ul>\n<li>Android提供的工具类</li>\n<li>无需自己处理线程切换</li>\n</ul>\n</li>\n<li>线程池\n<ul>\n<li>jdk提供的线程池</li>\n<li>易复用，减少频繁创建、销毁的时间</li>\n<li>功能强大：定时、任务列队、并发数控制等</li>\n</ul>\n</li>\n<li>RxJava\n<ul>\n<li>由强大的Scheduler集合提供</li>\n<li>不同类型的区分：IO密集型、CPU密集型</li>\n</ul>\n</li>\n<li>协程</li>\n</ul>\n<h3 id=\"线程使用准则\">线程使用准则<a title=\"#线程使用准则\" href=\"#线程使用准则\"></a></h3>\n<p>1、严禁使用new Thread,因为这样不便控制,可能产生预期之外的事情<br>\n2、提供基础线程池供各个业务栈使用（避免各个业务栈各自维护一套线程池，导致线程数过多）<br>\n3、根据任务类型选择合适的异步方式（优先级低长时间执行-HandlerThread，定时执行-线程池）<br>\n4、创建线程必须命名（方便定位线程归属，运行期Thread.currentThread().setName修改名字）<br>\n5、关键异步任务监控（异步不等于不耗时，AOP的方式来做监控）<br>\n6、重视优先级的设置（Process.setThreadPriority(),可以设置多次）</p>\n",
            "tags": [
                "性能优化"
            ]
        },
        {
            "id": "https://onion99.github.io/2021/11/01/9LsQhIFgDkllFt0Q/",
            "url": "https://onion99.github.io/2021/11/01/9LsQhIFgDkllFt0Q/",
            "title": "安卓优化-包体积",
            "date_published": "2021-10-31T20:48:08.000Z",
            "content_html": "<p><a href=\"https://cloud.tencent.com/developer/article/1425318\" target=\"_blank\">Android APP 终极瘦身指南</a></p>\n<ul>\n<li>图片转WebP</li>\n<li>去掉不必要的so库</li>\n<li>开启shrinkResources去除无用资源</li>\n<li>开启minifyEnabled混淆代码</li>\n<li>删除无用的语言资源</li>\n<li>使用微信资源压缩打包工具</li>\n<li>避免重复库,以及避免不同版本的库</li>\n<li>AndroidManifest中 -&gt; android:extractNativeLibs=“true”</li>\n</ul>\n",
            "tags": [
                "性能优化"
            ]
        },
        {
            "id": "https://onion99.github.io/2021/11/01/UYa5EEntsM9sKTYz/",
            "url": "https://onion99.github.io/2021/11/01/UYa5EEntsM9sKTYz/",
            "title": "安卓优化-卡顿优化",
            "date_published": "2021-10-31T20:47:12.000Z",
            "content_html": "<blockquote>\n<p>卡顿产生的根本原因就是CPU和GPU没有及时处理好数据，针对卡顿的优化就有思路了：尽可能减少 CPU 和 GPU 资源的消耗</p>\n</blockquote>\n<ul>\n<li>CPU：中央处理器（CPU，central processing unit）作为计算机系统的运算和控制核心，是信息处理、程序运行的最终执行单元</li>\n<li>GPU：图形处理器（英语：Graphics Processing Unit，缩写：GPU），又称显示核心,做图像和图形相关运算工作的微处理器</li>\n</ul>\n<h3 id=\"卡顿检测\">卡顿检测<a title=\"#卡顿检测\" href=\"#卡顿检测\"></a></h3>\n<p><a href=\"https://blog.csdn.net/lmj623565791/article/details/58626355\" target=\"_blank\">Android UI性能优化 检测应用中的UI卡顿</a></p>\n<p><a href=\"https://www.jianshu.com/p/9e8f88eac490\" target=\"_blank\">Android性能优化-检测App卡顿 - 简书 (jianshu.com)</a></p>\n<span id=\"more\"></span>\n<h4 id=\"用ui线程looper打印的日志\">用UI线程Looper打印的日志<a title=\"#用ui线程looper打印的日志\" href=\"#用ui线程looper打印的日志\"></a></h4>\n<p>开源工具:<br>\n<a href=\"https://github.com/Kyson/AndroidGodEye\" target=\"_blank\">Kyson/AndroidGodEye: An app performance monitor(APM) , like “Android Studio profiler”, you can easily monitor the performance of your app real time in browser (github.com)</a></p>\n<p><a href=\"https://github.com/markzhai/AndroidPerformanceMonitor\" target=\"_blank\">markzhai/AndroidPerformanceMonitor: A transparent ui-block detection library for Android. (known as BlockCanary) </a></p>\n<p><a href=\"https://github.com/BzCoder/BlockCanaryCompat\" target=\"_blank\">BzCoder/BlockCanaryCompat: 卡顿监控，BlockCanary 适配Android O 以上系统 (github.com)</a></p>\n<h4 id=\"choreographer\">Choreographer<a title=\"#choreographer\" href=\"#choreographer\"></a></h4>\n<p>Android系统每隔16ms发出VSYNC信号，触发对UI进行渲染。开发者可以使用Choreographer#postFrameCallback设置自己的callback与Choreographer交互，你设置的FrameCallCack（doFrame方法）会在下一个frame被渲染时触发。理论上来说两次回调的时间周期应该在16ms，如果超过了16ms我们则认为发生了卡顿，我们主要就是利用两次回调间的时间周期来判断</p>\n<p>开源工具:<br>\n<a href=\"https://github.com/wasabeef/Takt\" target=\"_blank\">wasabeef/Takt: Takt is Android library for measuring the FPS using Choreographer</a></p>\n<p><a href=\"https://github.com/friendlyrobotnyc/TinyDancer\" target=\"_blank\">friendlyrobotnyc/TinyDancer: An android library for displaying fps from the choreographer and percentage of time with two or more frames dropped </a></p>\n<h3 id=\"anr分析\">ANR分析<a title=\"#anr分析\" href=\"#anr分析\"></a></h3>\n<blockquote>\n<p>Application Not Responding，也就是应用程序无响应</p>\n</blockquote>\n<h4 id=\"产生原因\">产生原因<a title=\"#产生原因\" href=\"#产生原因\"></a></h4>\n<ul>\n<li>InputDispatching Timeout：5秒内无法响应屏幕触摸事件或键盘输入事件</li>\n<li>BroadcastQueue Timeout ：在执行前台广播（BroadcastReceiver）的<code>onReceive()</code>函数时10秒没有处理完成，后台为60秒</li>\n<li>Service Timeout：前台服务20秒内，后台服务在200秒内没有执行完毕</li>\n<li>ContentProvider Timeout：ContentProvider的publish在10s内没进行完</li>\n<li>其他\n<ul>\n<li>主线程阻塞或主线程数据读取</li>\n<li>CPU满负荷，I/O阻塞</li>\n<li>内存不足</li>\n</ul>\n</li>\n</ul>\n<p>分析:</p>\n<ul>\n<li>log上的anr reason</li>\n<li>adb 导出ANR日志\n<ul>\n<li><code>adb pull /data/anr/traces.txt</code></li>\n</ul>\n</li>\n</ul>\n",
            "tags": [
                "性能优化"
            ]
        },
        {
            "id": "https://onion99.github.io/2021/11/01/T8ghe13OAeLx6NBP/",
            "url": "https://onion99.github.io/2021/11/01/T8ghe13OAeLx6NBP/",
            "title": "安卓优化-内存优化",
            "date_published": "2021-10-31T20:46:21.000Z",
            "content_html": "<h3 id=\"内存信息查看\">内存信息查看<a title=\"#内存信息查看\" href=\"#内存信息查看\"></a></h3>\n<p><a href=\"https://www.jianshu.com/p/28b9cd87e667\" target=\"_blank\">App内存优化实践：一步一步做内存分析与优化</a></p>\n<p>查看每个App进程可以分配到的最大内存</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">adb shell getprop | grep dalvik.vm.heapsize</span><br></pre></td></tr></table></figure>\n<p>App的内存使用情况概览</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">adb shell dumpsys meminfo 包名</span><br></pre></td></tr></table></figure>\n<h3 id=\"优化工具\">优化工具<a title=\"#优化工具\" href=\"#优化工具\"></a></h3>\n<ul>\n<li>CPU Profiler</li>\n<li>Memory Analyzer（MAT）</li>\n<li>LeakCannary</li>\n</ul>\n<span id=\"more\"></span>\n<h3 id=\"优化方向\">优化方向<a title=\"#优化方向\" href=\"#优化方向\"></a></h3>\n<p><a href=\"https://www.cnblogs.com/wangjie1990/p/11327112.html\" target=\"_blank\">Android 如何优化APP内存 </a></p>\n<ul>\n<li>谨慎使用Services\n<ul>\n<li>启动一个Service时， 系统需要始终保持运行该Service的进程,该Service占用的RAM对其他进程不共享</li>\n<li>避免使用持久性服务,如<code>JobScheduler</code>之类</li>\n</ul>\n</li>\n<li>使用经过优化的多数据容器\n<ul>\n<li>如SparseArray，SparseBooleanArray和LongSparseArray</li>\n<li>如有必要，您可以随时切换到原始数组以获得精简的数据结构</li>\n</ul>\n</li>\n<li>使用nano protobufs进行序列化数据</li>\n<li>避免内存泄漏\n<ul>\n<li>内存泄露会导致大量的垃圾收集事件发生,从而导致系统执行其他内容(如渲染或者传输)的时间变少</li>\n</ul>\n</li>\n<li>移除内存密集型资源，以及lib库\n<ul>\n<li>减小APK的大小</li>\n<li>请使用不进行反射扫描的依赖注入库(Dagger2),频繁的反射需要更多的CPU和内存消耗</li>\n<li>谨慎使用外部库,外部库可能对同一个功能有不一样的实现,这可能导致预期之外的事情</li>\n</ul>\n</li>\n</ul>\n",
            "tags": [
                "性能优化"
            ]
        },
        {
            "id": "https://onion99.github.io/2021/11/01/4LlbPfdOOCp58LMK/",
            "url": "https://onion99.github.io/2021/11/01/4LlbPfdOOCp58LMK/",
            "title": "安卓优化-启动优化",
            "date_published": "2021-10-31T20:43:04.000Z",
            "content_html": "<h3 id=\"启动流程\">启动流程<a title=\"#启动流程\" href=\"#启动流程\"></a></h3>\n<h4 id=\"相关\">相关<a title=\"#相关\" href=\"#相关\"></a></h4>\n<blockquote>\n<p>启动的流程就是通过这六个大类在这三个进程之间不断通信的过程</p>\n</blockquote>\n<h5 id=\"三个进程\">三个进程<a title=\"#三个进程\" href=\"#三个进程\"></a></h5>\n<ul>\n<li>Launcher进程: 整个App启动流程的起点,负责处理桌面与用户之间的交互事件,可以想象为一个桌面启动器</li>\n<li>SystemServer进程: Android中的所有SystemServer都由其孵化(Fork)出来,例如AMS,WindowsMannager,PackageManagerService等</li>\n<li>App进程: 启动的App所在的进程</li>\n</ul>\n<span id=\"more\"></span>\n<h5 id=\"六个大类\">六个大类<a title=\"#六个大类\" href=\"#六个大类\"></a></h5>\n<ul>\n<li>ActivityManagerService:  即AMS,负责管理系统中四大组件的启动,切换,调度以及应用进程的管理</li>\n<li>Instrumentation: 监控应用程序和系统的交互</li>\n<li>ActivityThread: 应用的入口类，通过调用main方法，开启消息循环队列。ActivityThread所在的线程被称为主线程</li>\n<li>ApplicationThread: 提供Binder通讯接口，AMS则通过代理调用此App进程的本地方法</li>\n<li>ActivityManagerProxy：AMS服务在当前进程的代理类，负责与AMS通信</li>\n<li>ApplicationThreadProxy：ApplicationThread在AMS服务中的代理类，负责与ApplicationThread通信</li>\n</ul>\n<h4 id=\"顺序\">顺序<a title=\"#顺序\" href=\"#顺序\"></a></h4>\n<p><a href=\"https://blog.csdn.net/huangliniqng/article/details/89364064\" target=\"_blank\">APP启动流程解析,墙裂推荐</a><br>\n<a href=\"https://www.cnblogs.com/not2/p/14326090.html\" target=\"_blank\">App启动速度优化 T2</a><br>\n<a href=\"https://blog.csdn.net/huangliniqng/article/details/89364064\" target=\"_blank\">具体代码流程</a></p>\n<ol>\n<li>Launcher通知AMS, 要启动某一应用,并说明对应的LauncherActivity</li>\n<li>AMS表示收到, 等待Launcher进入Pause状态</li>\n<li>Launcher进入Pause状态, 通知AMS可以启动某一应用了</li>\n<li>AMS开始检查某一应用是否启动\n<ul>\n<li>是,则直接启动,流程终止</li>\n<li>否,AMS则在的进程中创建ActivityThread对象,并启动main函数</li>\n</ul>\n</li>\n<li>某一应用通知AMS启动准备就绪</li>\n<li>AMS通知某一应用要启动的页面,某一应用启动对应页面</li>\n</ol>\n<p><img src=\"https://z3.ax1x.com/2021/10/27/57Z1PJ.png\" alt=\"57Z1PJ.png\" loading=\"lazy\" class=\"φbp\"></p>\n<h3 id=\"启动分类\">启动分类<a title=\"#启动分类\" href=\"#启动分类\"></a></h3>\n<ul>\n<li>冷启动\n<ul>\n<li>耗时最多,优化重点</li>\n<li><img src=\"https://z3.ax1x.com/2021/10/27/57ZxJJ.png\" alt=\"57ZxJJ.png\" loading=\"lazy\" class=\"φbp\"></li>\n</ul>\n</li>\n<li>热启动\n<ul>\n<li>最快.即后台到前台的切换</li>\n</ul>\n</li>\n<li>温启动\n<ul>\n<li>较快,只重走Activity的生命周期,即销毁后重建</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"耗时统计\">耗时统计<a title=\"#耗时统计\" href=\"#耗时统计\"></a></h3>\n<h4 id=\"systrace\">Systrace<a title=\"#systrace\" href=\"#systrace\"></a></h4>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TraceCompat.beginSection(<span class=\"string\">&quot;sectionName&quot;</span>)</span><br><span class=\"line\">TraceCompat.endSection();</span><br></pre></td></tr></table></figure>\n<p><code>python systrace.py -t 10 [other-options] [categories]</code></p>\n<h4 id=\"traceview\">Traceview<a title=\"#traceview\" href=\"#traceview\"></a></h4>\n<p><img src=\"https://z3.ax1x.com/2021/10/27/57llge.png\" alt=\"57llge.png\" loading=\"lazy\" class=\"φbp\"></p>\n<p>使用方式</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Debug.startMethodTracing(<span class=\"string\">&quot;fileName&quot;</span>)</span><br><span class=\"line\">Debug.stopMethodTracing()</span><br></pre></td></tr></table></figure>\n<p>运行之后可以在目录下生成文件：内部存储/android/data/${application}/files/fileName.trace，此文件可以使用Android Studio Profile打开</p>\n<ul>\n<li>Wall Clock time : 是线程真正执行的时间</li>\n<li>Thread time : CPU执行的时间,比Wall Clock Time少,不包含锁时间,等待时间</li>\n<li>Top Down:就是函数的调用列表</li>\n<li>Call Chart: 系统Api黄色，应用调用的方法绿色，第三方Api(java sdk也属于第三方)蓝色</li>\n<li>Flame Chart:  主要的作用是收集调用方法的时间，比如多次调用LayoutInflate.inflate，Flame Chart会把他们都收集到一起。</li>\n<li>Bottom Up: 和Top Down是相反的</li>\n</ul>\n<h4 id=\"adb-命令统计\">Adb 命令统计<a title=\"#adb-命令统计\" href=\"#adb-命令统计\"></a></h4>\n<p><code>adb shell am start -S -W 包名/启动类的全限定名</code></p>\n<p>ThisTime : 最后一个 Activity 的启动耗时<br>\nTotalTime : 启动一连串的 Activity 总耗时<br>\nWaitTime : 应用进程的创建过程 + TotalTime</p>\n<h4 id=\"系统日志统计\">系统日志统计<a title=\"#系统日志统计\" href=\"#系统日志统计\"></a></h4>\n<p>过滤<code>displayed</code>输出的启动日志</p>\n<p><img src=\"https://z3.ax1x.com/2021/10/27/57mU4e.png\" alt=\"57mU4e.png\" loading=\"lazy\" class=\"φbp\"></p>\n<h3 id=\"冷启动优化\">冷启动优化<a title=\"#冷启动优化\" href=\"#冷启动优化\"></a></h3>\n<p><a href=\"https://jishuin.proginn.com/p/763bfbd345f0\" target=\"_blank\"> App 启动时间优化详解</a></p>\n<p>优化方向:</p>\n<ul>\n<li>延迟加载 / 懒加载</li>\n<li>异步线程执行耗时操作，如图片加载、网络访问、IO操作等</li>\n<li>ViewStub的使用</li>\n<li>减少布局层次和嵌套布局</li>\n</ul>\n",
            "tags": [
                "性能优化"
            ]
        }
    ]
}